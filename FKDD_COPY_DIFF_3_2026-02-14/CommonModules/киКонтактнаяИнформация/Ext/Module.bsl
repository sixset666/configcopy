

// Функция формирует структуру записи регистра.
//
// Параметры:
//	Запись	- РегистрСведенийЗапись - Запись регистра сведений
//
// Возвращаемое значение:
//	Структура - Структура записи
//
Функция киПолучитьСтруктуруЗаписиРегистра(Запись) Экспорт

	Если ТипЗнч(Запись) = Тип("РегистрСведенийЗапись.КонтактнаяИнформация")
	 ИЛИ ТипЗнч(Запись) = Тип("РегистрСведенийМенеджерЗаписи.КонтактнаяИнформация") Тогда
		СтруктураЗаписи = Новый Структура;
		СтруктураЗаписи.Вставить("Объект"      		   , Запись.Объект);
		СтруктураЗаписи.Вставить("Тип"     		       , Запись.Тип);
		СтруктураЗаписи.Вставить("Вид"      	       , Запись.Вид);
		СтруктураЗаписи.Вставить("Представление"	   , Запись.Представление);
		СтруктураЗаписи.Вставить("Комментарий"  	   , Запись.Комментарий);
		СтруктураЗаписи.Вставить("КраткоеПредставление", Запись.КраткоеПредставление);
		СтруктураЗаписи.Вставить("ГородскойРайон"      , Запись.ГородскойРайон);
		СтруктураЗаписи.Вставить("СтанцияМетро"        , Запись.СтанцияМетро);
		СтруктураЗаписи.Вставить("ТипДома" 		  	   , Запись.ТипДома);
		СтруктураЗаписи.Вставить("ТипКорпуса"      	   , Запись.ТипКорпуса);
		СтруктураЗаписи.Вставить("ТипКвартиры"         , Запись.ТипКвартиры);
		
		Для а = 1 По 12 Цикл
			СтруктураЗаписи.Вставить("Поле" + Строка(а), Запись["Поле" + Строка(а)]);
		КонецЦикла;
		Возврат СтруктураЗаписи;
	Иначе
		Возврат Неопределено;
	КонецЕсли; 

КонецФункции // киПолучитьСтруктуруЗаписиРегистра()

#Если Клиент Тогда
// Процедура открывает данные из Контактной информации
//
// Параметры:
//  Данные - ТабличноеПоле.ТекущиеДанные или Структура - Содержит параметры для открытия КИ
//
Процедура киОткрытьСсылкуИзКИ(Данные) Экспорт                        
	Тип = Данные.Тип;
	Представление = СокрЛП(Данные.Представление);
	Если НЕ ПустаяСтрока(Представление) Тогда
		Если Тип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда	
			ПозицияПодстроки = Найти(Представление,"mailto:");
			Если ПозицияПодстроки>0 Тогда
				АдресПочты = СокрЛП(Сред(Представление, ПозицияПодстроки+7));
			Иначе
				АдресПочты = Представление;
			КонецЕсли; 
			НовоеПисьмо = Документы.ЭлектронноеПисьмо.СоздатьДокумент();
			Получатель = НовоеПисьмо.Получатели.Добавить();
			Получатель.КодГруппыАдреса = Перечисления.КодГруппыАдресаЭлектронногоПисьма.Кому;
			Получатель.АдресЭлектроннойПочты = АдресПочты;
			Получатель.Представление = Данные.Объект.Наименование;
			Получатель.СсылкаНаОбъект = Данные.Объект.Ссылка;
			Если НЕ обПраво("ИспользоватьВстроенныйКлиент") Тогда
				НовоеПисьмо.ДополнительныеСвойства.Вставить("ОтправитьВнешнимКлиентом",Истина);
			КонецЕсли;
			НовоеПисьмо.ПолучитьФорму().Открыть();
			
		ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
			СтрокаЗапуска = Представление;
			Попытка
				ЗапуститьПриложение(СтрокаЗапуска);
			Исключение
			КонецПопытки;			
		ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.НомерICQ Тогда
			СтрокаЗапуска = "http://www.icq.com/whitepages/cmd.php?uin=" + Представление + "&action=message";
			Попытка
				ЗапуститьПриложение(СтрокаЗапуска);
			Исключение
			КонецПопытки;
		ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
			//ПолучаемПраваНаИспользования SMS
			СписокДействий = Новый СписокЗначений;
			ОбработкаСПравами = Обработки.Защита.Создать();
			Права = ОбработкаСПравами.Права;
			ПравоНаРаботуСSMS = кмПравоНаРаботуСSMS(Права);
			Если ПравоНаРаботуСSMS И Данные.Вид = Справочники.ВидыКонтактнойИнформации.ТелефонСотовый Тогда
				СписокДействий.Добавить("Создать SMS");
			КонецЕсли;
			//Получаем право на использования СофтФона
			Если сфпСофтФонПроСервер.сфпПолучитьЗначениеНастройкиПользователя("сфпИспользоватьСофтФон") Тогда
				СписокДействий.Добавить("Создать событие и позвонить");
				СписокДействий.Добавить("Позвонить");
			КонецЕсли;
			Если СписокДействий.Количество()>1 Тогда
				ВыбранноеДействие = СписокДействий.ВыбратьЭлемент("Выберите действие:");
			ИначеЕсли СписокДействий.Количество()=1 Тогда
				ВыбранноеДействие = СписокДействий[0];
			ИначеЕсли СписокДействий.Количество()=0 Тогда
				ВыбранноеДействие = Неопределено;	
			КонецЕсли;
			
			Если НЕ ВыбранноеДействие = Неопределено Тогда
				ЗначениеВыбора = ВыбранноеДействие.Значение;
				Если ЗначениеВыбора = "Создать SMS" Тогда
					кмОтправитьSMS(Представление,"",Неопределено,Неопределено,Неопределено,Неопределено,Неопределено,Неопределено,Перечисления.ВариантыОтветов.Спрашивать);
				ИначеЕсли ЗначениеВыбора = "Создать событие и позвонить" Тогда
					кмсфпСоздатьСобытиеИПозвонить(Данные);
				ИначеЕсли ЗначениеВыбора = "Позвонить" Тогда
					кмсфпПозвонитьПоНомеру(Данные);
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
КонецПроцедуры // киОткрытьСсылкуИзКИ()
#КонецЕсли

// Функция возвращает для заданного объекта представление контактной информации
//
// Параметры:
//  Объект  			 – СправочникСсылка - Объект, для которого нужно получить представление
//  ЗначениеКИ 			 - СправочникСсылка или ПеречислениеСсылка - Значение контактной информации
//  ДобавлятьКомментарий - Булево 			- Признак добавления комментария
//
// Возвращаемое значение:
//   Строка   – представление контактной информации или пустая строка, если значение не найдено.
//
Функция киПолучитьПредставлениеКИ(Объект, ЗначениеКИ, ДобавлятьКомментарий = Ложь) Экспорт

	Представление = "";
	
	НаборЗаписейКИ = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
	НаборЗаписейКИ.Отбор.Объект.Значение      = Объект;
	НаборЗаписейКИ.Отбор.Объект.Использование = Истина;
	Если ТипЗнч(ЗначениеКИ) = Тип("СправочникСсылка.ВидыКонтактнойИнформации") Тогда
		НаборЗаписейКИ.Отбор.Вид.Значение      = ЗначениеКИ;
		НаборЗаписейКИ.Отбор.Вид.Использование = Истина;
		НаборЗаписейКИ.Прочитать();
		Если НаборЗаписейКИ.Количество() > 0  Тогда
			Представление = НаборЗаписейКИ[0].Представление;
			Если ДобавлятьКомментарий И Не ПустаяСтрока(НаборЗаписейКИ[0].Комментарий) Тогда
				Если НаборЗаписейКИ[0].Тип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
					Представление = Представление + Символы.ПС + "Комментарий: " + НаборЗаписейКИ[0].Комментарий;
				Иначе
					Представление = Представление + " (" + НаборЗаписейКИ[0].Комментарий + ")";
				КонецЕсли;
			КонецЕсли;	
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(ЗначениеКИ) = Тип("ПеречислениеСсылка.ТипыКонтактнойИнформации") Тогда
		НаборЗаписейКИ.Отбор.Тип.Значение      = ЗначениеКИ;
		НаборЗаписейКИ.Отбор.Тип.Использование = Истина;
		НаборЗаписейКИ.Прочитать();
		Представление = "";
		Для каждого Запись Из НаборЗаписейКИ Цикл
			Если Запись.ЗначениеПоУмолчанию Тогда
				Представление = Запись.Представление;
				Если ДобавлятьКомментарий И Не ПустаяСтрока(Запись.Комментарий) Тогда
					Если Запись.Тип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
						Представление = Представление + Символы.ПС + "Комментарий: " + Запись.Комментарий;
					Иначе
						Представление = Представление + " (" + Запись.Комментарий + ")";
					КонецЕсли;
				КонецЕсли;
				Прервать;
			КонецЕсли;
		КонецЦикла; 
	КонецЕсли; 
	
	Возврат Представление;
	
КонецФункции // киПолучитьПредставлениеКИ()

// Функция возвращает для заданного объекта город из контактной информации
//
// Параметры:
//  Объект  			 – СправочникСсылка - Объект, для которого нужно получить представление
//  ЗначениеКИ 			 - СправочникСсылка - Значение контактной информации
//
// Возвращаемое значение:
//   Строка   – представление контактной информации или пустая строка, если значение не найдено.
//
Функция киПолучитьГород(Объект, ЗначениеКИ) Экспорт

	НаборЗаписейКИ = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
	НаборЗаписейКИ.Отбор.Объект.Значение      = Объект;
	НаборЗаписейКИ.Отбор.Объект.Использование = Истина;
	Если ТипЗнч(ЗначениеКИ) = Тип("СправочникСсылка.ВидыКонтактнойИнформации") Тогда
		НаборЗаписейКИ.Отбор.Вид.Значение      = ЗначениеКИ;
		НаборЗаписейКИ.Отбор.Вид.Использование = Истина;
		НаборЗаписейКИ.Прочитать();
		Если НаборЗаписейКИ.Количество() > 0  Тогда
			город = НаборЗаписейКИ[0].Поле4;
			Если ЗначениеЗаполнено(город) Тогда
				Если Прав(город,2)=" г" Тогда
					Возврат "г. " + Лев(город, СтрДлина(город)-2);
				Иначе
					Возврат город; //поселок, пгт или что-то еще
				КонецЕсли;
			Иначе
				Если Найти(НаборЗаписейКИ[0].Поле2,"Москва") Тогда
					Возврат "г. Москва";
				ИначеЕсли Найти(НаборЗаписейКИ[0].Поле2,"Санкт-Петербург") Тогда
					Возврат "г. Санкт-Петербург";
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 
	
	Возврат "";
	
КонецФункции // киПолучитьПредставлениеКИ()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ПОДСТАНОВКИ АДРЕСА ПО КЛАССИФИКАТОРУ КЛАДР


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ПОДСТАНОВКИ АДРЕСА ПО КЛАССИФИКАТОРУ КЛАДР

// Функция возвращает строку адресного классификатора по значениям адресных элементов
Функция ВернутьСтрокуАдресногоКлассификатораПоАдреснымЭлементам(Знач НазваниеРегиона, Знач НазваниеРайона, Знач НазваниеГорода, 
											Знач НазваниеНаселенногоПункта, Знач НазваниеУлицы)
											
	РодительскийЭлемент = Неопределено;
	КодРодителяРодителя = 0;

	Регион = киПолучитьАдресныйЭлемент(НазваниеРегиона, 1);
	Если Регион.Код > 0 Тогда
		РодительскийЭлемент = Регион;
		КодРодителяРодителя = Регион.Код;
	КонецЕсли;
	
	Район = киПолучитьАдресныйЭлемент(НазваниеРайона, 2, КодРодителяРодителя);
	Если Район.Код > 0 Тогда
		РодительскийЭлемент = Район;
		КодРодителяРодителя = Район.Код;
	КонецЕсли;
	
	Город = киПолучитьАдресныйЭлемент(НазваниеГорода, 3, КодРодителяРодителя);
    Если Город.Код > 0 Тогда
		РодительскийЭлемент = Город;
		КодРодителяРодителя = Город.Код;
	КонецЕсли;
	
	НаселенныйПункт = киПолучитьАдресныйЭлемент(НазваниеНаселенногоПункта, 4, КодРодителяРодителя);
	Если НаселенныйПункт.Код > 0 Тогда
		РодительскийЭлемент = НаселенныйПункт;
		КодРодителяРодителя = НаселенныйПункт.Код;
	КонецЕсли;
	
	Улица = киПолучитьАдресныйЭлемент(НазваниеУлицы, 5, КодРодителяРодителя);
	Если Улица.Код > 0 Тогда
		РодительскийЭлемент = Улица;
		КодРодителяРодителя = Улица.Код;
	КонецЕсли;
	
	Если РодительскийЭлемент = Неопределено Тогда
		Возврат киПолучитьПустуюСтруктуруАдреса()
	Иначе
		Возврат РодительскийЭлемент;
	КонецЕсли;
										
КонецФункции

// Процедура добавляет не нулевое значение кода в структуру
Процедура ДобавитьКодВСтруктуру(ДанныеСтруктуры, ИмяЭлемента, КодЭлемента, УровеньРодителя, УровеньЭлемента)
	
	Если (КодЭлемента <> 0) ИЛИ (УровеньРодителя >= УровеньЭлемента) Тогда
		ДанныеСтруктуры.Вставить(ИмяЭлемента, КодЭлемента);
    КонецЕсли;
	
КонецПроцедуры

// Функция возвращает структуру ограничений по переданным параметрам
// уже заполненным адресным полям
//
// Параметры: 
// Параметры: 
//  НазваниеРегиона - название региона( с сокращением)
//  НазваниеРайона - название района( с сокращением)
//  НазваниеГорода - название города( с сокращением)
//  НазваниеНаселенногоПункта - название населенного пункта( с сокращением)
//
Функция ВернутьСтруктуруОграниченийПоРодителю(Знач НазваниеРегиона, Знач НазваниеРайона, Знач НазваниеГорода, 
											Знач НазваниеНаселенногоПункта, Знач НазваниеУлицы, КодРодителя) Экспорт
	
	СтруктураОграничений = Новый Структура();
	РодительскийЭлемент = ВернутьСтрокуАдресногоКлассификатораПоАдреснымЭлементам(НазваниеРегиона, НазваниеРайона, НазваниеГорода, 
											НазваниеНаселенногоПункта, НазваниеУлицы);
	
	КодРодителя = РодительскийЭлемент.Код;
	
	// по коду определяем уровень элемента
	ТипЭлемента = киПолучитьТипАдресногоЭлемента(КодРодителя);
	ДобавитьКодВСтруктуру(СтруктураОграничений, "КодРегионаВКоде", Цел(КодРодителя / киМаскаРегиона()), ТипЭлемента, 1);
    ДобавитьКодВСтруктуру(СтруктураОграничений, "КодРайонаВКоде", Цел(КодРодителя / киМаскаРайона()) % 1000, ТипЭлемента, 2);
	ДобавитьКодВСтруктуру(СтруктураОграничений, "КодГородаВКоде", Цел(КодРодителя / киМаскаГорода()) % 1000, ТипЭлемента, 3);
	ДобавитьКодВСтруктуру(СтруктураОграничений, "КодНаселенногоПунктаВКоде", Цел(КодРодителя / киМаскаНасПункта()) % 1000, ТипЭлемента, 4);
	ДобавитьКодВСтруктуру(СтруктураОграничений, "КодУлицыВКоде", Цел(КодРодителя / киМаскаУлицы())% 10000, ТипЭлемента, 5);
	
	Возврат СтруктураОграничений;
	
КонецФункции

//Функция по адресу возвращает структуру ограничений	
Функция ПолучитьСтруктуруОграниченийПоАдресу(ПолеРегиона, ПолеРайона, ПолеГорода, ПолеНаселенногоПункта, ИмяУлицы, УровеньЭлемента) Экспорт 
	
	Если УровеньЭлемента > 1 Тогда
		
		КодРодителя = Неопределено;
		СтруктураОграничений = ВернутьСтруктуруОграниченийПоРодителю(ПолеРегиона, ПолеРайона, ПолеГорода, ПолеНаселенногоПункта, ИмяУлицы, КодРодителя);
			
	Иначе
		СтруктураОграничений = Новый Структура();
	КонецЕсли;
	СтруктураОграничений.Вставить("ТипАдресногоЭлемента", УровеньЭлемента);
	
	Возврат СтруктураОграничений;
	
КонецФункции

// Функция определяет необходимый уровень для детализации имени адресного элемента
Функция киОпределитьУровеньДетализацииДляАдресногоЭлемента(ПолеРегиона, ПолеРайона, ПолеГорода, ПолеНаселенногоПункта, УровеньЭлемента) Экспорт
	
	НачальныйУровеньАдреса = 1;
	
	Если ЗначениеЗаполнено(ПолеРегиона) И (УровеньЭлемента >= 2) Тогда
		НачальныйУровеньАдреса = 2;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолеРайона) И (УровеньЭлемента >= 3) Тогда
		НачальныйУровеньАдреса = 3;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолеГорода) И (УровеньЭлемента >= 4) Тогда
		НачальныйУровеньАдреса = 4;	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПолеНаселенногоПункта) И (УровеньЭлемента >= 5) Тогда
		НачальныйУровеньАдреса = 5;	
	КонецЕсли;
	
	Возврат НачальныйУровеньАдреса;		
КонецФункции

// Процедура переносит строку из запроса в Структуру
Процедура ПеренестиСтрокуВыборкиВСтруктуру(РезультатЗапроса, СтрокаВыборки, СтруктураЭлемента)Экспорт 
	
	Если СтруктураЭлемента = Неопределено 
		ИЛИ РезультатЗапроса = Неопределено 
		ИЛИ СтрокаВыборки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЭлемента.Очистить();
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаВыборки[Колонка.Имя]);
	КонецЦикла;
	
КонецПроцедуры // ПеренестиСтрокуВыборкиВСтруктуру()

// процедура переносит значение из выборки в структуру
Процедура ОбработатьЕдинственныйЭлементВыбора(РезультатЗапроса, Выборка, Значение, ПолеВыбора, СтруктураВыбранногоЭлемента)
	
	Выборка.Следующий();
	Значение = Выборка[ПолеВыбора];
	ПеренестиСтрокуВыборкиВСтруктуру(РезультатЗапроса, Выборка, СтруктураВыбранногоЭлемента);	
	
КонецПроцедуры

// Функция формирует список выбора значений, для АдресногоКлассификатора
Функция СформироватьСписокВыбораАдресногоКлассификатора(ТаблицаЗапроса, Знач Текст, НачальныйУровеньДетализации, КонечныйУровеньДетализации)

	КЧ = Новый КвалификаторыЧисла(12,2);
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	ОписаниеТиповЧ = Новый ОписаниеТипов(Массив, , ,КЧ);
	
	ТаблицаЗапроса.Колонки.Добавить("УникальныйНомерСтроки", ОписаниеТиповЧ);
	
	СписокВозврата = Новый СписокЗначений;
	
	Текст = ВРег(Текст);
	ДлинаТекста = СтрДлина(Текст);
	
	НомерЭлемента = 0;
	Для Каждого СтрокаТаблицы Из ТаблицаЗапроса Цикл
		
		СтрокаТаблицы.УникальныйНомерСтроки = НомерЭлемента;
		НомерЭлемента = НомерЭлемента + 1;
				
		Если ВРег(Лев(СтрокаТаблицы.Наименование, ДлинаТекста)) = Текст Тогда
			
			// Нужно сформировать полное наименование адресного элемента
			// Смотрим какой уровень детализации и такое наименование и строим
			НаименованиеЭлемента = киПолучитьПолноеНазвание(СтрокаТаблицы.Код);
			НаименованиеТекущегоУровня = СтрокаТаблицы.Наименование + " " + СтрокаТаблицы.Сокращение;
			ПолноеНаименованиеЭлемента = ?(НЕ ЗначениеЗаполнено(НаименованиеЭлемента), НаименованиеТекущегоУровня, 
											НаименованиеТекущегоУровня + " (" + НаименованиеЭлемента + ")");
			СписокВозврата.Добавить(СтрокаТаблицы["УникальныйНомерСтроки"], ПолноеНаименованиеЭлемента);
			
		КонецЕсли;
					
	КонецЦикла; 

	Возврат СписокВозврата;
	
КонецФункции

// Процедура переносит строку из таблицы в Структуру
Процедура ПеренестиСтрокуТаблицыВСтруктуру(Таблица, СтрокаТаблицы, СтруктураЭлемента)Экспорт 
	
	Если СтруктураЭлемента = Неопределено 
		ИЛИ СтрокаТаблицы = Неопределено 
		ИЛИ Таблица = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЭлемента.Очистить();
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
КонецПроцедуры

// функция возвращает был ли выбран пользователем элемент из выпадающего списка выбора
Функция ОпределитьВыборПользователяИзСписка(Элемент, ЭтаФорма, СписокВыбора, ТаблицаВыборки, Значение, ПолеВыбора, СтруктураВыбранногоЭлемента)
	
	// а содержит ли список строки
	Если СписокВыбора.Количество() > 0 Тогда
		// список отсортируем в алфавитном порядке
		СписокВыбора.СортироватьПоПредставлению();
		ВыбранныйЭлемент = ЭтаФорма.ВыбратьИзСписка(СписокВыбора, Элемент);
	Иначе
		ВыбранныйЭлемент = Неопределено; // если список пустой - выбирать не из чего
	КонецЕсли;
		
	Если ВыбранныйЭлемент <> Неопределено Тогда
		ВыбраннаяСтрока = ТаблицаВыборки.Найти(ВыбранныйЭлемент.Значение, "УникальныйНомерСтроки");
		Значение = ВыбраннаяСтрока[ПолеВыбора];
		// структуру надо вернуть
		ПеренестиСтрокуТаблицыВСтруктуру(ТаблицаВыборки, ВыбраннаяСтрока, СтруктураВыбранногоЭлемента);
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Процедура организует выбор элементов по результату запроса
Процедура ВыбратьЭлементОкончаниеВводаАдресногоКлассификатора(Элемент, Текст, Значение, СтандартнаяОбработка, РезультатЗапроса, ЭтаФорма, ПоляПоиска, ПолеВыбора, 
											СтруктураВыбранногоЭлемента = Неопределено, НачальныйУровеньДетализации = 0, КонечныйУровеньДетализации = 5)
	
	Если РезультатЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	СтандартнаяОбработка = Ложь;
	
	Если РезультатЗапроса.Пустой() Тогда
		Значение = Текст;
		Возврат;
	КонецЕсли;
	
	Выборка = РезультатЗапроса.Выбрать();
	КоличествоЭлементовВыборки = Выборка.Количество();
	
	Если КоличествоЭлементовВыборки = 1 Тогда
		
		// единственный элемент в выборке - переносим значение в структуру
		ОбработатьЕдинственныйЭлементВыбора(РезультатЗапроса, Выборка, Значение, ПолеВыбора, СтруктураВыбранногоЭлемента);	
		Возврат;
		
	ИначеЕсли КоличествоЭлементовВыборки > 50 Тогда
		#Если Клиент Тогда
		Предупреждение("Найдено более 50-ти значений, удовлетворяющих условиям выбора.
				   |Задайте более длинную строку или воспользуйтесь командой выбора (F4).");
		#КонецЕсли
				   
		// то что пользователь ввел то и оставляем
		Значение = Текст;
        Возврат;
		
	ИначеЕсли КоличествоЭлементовВыборки = 0 Тогда
		ЭлементВыбран = Ложь;
	Иначе
		
		// из выпадающего списка предлагаем выбрать элемент
		ТаблицаВыборки = РезультатЗапроса.Выгрузить();
		СписокВыбора = СформироватьСписокВыбораАдресногоКлассификатора(ТаблицаВыборки, Текст, 
																			НачальныйУровеньДетализации, КонечныйУровеньДетализации);
		
		ЭлементВыбран = ОпределитьВыборПользователяИзСписка(Элемент, ЭтаФорма, СписокВыбора, ТаблицаВыборки, Значение, ПолеВыбора, СтруктураВыбранногоЭлемента);
		
	КонецЕсли; 
	
	Если ЭлементВыбран Тогда
		Возврат;
	КонецЕсли;
	
	// то что пользователь ввел то и оставляем
	Значение = Текст;
		
КонецПроцедуры

// Процедура обслуживает событие ОкончаниеВводаТекста элемента управления По Адресному Классификатору
Процедура ОкончаниеВводаТекстаВЭлементеУправленияПоАдресномуКлассификатору(Элемент, Текст, Значение, СтандартнаяОбработка, СтруктураПараметров, ЭтаФорма, 
															СтруктураВыбранногоЭлемента = Неопределено, 
															НачальныйУровеньДетализацииАдреса, КонечныйУровеньДетализацииАдреса) Экспорт                                               

	Если ПустаяСтрока(Текст) Тогда
		Значение = "";
		СтандартнаяОбработка = Ложь;
		Возврат;
	КонецЕсли; 

	МассивПоиска = Новый Массив();
    МассивПоиска.Добавить("Наименование");

	СокращенныйТекстТерритории = СокрЛП(киОбрезатьСокращение(Текст));
	СообщатьОбОшибкеПриОтсутствииЭлементов = (СокращенныйТекстТерритории = Текст);

  	// пробуем найти адресный элемент без обрезания потенциального сокращения
	РезультатЗапроса = ПолучитьРезультатЗапросаАвтоподбораДляРегистра(Текст, СтруктураПараметров, "АдресныйКлассификатор", МассивПоиска, 51);
	Если РезультатЗапроса.Пустой() И НЕ СообщатьОбОшибкеПриОтсутствииЭлементов Тогда
		
		// Ничего найти не удалось. Обрезаем сокращения и пытаемся еще раз
		РезультатЗапроса = ПолучитьРезультатЗапросаАвтоподбораДляРегистра(СокращенныйТекстТерритории, СтруктураПараметров, "АдресныйКлассификатор", МассивПоиска, 51);
		
	КонецЕсли;
	
	ВыбратьЭлементОкончаниеВводаАдресногоКлассификатора(Элемент, Текст, Значение, СтандартнаяОбработка, РезультатЗапроса, 
										ЭтаФорма,МассивПоиска, "Наименование", СтруктураВыбранногоЭлемента, НачальныйУровеньДетализацииАдреса, КонечныйУровеньДетализацииАдреса);
	
КонецПроцедуры

// Функция создает объект запрос и устанавливает у него параметры ТекстАвтоПодбора и ТекстАвтоПодбораЧисло
// убирает лишние символы в строке поиска
Функция  СоздатьЗапросДляСпискаАвтоподбора(СтрокаПоиска, СтрокаОтборовПоСтруктуре, СтруктураПараметров, ИмяТаблицыОграничений)
	
	Запрос = Новый Запрос;
	
	СтрокаПоиска = СтрокаПоиска;
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, "~", "~~");
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, "%", "~%");
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, "_", "~_");
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, "[", "~[");
	СтрокаПоиска = СтрЗаменить(СтрокаПоиска, "-", "~-");

	Запрос.УстановитьПараметр("ТекстАвтоПодбора"     , (СтрокаПоиска + "%"));
	Попытка
		Запрос.УстановитьПараметр("ТекстАвтоПодбораЧисло", Число(СтрокаПоиска));
	Исключение
		Запрос.УстановитьПараметр("ТекстАвтоПодбораЧисло", Неопределено);
	КонецПопытки;
	
	// Устанавливает ограничения
	СтрокаОтборовПоСтруктуре = "";
	Для Каждого ЭлементСтруктуры Из СтруктураПараметров Цикл
		Ключ 	 = ЭлементСтруктуры.Ключ;
        Значение = ЭлементСтруктуры.Значение;

		Запрос.УстановитьПараметр(Ключ, Значение);
		СтрокаОтборовПоСтруктуре = СтрокаОтборовПоСтруктуре + "
		|		И
		|		" + ИмяТаблицыОграничений + "." + Ключ + " В (&"+ Ключ + ")";
	КонецЦикла; 
	
	Возврат Запрос;
	
КонецФункции

//Функция Определяет тип ограничений по полю
Функция ОпределитьТипОграниченийПоПолю(ИмяЭлемента, МетаданныеОбъекта, ДляСправочника = Истина)
	
	Если ДляСправочника Тогда
		
		Если ИмяЭлемента <> "Наименование" И ИмяЭлемента <> "Код" Тогда
	    	ТипЗначенияПоиска = МетаданныеОбъекта.Реквизиты[ИмяЭлемента].Тип.Типы()[0];
		Иначе
			Если ИмяЭлемента = "Наименование" Тогда
				ТипЗначенияПоиска = Тип("Строка");
			Иначе
				Если МетаданныеОбъекта.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Строка Тогда
					ТипЗначенияПоиска = Тип("Строка");
				Иначе
					ТипЗначенияПоиска = Тип("Число");
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли;
		
	Иначе
		// тип определяем для регистра сведений
		Объект = МетаданныеОбъекта.Измерения.Найти(ИмяЭлемента);
		Если Объект = Неопределено Тогда
			Объект = МетаданныеОбъекта.Ресурсы.Найти(ИмяЭлемента);
		КонецЕсли;
		Если Объект = Неопределено Тогда
			Объект = МетаданныеОбъекта.Реквизиты.Найти(ИмяЭлемента);
			Если Объект = Неопределено Тогда
				ТипЗначенияПоиска = Тип("Строка");
			КонецЕсли;	
		КонецЕсли;
		ТипЗначенияПоиска = Объект.Тип.Типы()[0];
		
	КонецЕсли;
	
	Возврат  ТипЗначенияПоиска;
	
КонецФункции

//Функция Строит запрос автоподбора для регистра
Функция ПолучитьРезультатЗапросаАвтоподбораДляРегистра(Знач Текст, СтруктураПараметров, ИмяРегистра, ПоляДляПоиска, КоличествоЭлементов) Экспорт
	
	Если (ПоляДляПоиска = Неопределено) ИЛИ ПоляДляПоиска.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	Объект = Метаданные.РегистрыСведений[ИмяРегистра];
    	
	СтрокаОтборовПоСтруктуре = "";
	
	Запрос = СоздатьЗапросДляСпискаАвтоподбора(Текст, СтрокаОтборовПоСтруктуре, СтруктураПараметров, "ТаблицаРегистра");
	
	СтрокаПолей = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ " + Строка(КоличествоЭлементов) + "
				  	|	ТаблицаРегистра.* ";
	
	Запрос.Текст = СтрокаПолей + "
		|ИЗ
		|	РегистрСведений." + ИмяРегистра + " КАК ТаблицаРегистра
		|ГДЕ ";

	
	// формируем ограничения по полям для поиска
	ОграничениеПоПолю = "";
	Для Каждого ПолеПоиска из ПоляДляПоиска Цикл
		
		ТипЗначенияПоиска = Тип("Строка");
		Если (ОграничениеПоПолю <> "") Тогда
			ОграничениеПоПолю = ОграничениеПоПолю + "
				| ИЛИ ";
		КонецЕсли;
		ОграничениеПоПолю = ОграничениеПоПолю + СформироватьОграничениеПоПолюВхождениеВНачало("ТаблицаРегистра." + ПолеПоиска, ТипЗначенияПоиска);

	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст +"
		|	(" + ОграничениеПоПолю + ") " + СтрокаОтборовПоСтруктуре;

	Возврат Запрос.Выполнить();
 	
КонецФункции

// Функция формирует ограничение для запроса по полю 
Функция СформироватьОграничениеПоПолюВхождениеВНачало(ИмяПоля, ТипЗначенияПоиска) Экспорт
	
	Ограничение = ИмяПоля + ?(ТипЗначенияПоиска = Тип("Строка"), (" ПОДОБНО &ТекстАвтоПодбора СПЕЦСИМВОЛ ""~"""), (" =  &ТекстАвтоПодбораЧисло"));
	Возврат "(" + Ограничение + ") ";
	
КонецФункции

// Функция подбирает значения по выборке
Функция ПолучитьАвтоподборПоВыборке(РезультатЗапроса, Текст, ТекстАвтоПодбора, СтандартнаяОбработка, ПоляПоиска, Знач ПолеВыбора = "") Экспорт
	
	СтруктураНайденногоЭлемента = Новый Структура;
	
	Если РезультатЗапроса = Неопределено Тогда
		Возврат СтруктураНайденногоЭлемента;
	КонецЕсли; 
	
	СтандартнаяОбработка = Ложь;
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат СтруктураНайденногоЭлемента;
	КонецЕсли;
	
	ВрегТекст =	ВРег(Текст);
	
	Выборка = РезультатЗапроса.Выбрать();
	Если Выборка.Количество() <> 1 Тогда
		Возврат СтруктураНайденногоЭлемента;
	КонецЕсли;

	// выбран только один элемент - его и подставляем
	Выборка.Следующий();
	Для Каждого ИмяПоляПоиска Из ПоляПоиска Цикл
		ВрегЗначение = Врег(Выборка[ИмяПоляПоиска]);
		
		Если Лев(ВрегЗначение, СтрДлина(ВрегТекст)) = ВрегТекст Тогда
			Если ВрегТекст <> ВрегЗначение Тогда
				
				Если ПустаяСтрока(ПолеВыбора) Тогда			
					ТекстАвтоподбора = Выборка[ИмяПоляПоиска];
				Иначе
					ТекстАвтоподбора = Выборка[ПолеВыбора];
				КонецЕсли;
				
				ПеренестиСтрокуВыборкиВСтруктуру(РезультатЗапроса, Выборка, СтруктураНайденногоЭлемента);
			КонецЕсли;
			
			Возврат СтруктураНайденногоЭлемента;
		КонецЕсли; 
		
	КонецЦикла;  
		
КонецФункции

// Функция обслуживает событие АвтоПодборТекста элемента управления ПолеВвода для подмены автопоиска по тексту.
//
// Параметры
//  Элемент - поле ввода
//  Текст - текст введенный в поле ввода Вид
//  ТекстАвтоПодбора - текст автоподбора в поле Вид
//  СтандартнаяОбработка - булево, флаг стандартной обработки события автоподбора
//  СтруктураПараметров - Структура параметров запроса, ключ - имя параметра, значение - значение параметра.
//  ТипСправочника - строка, имя регистра в котором ищется информация
//	ПоляПоиска - массивы полей для Поиска
//
Функция АвтоПодборТекстаВЭлементеУправленияПоРегистру(Элемент, Текст, ТекстАвтоПодбора, СтандартнаяОбработка, СтруктураПараметров, 
														ИмяРегистра, ПоляПоиска, ПолеВыбора) Экспорт

	РезультатЗапроса = ПолучитьРезультатЗапросаАвтоподбораДляРегистра(Текст, СтруктураПараметров, ИмяРегистра, ПоляПоиска, 2);
	//МассивПолеВыбора = Новый Массив();
	//МассивПолеВыбора.Добавить(ПолеВыбора);
	СтруктураНайденногоЭлемента = ПолучитьАвтоподборПоВыборке(РезультатЗапроса, Текст, ТекстАвтоПодбора, СтандартнаяОбработка, ПоляПоиска, ПолеВыбора);
	Возврат СтруктураНайденногоЭлемента;
	
КонецФункции

//  Процедура формирует строковое представление адресных элементов -
// "родителей" переданного в переданных параметрах
//
// Параметры:
//  Элемент - элемент справочника Адресный классфикатор, для которого надо получить родителей.
//  Регион - строка, куда будет помещено строковое представление "родительского" региона.
//  Район - строка, куда будет помещено строковое представление "родительского" района.
//  Город - строка, куда будет помещено строковое представление "родительского" города.
//  НаселенныйПункт - строка, куда будет помещено строковое представление "родительского" населенного пункта.
//
Процедура АдресныйЭлементЗаполнитьРодителей(Регион, Район, Город, НаселенныйПункт, Элемент) Экспорт

	Если (Элемент.ТипАдресногоЭлемента > 4) И НЕ ЗначениеЗаполнено(НаселенныйПункт) Тогда
		НаселенныйПункт = ПолучитьИмяАдресногоЭлементаПоКоду(Элемент.Код - Элемент.Код%киМаскаНасПункта(), 4);
	КонецЕсли;

	Если (Элемент.ТипАдресногоЭлемента > 3) И НЕ ЗначениеЗаполнено(Город) Тогда
		Город = ПолучитьИмяАдресногоЭлементаПоКоду(Элемент.Код - Элемент.Код%киМаскаГорода(), 3);
	КонецЕсли;

	Если (Элемент.ТипАдресногоЭлемента > 2) И НЕ ЗначениеЗаполнено(Район) Тогда    
		Район = ПолучитьИмяАдресногоЭлементаПоКоду(Элемент.Код - Элемент.Код%киМаскаРайона(), 2);
	КонецЕсли;

	Если (Элемент.ТипАдресногоЭлемента > 1) И НЕ ЗначениеЗаполнено(Регион) Тогда
		Регион = ПолучитьИмяАдресногоЭлементаПоКоду(Элемент.Код - Элемент.Код%киМаскаРегиона(), 1);
	КонецЕсли;
		
КонецПроцедуры

// Функция возвращает имя адресного элемента определенного уровня по коду
Функция ПолучитьИмяАдресногоЭлементаПоКоду(КодЭлемента, ТипАдресногоЭлемента) Экспорт
	
	ИмяАдресногоЭлемента = "";
	// сначала по коду определим уровень элемента, если не совпадет с требуемым, то к БД не обращаемся
	ТипЭлемента = киПолучитьТипАдресногоЭлемента(КодЭлемента);
	Если  ТипЭлемента <> ТипАдресногоЭлемента Тогда
		Возврат ИмяАдресногоЭлемента;
	КонецЕсли;
	
	АдресныйЭлемент = киПолучитьСтруктуруАдресногоЭлемента(КодЭлемента);
	Если АдресныйЭлемент.ТипАдресногоЭлемента = ТипАдресногоЭлемента Тогда
		ИмяАдресногоЭлемента = киПолучитьНазвание(АдресныйЭлемент);
	КонецЕсли;
	
	Возврат ИмяАдресногоЭлемента;
	
КонецФункции

//  Процедура проверяет правильность заполнения потомков определенного адресного элемента
//
// Параметры:
//  Элемент - элемент справочника Адресный классфикатор, для которого надо получить родителей.
//  Регион - строка, куда будет помещено строковое представление "родительского" региона.
//  Район - строка, куда будет помещено строковое представление "родительского" района.
//  Город - строка, куда будет помещено строковое представление "родительского" города.
//  НаселенныйПункт - строка, куда будет помещено строковое представление "родительского" населенного пункта.
//
Процедура АдресныйЭлементПроверитьПравильностьЗаполненияПотомков(Регион, Район, Город, НаселенныйПункт, Улица, Элемент) Экспорт
	
	КодЭлемента = Неопределено;
	
	ИмяРегиона = ?(Элемент.ТипАдресногоЭлемента = 1, Элемент.Наименование, Регион);
	ИмяРайона = ?(Элемент.ТипАдресногоЭлемента = 2, Элемент.Наименование, Район);
	ИмяГорода = ?(Элемент.ТипАдресногоЭлемента = 3, Элемент.Наименование, Город);
	ИмяНаселенногоПункта = ?(Элемент.ТипАдресногоЭлемента = 4, Элемент.Наименование, НаселенныйПункт);
	ИмяУлицы = ?(Элемент.ТипАдресногоЭлемента = 5, Элемент.Наименование, Улица);
	
	Если (Элемент.ТипАдресногоЭлемента < 2) И ЗначениеЗаполнено(ИмяРайона) Тогда
		СтруктураОграничений = ПолучитьСтруктуруОграниченийПоАдресу(ИмяРегиона, ИмяРайона, "", "", "", 2);
		СтруктураОграничений.Свойство("КодРайонаВКоде", КодЭлемента);
		Если (КодЭлемента = Неопределено) ИЛИ (КодЭлемента = -1) Тогда
			// очищаем элемент и все что ниже него по иерархии
			Район = "";	
			Город = "";
			НаселенныйПункт = "";
			Улица = "";
			Возврат;
		КонецЕсли;
	КонецЕсли;

	Если (Элемент.ТипАдресногоЭлемента < 3) И ЗначениеЗаполнено(ИмяГорода) Тогда
		СтруктураОграничений = ПолучитьСтруктуруОграниченийПоАдресу(ИмяРегиона, ИмяРайона, ИмяГорода, "", "", 3);
		СтруктураОграничений.Свойство("КодГородаВКоде", КодЭлемента);
		Если (КодЭлемента = Неопределено) ИЛИ (КодЭлемента = -1)	Тогда
			Город = "";
			НаселенныйПункт = "";
			Улица = "";
			Возврат;	
		КонецЕсли;
	КонецЕсли;
	
	Если (Элемент.ТипАдресногоЭлемента < 4) И ЗначениеЗаполнено(ИмяНаселенногоПункта) Тогда
		СтруктураОграничений = ПолучитьСтруктуруОграниченийПоАдресу(ИмяРегиона, ИмяРайона, ИмяГорода, ИмяНаселенногоПункта, "", 4);
		СтруктураОграничений.Свойство("КодНаселенногоПунктаВКоде", КодЭлемента);
		Если (КодЭлемента = Неопределено) ИЛИ (КодЭлемента = -1) 	Тогда
			НаселенныйПункт = "";
			Улица = "";
			Возврат;	
		КонецЕсли;
	КонецЕсли;
	
	Если (Элемент.ТипАдресногоЭлемента < 5) И ЗначениеЗаполнено(ИмяУлицы) Тогда
		СтруктураОграничений = ПолучитьСтруктуруОграниченийПоАдресу(ИмяРегиона, ИмяРайона, ИмяГорода, ИмяНаселенногоПункта, ИмяУлицы, 5);
		СтруктураОграничений.Свойство("КодУлицыВКоде", КодЭлемента);
		Если (КодЭлемента = Неопределено) ИЛИ (КодЭлемента = -1)	Тогда
			Улица = "";	
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

//Функция возвращает полное наименование и адрес объекта строки на основании СтруктураПредставления1
//
Функция ПолучитьАдресИзСтруктураПредставления(СтрокаОбъекта) Экспорт
	Если СтрокаОбъекта <> "" Тогда
		ИндексНаименования = Найти(СтрокаОбъекта,",");
		Наименование = Лев(СтрокаОбъекта, ?(ИндексНаименования=0,СтрДлина(СтрокаОбъекта),ИндексНаименования-1));
		Если СтрДлина(СтрокаОбъекта) = СтрДлина(Наименование) Тогда
			Возврат Наименование;
		КонецЕсли;
		СтрокаАдреса = Прав(СтрокаОбъекта, СтрДлина(СтрокаОбъекта) - ИндексНаименования);
		Если Найти(СтрокаАдреса, "ИНН") > 0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,",");
			Если ИндексАдреса = 0 Тогда
				Возврат Наименование;
			КонецЕсли;
			СтрокаАдреса = Прав(СтрокаАдреса, СтрДлина(СтрокаАдреса) - ИндексАдреса);
		КонецЕсли;
		Если Найти(СтрокаАдреса, "КПП") > 0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,",");
			Если ИндексАдреса = 0 Тогда
				Возврат Наименование;
			КонецЕсли;
			СтрокаАдреса = Прав(СтрокаАдреса, СтрДлина(СтрокаАдреса) - ИндексАдреса);
		КонецЕсли;
		Если Найти(СтрокаАдреса, "тел.:") >0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,"тел.:");
			СтрокаАдреса = Лев(СтрокаАдреса, ?(СтрокаАдреса=0,СтрДлина(СтрокаАдреса),ИндексАдреса-2));
		ИначеЕсли Найти(СтрокаАдреса, "р/с ")>0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,"р/с");
			СтрокаАдреса = Лев(СтрокаАдреса, ?(СтрокаАдреса=0,СтрДлина(СтрокаАдреса),ИндексАдреса-2));
		ИначеЕсли Найти(СтрокаАдреса, "в банке")>0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,"в банке");
			СтрокаАдреса = Лев(СтрокаАдреса, ?(СтрокаАдреса=0,СтрДлина(СтрокаАдреса),ИндексАдреса-2));
		ИначеЕсли Найти(СтрокаАдреса, "БИК")>0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,"БИК");
			СтрокаАдреса = Лев(СтрокаАдреса, ?(СтрокаАдреса=0,СтрДлина(СтрокаАдреса),ИндексАдреса-2));
		ИначеЕсли Найти(СтрокаАдреса, "к/с ")>0 Тогда
			ИндексАдреса = Найти(СтрокаАдреса,"к/с");
			СтрокаАдреса = Лев(СтрокаАдреса, ?(СтрокаАдреса=0,СтрДлина(СтрокаАдреса),ИндексАдреса-2));
		КонецЕсли;
		ПоследнийСимвол = Прав(СтрокаАдреса, 1);
		Если ПоследнийСимвол = "," Тогда
			СтрокаАдреса = Лев(СтрокаАдреса, СтрДлина(СтрокаАдреса)-1);
		КонецЕсли;
		Если СтрокаАдреса <> "" Тогда
			Возврат Наименование+", "+СтрокаАдреса;
		Иначе
			Возврат Наименование;
		КонецЕсли;
	КонецЕсли;
	Возврат "--";
КонецФункции
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОТОБРАЖЕНИЯ КИ В ФОРМАХ ОБЪЕКТОВ

// Процедура сортирует набор записей регистра сведений КонтактнаяИнформация в следующем порядке:
//		1. Адрес;
//		2. Телефон;
//		3. Эл.Почта;
//		4. Веб;
//		5. ICQ;
//		6. Прочее.
//	Внутри этих типов первыми идут значения по умолчанию.
//
// Параметры:
//  НаборЗаписей - СписокЗначений	- Набор записей регистра сведений
//
Процедура киСортироватьНаборЗаписей(НаборЗаписей) Экспорт
	ТаблицаНабора = НаборЗаписей.Выгрузить();
	ТаблицаНабора.Колонки.Добавить("НомерТип");
	
	Для каждого СтрокаТаблицыНабора Из ТаблицаНабора Цикл
		СтрокаТаблицыНабора.НомерТип = Перечисления.ТипыКонтактнойИнформации.Индекс(СтрокаТаблицыНабора.Тип);
	КонецЦикла;	
	
	ТаблицаНабора.Сортировать("НомерТип ВОЗР, ЗначениеПоУмолчанию УБЫВ");
	НаборЗаписей.Загрузить(ТаблицаНабора);
КонецПроцедуры // киСортироватьНаборЗаписей()

// Процедура считывает контактную информацию из ИБ в набор записей регистра сведений.
//
// Параметры:
//  НаборЗаписей - СписокЗначений	- Набор записей регистра сведений
//  Ссылка 		 - Объект			- Объект, по которому необходимо заполнить КИ
//
Процедура киПрочитатьКонтактнуюИнформацию(НаборЗаписей, Ссылка) Экспорт

	Если ТипЗнч(НаборЗаписей) <> Тип("РегистрСведенийНаборЗаписей.КонтактнаяИнформация") Тогда
		НаборЗаписей = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
	Иначе
		НаборЗаписей.Очистить();
	КонецЕсли; 
	
	НаборЗаписей.Отбор.Объект.Значение      = Ссылка;
	НаборЗаписей.Отбор.Объект.Использование = Истина;
	НаборЗаписей.Прочитать();
	// сортируем
	киСортироватьНаборЗаписей(НаборЗаписей);

КонецПроцедуры // киПрочитатьКонтактнуюИнформацию()

#Если Клиент Тогда
// Функция возвращает картинку, соответствующую переданному типу
//
// Параметры:
//  Тип - ПеречислениеСсылка.ТипыКонтактнойИнформации - Содержит тип контактной информации. 
//
// Возвращаемое значение:
//  Картинка - Картинка, соответствующая переданному типу
//
Функция киПолучитьКартинкуТипаКИ(Тип) Экспорт 
	
	Картинка = Новый Картинка;
	
	Если Тип = Перечисления.ТипыКонтактнойИнформации.Адрес Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияАдрес;
	ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияЭлектроннаяПочта;
	ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияВебСтраница;
	ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.Другое Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияДругое;
	ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.НомерICQ Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияICQ;
	ИначеЕсли Тип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
		Картинка = БиблиотекаКартинок.КонтактнаяИнформацияТелефон;
	КонецЕсли;

	Возврат Картинка;
	
КонецФункции // киПолучитьКартинкуТипаКИ()

// Процедура обработка ПриВыводеСтроки в табличном поле контактной информации
//
// Параметры:
//	Элемент			 - Строка табличного части - Строка  табличного поля
//  ОформлениеСтроки - ОформлениеСтроки 	   - Содержит оформление строки и коллекцию оформлений ячеек. 
//  ДанныеСтроки 	 - Неопределено			   - Соответствует свойству ТекущиеДанные для выводимой строки. 
//
Процедура киКонтактнаяИнформацияПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки) Экспорт
	Если ДанныеСтроки <> Неопределено Тогда
		Если ТипЗнч(ДанныеСтроки) = Тип("ПеречислениеСсылка.ТипыКонтактнойИнформации") Тогда
			Тип = ДанныеСтроки;
			Картинка = ОформлениеСтроки.Ячейки.Ссылка;
		ИначеЕсли (ТипЗнч(ДанныеСтроки) = Тип("СтрокаДереваЗначений")) Или (ТипЗнч(ДанныеСтроки) = Тип("СтрокаТаблицыЗначений"))Тогда 
			Если ТипЗнч(ДанныеСтроки.ВидыКонтактнойИнформации) = Тип("ПеречислениеСсылка.ТипыКонтактнойИнформации") Тогда
				Тип = ДанныеСтроки.ВидыКонтактнойИнформации;
			Иначе
				Тип = ДанныеСтроки.ВидыКонтактнойИнформации.Тип;
			КонецЕсли;	
			Картинка = ОформлениеСтроки.Ячейки.ВидыКонтактнойИнформации;
		Иначе
			Попытка
				Тип = ДанныеСтроки.Тип;
			Исключение
				Попытка
					Тип = ДанныеСтроки.Ссылка.Тип;
				Исключение
					Попытка
						Тип = Элемент.ТекущаяСтрока.Тип;
					Исключение
					КонецПопытки;
				КонецПопытки;
			КонецПопытки;
			Картинка = ОформлениеСтроки.Ячейки.Тип;
			Попытка
				Если ДанныеСтроки.ЗначениеПоУмолчанию Тогда
					ОформлениеСтроки.Шрифт = Новый Шрифт(,,ДанныеСтроки.ЗначениеПоУмолчанию);
				КонецЕсли;
			Исключение
			КонецПопытки;	
		КонецЕсли;	
		
		Картинка.Картинка = киПолучитьКартинкуТипаКИ(Тип);
		Картинка.ОтображатьКартинку = Истина;
		
	КонецЕсли;
КонецПроцедуры // киКонтактнаяИнформацияПриВыводеСтроки()
#КонецЕсли

// Обработчик события "ПередНачаломДобавления" табличного поля
// набора записей регистра сведений  "Контактная информация"
//
// Параметры:
//	Отказ 	  	  			  - Булево 			 - Признак отказа от записи объекта
// 	Копирование   			  - Булево 			 - Признак копирования объекта
// 	ТабличноеПоле 			  - ТаблицаЗначений  - Табличное поле
//  НаборКонтактнойИнформации - СписокЗначений	 - Набор записей регистра сведений
//	ФормаВладелец			  - Форма			 - Форма владелец
// 	ТипКонтактнойИнформации	  - СправочникСсылка - Вид контактной информации
//
Процедура киПередНачаломДобавления(Отказ, Копирование, ТабличноеПоле, НаборКонтактнойИнформации, ФормаВладелец = Неопределено, ТипКонтактнойИнформации = Неопределено, РедактированиеБезВладельца=Ложь) Экспорт

	Отказ = Истина;
	
	ОбработкаРедактирования = Обработки.РедактированиеКонтактнойИнформации.Создать();
	ОбработкаРедактирования.РедактированиеБезВладельца=РедактированиеБезВладельца;
	
	Если Копирование Тогда
		ОбработкаРедактирования.РедактироватьЗапись(НаборКонтактнойИнформации,,ФормаВладелец,киПолучитьСтруктуруЗаписиРегистра(ТабличноеПоле.ТекущиеДанные));
		ОбработкаРедактирования.ЗапуститьФорму(ФормаВладелец);
	Иначе
		ОбработкаРедактирования.РедактироватьЗапись(НаборКонтактнойИнформации,,ФормаВладелец);
		Если Не ТипКонтактнойИнформации = Неопределено Тогда
			ОбработкаРедактирования.Тип = ТипКонтактнойИнформации;
		КонецЕсли; 
		Форма = ОбработкаРедактирования.ПолучитьФорму("ФормаДереваВидов", ФормаВладелец);
		#Если Клиент Тогда
		Форма.ПоложениеОкна = ВариантПоложенияОкна.Центрировать;
		#КонецЕсли
		Форма.Открыть();
	КонецЕсли;
	
КонецПроцедуры // киПередНачаломДобавления()

// Обработчик события "ПередНачаломДобавления" табличного поля
// списка записей регистра сведений "Контактная информация"
//
// Параметры:
//	Элемент			 		  - Строка табличного части - Строка  табличного поля
//	Отказ 	  	  			  - Булево 			 		- Признак отказа от записи объекта
// 	Копирование   			  - Булево 			 		- Признак копирования объекта
//	СписокВладельцев		  - СписокЗначений			- Список владельцев
// 	ТипКонтактнойИнформации	  - СправочникСсылка 		- Вид контактной информации
//
Процедура киПередНачаломДобавленияВСписке(Элемент, Отказ, Копирование, СписокВладельцев, ТипКонтактнойИнформации = Неопределено, ФормаВладелец=Неопределено) Экспорт
	
	Отказ = Истина;
	
	МенеджерЗаписи = РегистрыСведений.КонтактнаяИнформация.СоздатьМенеджерЗаписи();
	Если Копирование Тогда
		Для каждого Измерение Из Метаданные.РегистрыСведений.КонтактнаяИнформация.Измерения Цикл
			МенеджерЗаписи[Измерение.Имя] = Элемент.ТекущиеДанные[Измерение.Имя];
		КонецЦикла;
		Для каждого Ресурс Из Метаданные.РегистрыСведений.КонтактнаяИнформация.Ресурсы Цикл
			МенеджерЗаписи[Ресурс.Имя] = Элемент.ТекущиеДанные[Ресурс.Имя];
		КонецЦикла;
		Для каждого Реквизит Из Метаданные.РегистрыСведений.КонтактнаяИнформация.Реквизиты Цикл
			МенеджерЗаписи[Ресурс.Имя] = Элемент.ТекущиеДанные[Ресурс.Имя];
		КонецЦикла;
	КонецЕсли;
	
	Если СписокВладельцев.ТекущиеДанные <> Неопределено Тогда
		Если ТипЗнч(СписокВладельцев.ТекущиеДанные) = Тип("СтрокаТаблицыЗначений") Тогда
			МенеджерЗаписи["Объект"] = СписокВладельцев.ТекущаяСтрока.Значение.Ссылка;
		Иначе
			МенеджерЗаписи["Объект"] = СписокВладельцев.ТекущаяСтрока.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	ОбработкаКИ = Обработки.РедактированиеКонтактнойИнформации.Создать();
	ОбработкаКИ.РедактироватьЗапись(МенеджерЗаписи, Истина, ФормаВладелец);
	Если Копирование Тогда
		ОбработкаКИ.ЗапуститьФорму();
	Иначе
		Если Не ТипКонтактнойИнформации = Неопределено Тогда
			ОбработкаКИ.Тип = ТипКонтактнойИнформации;
		КонецЕсли; 
		Форма = ОбработкаКИ.ПолучитьФорму("ФормаДереваВидов");
		#Если Клиент Тогда
		Форма.ПоложениеОкна = ВариантПоложенияОкна.Центрировать;
		#КонецЕсли
		Форма.Открыть();
	КонецЕсли;
	
КонецПроцедуры // киПередНачаломДобавленияВСписке()

// Обработчик события "ПередНачаломИзменения" табличного поля
// набора записей регистра сведений
//
// Параметры:
//	Элемент			 		  - Строка табличного части - Строка  табличного поля
//	Отказ 	  	  			  - Булево 			 		- Признак отказа от записи объекта
//	ФормаВладелец			  - Форма			 		- Форма владелец
// 	ТипКонтактнойИнформации	  - СправочникСсылка 		- Вид контактной информации
//
Процедура киПередНачаломИзменения(Элемент, Отказ, ФормаВладелец = Неопределено, НаборКонтактнойИнформации = Неопределено, РедактированиеБезВладельца=Ложь) Экспорт

	Отказ = Истина;
	ОбработкаРедактирования = Обработки.РедактированиеКонтактнойИнформации.Создать();
	ОбработкаРедактирования.РедактированиеБезВладельца=РедактированиеБезВладельца;
	ОбработкаРедактирования.мНаборЗаписейКонтактнойИнформации = НаборКонтактнойИнформации;
	ОбработкаРедактирования.РедактироватьЗапись(Элемент.ТекущиеДанные,,ФормаВладелец);
	ОбработкаРедактирования.ЗапуститьФорму(ФормаВладелец);

КонецПроцедуры // киПередНачаломИзменения()

// Обработчик события "ПередНачаломИзменения" табличного поля
// набора записей регистра сведений
//
// Параметры:
//	Элемент			 		  - Строка табличного части - Строка  табличного поля
//	Отказ 	  	  			  - Булево 			 		- Признак отказа от записи объекта
//
Процедура киПередНачаломИзмененияВСписке(Элемент, Отказ, ФормаВладелец=Неопределено) Экспорт

	Отказ = Истина;
	
	МенеджерЗаписи = РегистрыСведений.КонтактнаяИнформация.СоздатьМенеджерЗаписи();
	Для каждого Измерение Из Метаданные.РегистрыСведений.КонтактнаяИнформация.Измерения Цикл
		МенеджерЗаписи[Измерение.Имя] = Элемент.ТекущиеДанные[Измерение.Имя];
	КонецЦикла;
	МенеджерЗаписи.Прочитать();
	
	ОбработкаРедактирования = Обработки.РедактированиеКонтактнойИнформации.Создать();
	ОбработкаРедактирования.РедактироватьЗапись(МенеджерЗаписи, Истина, );
	ОбработкаРедактирования.ЗапуститьФорму();

КонецПроцедуры // киПередНачаломИзмененияВСписке()

// Процедура записывает контактную информацию в ИБ из набора записей регистра сведений.
//
// Параметры:
//  НаборЗаписей - СписокЗначений - Набор записей регистра сведений
//  Ссылка 		 - Объект 		  - Объект, по которому необходимо записать КИ
//	Отказ 	     - Булево 		  - Признак отказа от записи объекта
//  ЧитатьКИ 	 - Булево 		  - Признак того, что после записи набор регистра нужно обновить
//
Процедура киЗаписатьКонтактнуюИнформацию(НаборЗаписей, Ссылка, Отказ, ЧитатьКИ = Истина) Экспорт

	Индекс = 0;
	
	Пока Индекс <= НаборЗаписей.Количество() - 1 Цикл
		
		Запись = НаборЗаписей[Индекс];
		
		Запись.Объект = Ссылка;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	НаборЗаписей.Отбор.Объект.Значение = Ссылка;
	
	Попытка
		НаборЗаписей.Записать();
	Исключение
		Сообщить(ОписаниеОшибки(), СтатусСообщения.Важное);
		Сообщить("Элемент """ + СокрЛП(Ссылка) + """ не записан. Не записана контактная информация.");
		Отказ = Истина;
		Возврат;
	КонецПопытки;
	Если ЧитатьКИ Тогда
		киПрочитатьКонтактнуюИнформацию(НаборЗаписей, Ссылка)
	КонецЕсли; 
	
КонецПроцедуры // киЗаписатьКонтактнуюИнформацию()

// Процедура выполняется при активизации строки табличного поля, в котором
// отображается контактная информация объектов в их формах, и управляет
// доступностью кнопок командной пенели "установка значения по умолчанию" и "Открыть ссылку".
//
// Параметры:
//	Элемент			- Строка табличного части - Строка  табличного поля
//  КоманднаяПанель - Командная панель 		  - Командная панель, связанная с Элементом
//
Процедура киПриАктивизацииСтрокиТаблицы (Элемент, КоманднаяПанель) Экспорт
	      
	Кнопки = КоманднаяПанель.Кнопки;
	Кнопки.Открыть.Доступность 		= Ложь;	
	Кнопки.ПоУмолчанию.Пометка     	= Ложь;
	Кнопки.ПоУмолчанию.Доступность 	= Ложь;
	
	Если Элемент.ТекущиеДанные <> Неопределено Тогда
		Если Элемент.ТекущиеДанные.Тип = Перечисления.ТипыКонтактнойИнформации.АдресЭлектроннойПочты 
			или Элемент.ТекущиеДанные.Тип = Перечисления.ТипыКонтактнойИнформации.ВебСтраница 
			или Элемент.ТекущиеДанные.Тип = Перечисления.ТипыКонтактнойИнформации.НомерICQ  
			или Элемент.ТекущиеДанные.Тип = Перечисления.ТипыКонтактнойИнформации.Телефон Тогда
			Кнопки.Открыть.Доступность = Истина;
		КонецЕсли;
			
		Если Элемент.ТекущиеДанные.ЗначениеПоУмолчанию Тогда
			Кнопки.ПоУмолчанию.Пометка     = Истина;
			Кнопки.ПоУмолчанию.Доступность = Истина;
		Иначе
			Кнопки.ПоУмолчанию.Пометка     = Ложь;
			Кнопки.ПоУмолчанию.Доступность = Истина;
		КонецЕсли; 
	КонецЕсли;
КонецПроцедуры // киПриАктивизацииСтрокиТаблицы()

// Процедура устанавливает в наборе регистра сведений 
// запись контактной информации определенного типа и вида основной
// для объекта в пространстве одного типа.
//
// Параметры:
//  НаборЗаписей  - СписокЗначений - Набор записей регистра сведений
//  ТабличноеПоле - ТабличноеПоле  - Поле связанное с набором записей
//  Кнопка 		  - Кнопка		   - Кнопка, по которой запись устанавливается основной
//
Процедура киУстановитьЗаписьОсновной(НаборЗаписей, ТабличноеПоле, Кнопка) Экспорт

	Если ТабличноеПоле.ТекущиеДанные <> Неопределено
	   И НЕ обЗначениеНеЗаполнено(ТабличноеПоле.ТекущиеДанные.Представление) Тогда
		Если НЕ ТабличноеПоле.ТекущиеДанные.ЗначениеПоУмолчанию Тогда
			Для каждого ЗаписьНабора Из НаборЗаписей Цикл
				Если ЗаписьНабора.Тип = ТабличноеПоле.ТекущиеДанные.Тип Тогда
					ЗаписьНабора.ЗначениеПоУмолчанию = Ложь;
				КонецЕсли; 
			КонецЦикла;
			ТабличноеПоле.ТекущиеДанные.ЗначениеПоУмолчанию = Истина;
			Кнопка.Пометка = Истина;
		КонецЕсли; 
	КонецЕсли;
	киСортироватьНаборЗаписей(НаборЗаписей);
	
КонецПроцедуры // киУстановитьЗаписьОсновной()

// Процедура устанавливает в списке регистра сведений 
// запись контактной информации определенного типа и вида основной
// для объекта в пространстве одного типа.
//
// Параметры:
//  СписокКИ 	  - РегистрСведенийСписок - Список записей регистра сведений
//  ТабличноеПоле - ТабличноеПоле 		  - Поле связанное со списком записей регистра сведений
//  Кнопка        - Кнопка				  - Кнопка, по которой запись устанавливается основной
//
Процедура киУстановитьЗаписьОсновнойВСписке(СписокКИ, ТабличноеПоле, Кнопка) Экспорт
	
	Если СписокКИ.Отбор.Объект.Значение <> Неопределено И ТабличноеПоле.ТекущиеДанные <> Неопределено Тогда
		ЗначениеПоУмолчанию = ТабличноеПоле.ТекущиеДанные.ЗначениеПоУмолчанию;
		Если ЗначениеПоУмолчанию Тогда
			Возврат;
		КонецЕсли;
		Кнопка.Пометка = НЕ ЗначениеПоУмолчанию;
		НаборЗаписей = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Объект.Значение      = СписокКИ.Отбор.Объект.Значение;
		НаборЗаписей.Отбор.Объект.Использование = Истина;
		НаборЗаписей.Прочитать();
	
		ТекущийВид = ТабличноеПоле.ТекущиеДанные.Вид;
		ТекущийТип = ТабличноеПоле.ТекущиеДанные.Тип;
		
		Для каждого ЗаписьНабора Из НаборЗаписей Цикл
			Если ЗаписьНабора.Тип = ТекущийТип Тогда
				ЗаписьНабора.ЗначениеПоУмолчанию = ?(ЗаписьНабора.Вид = ТекущийВид, Истина, Ложь);	
			КонецЕсли; 
		КонецЦикла;
		
		Попытка
			НаборЗаписей.Записать();
		Исключение
			Сообщить("Невозможно установить основной вид контактной информации.",СтатусСообщения.Важное);	
		КонецПопытки;
		
	КонецЕсли;	
	
КонецПроцедуры // киУстановитьЗаписьОсновнойВСписке()

// Функция проверяет строку на наличие значимых символов
//
// Параметры:
//  ВыбСтрока – Строка - Строка для проверки
//
// Возвращаемое значение:
//   Строка - пробел или пустое значение строки
//
Функция ПроверкаПустойСтроки(ВыбСтрока, ПризнакЗапятой=Истина)
	
	Если ПустаяСтрока(ВыбСтрока) Тогда
		Возврат "";
	Иначе
		Возврат ?(ПризнакЗапятой,",","")+" ";
	КонецЕсли; 
	
КонецФункции // ПроверкаПустойСтроки()

// Функция возвращает представление адреса собранного из полей значений Поле1 - Поле10
//
// Параметры:
//  НЕТ
//
// Возвращаемое значение:
//   Строка	- Представление адреса
//
Функция киПолучитьПредставлениеАдреса(Запись) Экспорт

	ТекПредставление = "";
	КраткоеПредставление = Запись.КраткоеПредставление;
	
	Если (СокрЛП(Запись.Поле1) <> "") И (Не КраткоеПредставление) Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле1);
	КонецЕсли;

 	Если (СокрЛП(Запись.Поле2) <> "") И (Не КраткоеПредставление) Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле2);
	КонецЕсли;

	Если (СокрЛП(Запись.Поле3) <> "") И (Не КраткоеПредставление) Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле3);
	КонецЕсли;

	Если (СокрЛП(Запись.Поле4) <> "") И (Не КраткоеПредставление) Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле4);
	КонецЕсли;

	Если (СокрЛП(Запись.Поле5) <> "") И (Не КраткоеПредставление) Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле5);
	КонецЕсли;
	
	Если Не Запись.ГородскойРайон.Пустая() Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.ГородскойРайон.Наименование);
	КонецЕсли;
	
	Если Не Запись.СтанцияМетро.Пустая() Тогда
		ТекПредставление = ТекПредставление + ", м. " + СокрЛП(Запись.СтанцияМетро.Наименование);
	КонецЕсли;

	Если СокрЛП(Запись.Поле6) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + СокрЛП(Запись.Поле6);
	КонецЕсли;

	Если СокрЛП(Запись.Поле7) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + Запись.ТипДома + " №" + СокрЛП(Запись.Поле7);
	КонецЕсли;

	Если СокрЛП(Запись.Поле8) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + Запись.ТипКорпуса + " " +СокрЛП(Запись.Поле8);
	КонецЕсли;

	Если СокрЛП(Запись.Поле9) <> "" Тогда
		ТекПредставление = ТекПредставление + ", " + Запись.ТипКвартиры + " " + СокрЛП(Запись.Поле9);
	КонецЕсли;

	Если СокрЛП(Запись.Поле10) <> "" Тогда
		ТекПредставление = ТекПредставление + ", подъезд №" + СокрЛП(Запись.Поле10);
	КонецЕсли;

	Если СокрЛП(Запись.Поле11) <> "" Тогда
		ТекПредставление = ТекПредставление + ", этаж " + СокрЛП(Запись.Поле11);
	КонецЕсли;

	Если СокрЛП(Запись.Поле12) <> "" Тогда
		ТекПредставление = ТекПредставление + ", код " + СокрЛП(Запись.Поле12);
	КонецЕсли;
	
	Если СтрДлина(ТекПредставление) > 2 Тогда
		ТекПредставление = Сред(ТекПредставление, 3);
	КонецЕсли;
	
	Возврат ТекПредставление;

КонецФункции // киПолучитьПредставлениеАдреса()

// Процедура устанавливает признак модифицированности и сортирует набор записей регистра сведений КонтактнаяИнформация.
//
// Параметры:
//	Модифицированность		  - Булево			- Признак модифицированности
//  НаборКонтактнойИнформации - СписокЗначений	- Набор записей регистра сведений
//	Сортировать				  - Булево			- Признак сортировки	
//
Процедура киДействияПриЗаписиКонтактнойИнформации(Модифицированность, НаборКонтактнойИнформации, Сортировать) Экспорт
	#Если Клиент Тогда
	Модифицированность = Истина;
	Если Сортировать Тогда
		киСортироватьНаборЗаписей(НаборКонтактнойИнформации);
	КонецЕсли;
	#КонецЕсли
КонецПроцедуры// ДействияПриЗаписиКонтактнойИнформации()

// Функция подсчитывает количество записей с данным видом контактной информации
//
// Параметры:
//	РедактируемаяЗапись		- РегистрСведенийЗапись - Запись регистра
// ВидКонтактнойИнформации	- СправочникСсылка		- Вид контактной информации
//
// Возвращаемое значение:
//	Число					-  Количество записей
//
Функция киКоличествоЗаписейКонтактнойИнформации(РедактируемаяЗапись, ВидКонтактнойИнформации)Экспорт
	// Проверим, нет уже записи регистра по текущему объекту с данным видом КИ 
	Количество = 0;
	Если ТипЗнч(РедактируемаяЗапись) = Тип("РегистрСведенийЗапись.КонтактнаяИнформация") ИЛИ
		   ТипЗнч(РедактируемаяЗапись) = Тип("РегистрСведенийМенеджерЗаписи.КонтактнаяИнформация") Тогда
		Набор = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
		Набор.Отбор.Объект.Установить(РедактируемаяЗапись.Объект);
		Набор.Отбор.Вид.Установить(ВидКонтактнойИнформации);
		Набор.Прочитать();
		Количество = Набор.Количество();
	ИначеЕсли ТипЗнч(РедактируемаяЗапись) = Тип("РегистрСведенийНаборЗаписей.КонтактнаяИнформация") Тогда
		Для каждого Запись Из РедактируемаяЗапись Цикл
			Если Запись.Вид = ВидКонтактнойИнформации Тогда
				Количество = 1;
				Прервать;
			КонецЕсли;	
		КонецЦикла;  
	КонецЕсли; 
	
	Возврат Количество;
КонецФункции// НайтиЗаписиКонтактнойИнформации()

// Функция заполнения списка видов контактной информации 
//
// Параметры:
//	РедактируемаяЗапись				 - РегистрСведенийЗапись - Запись регистра
//	Объект							 - СправочникСсылка		 - Вид контактной информации
//  НаборЗаписейКонтактнойИнформации - СписокЗначений		 - Набор записей регистра сведений
//
// Возвращаемое значение:
// СписокЗначений	- Список видов контактной информации
//
Функция киЗаполнитьСписокВидовКонтактнойИнформации(РедактируемаяЗапись, Объект, НаборЗаписейКонтактнойИнформации) Экспорт
	СписокВидовКонтактнойИнформации = Новый СписокЗначений;
	Запрос = Новый Запрос;
	ТекстЗапроса = "ВЫБРАТЬ
				   |	ВидыКонтактнойИнформации.Ссылка
				   |ИЗ
				   |	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
				   |ГДЕ
				   |	ВидыКонтактнойИнформации.Тип = &Тип";
				   
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Тип", Объект.Тип);
	СписокВидовКонтактнойИнформации.ЗагрузитьЗначения(Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка"));
	Н = 0;
	Пока Н < СписокВидовКонтактнойИнформации.Количество() Цикл
		ЭлементСписка = СписокВидовКонтактнойИнформации.Получить(Н);
		Если ЭлементСписка.Значение = Объект.Вид Тогда
			Н = Н + 1;
		Иначе
			Если НаборЗаписейКонтактнойИнформации = Неопределено Тогда
				КоличествоЗаписей = киКоличествоЗаписейКонтактнойИнформации(РедактируемаяЗапись, ЭлементСписка.Значение);
			Иначе
				КоличествоЗаписей = киКоличествоЗаписейКонтактнойИнформации(НаборЗаписейКонтактнойИнформации, ЭлементСписка.Значение);
			КонецЕсли;	
			Если КоличествоЗаписей > 0 Тогда
				СписокВидовКонтактнойИнформации.Удалить(ЭлементСписка);
			Иначе
				Н = Н + 1;
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;		
	Возврат СписокВидовКонтактнойИнформации;
КонецФункции// ЗаполнитьСписокВидовКонтактнойИнформации()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С АДРЕСНЫМ КЛАССИФИКАТОРОМ

// Функция по полному наименованию адресного элемента выдает отдельно его имя, и отдельно его адресное сокращение
Функция киПолучитьИмяИАдресноеСокращение(Знач СтрокаЭлемента, АдресноеСокращение) Экспорт

   	Буфер = СокрП(СтрокаЭлемента);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		Возврат СтрокаЭлемента;
	КонецЕсли;

	Пока  СтрЧислоВхождений(Буфер, " ") > 1 Цикл
		Буфер = Лев(Буфер, ПозицияПослПробела - 1) + "_" + Сред(Буфер, ПозицияПослПробела + 1);
		ПозицияПослПробела = Найти(Буфер, " ");
	КонецЦикла;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Сокращение", Сред(СтрокаЭлемента, ПозицияПослПробела + 1));
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	АдресныеСокращения.Ссылка
	|ИЗ
	|	Справочник.АдресныеСокращения КАК АдресныеСокращения
	|
	|ГДЕ
	|	АдресныеСокращения.Сокращение = &Сокращение";

	Выборка = Запрос.Выполнить().Выбрать();
	АдресноеСокращение = "";

	Если Выборка.Следующий() Тогда
		Если ПустаяСтрока(СокрЛП(Лев(СтрокаЭлемента, ПозицияПослПробела - 1))) Тогда
			Возврат СтрокаЭлемента;
		Иначе
			АдресноеСокращение = Сред(СтрокаЭлемента, ПозицияПослПробела + 1);
			Возврат Лев(СтрокаЭлемента, ПозицияПослПробела - 1);
		КонецЕсли;
	Иначе
		Возврат СтрокаЭлемента;
	КонецЕсли;
  	
КонецФункции

// Функция определяет является ли последнее слово в строке допустимым 
//  сокращением, и если является, то обрезает его из строки
//
// Параметры:
//  СтрокаЭлемента - Строка - Строка в которой необходимо обрезать сокращение
//
// Возвращаемое значение:
// Строка - Обрезанная строка в случае, если есть сокращение и полученная строку в  обратном случае
//
Функция киОбрезатьСокращение(Знач СтрокаЭлемента) Экспорт

	Буфер = СокрП(СтрокаЭлемента);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		Возврат СтрокаЭлемента;
	КонецЕсли;

	Пока  СтрЧислоВхождений(Буфер, " ") > 1 Цикл
		Буфер = Лев(Буфер, ПозицияПослПробела - 1) + "_" + Сред(Буфер, ПозицияПослПробела + 1);
		ПозицияПослПробела = Найти(Буфер, " ");
	КонецЦикла;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Сокращение", Сред(СтрокаЭлемента, ПозицияПослПробела + 1));
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	АдресныеСокращения.Ссылка
	|ИЗ
	|	Справочник.АдресныеСокращения КАК АдресныеСокращения
	|
	|ГДЕ
	|	АдресныеСокращения.Сокращение = &Сокращение";

	Выборка = Запрос.Выполнить().Выбрать();

	Если Выборка.Следующий() Тогда
		Если ПустаяСтрока(СокрЛП(Лев(СтрокаЭлемента, ПозицияПослПробела - 1))) Тогда
			Возврат СтрокаЭлемента;
		Иначе
			Возврат Лев(СтрокаЭлемента, ПозицияПослПробела - 1);
		КонецЕсли;
	Иначе
		Возврат СтрокаЭлемента;
	КонецЕсли;

КонецФункции // киДействияПриЗаписиКонтактнойИнформации()

// Функция по для переданной строки определят необходимость дополнить её
// сокращением
//
// Параметры:
//  Название - Строка - Строка, для которой определяется необходимость дополнения сокращением
//  Уровень  - Число  - Уровень, для которого необходимо составить список сокращений
//
// Возвращаемое значение:
//  СписокЗначений - Неопределено, если строку дополнять не нужно или список значений с сокращениями
//
Функция киПолучитьСписокСокращений(Знач Название, Уровень) Экспорт

	Название = СокрЛП(Название);

	Если ПустаяСтрока(Название) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если киОбрезатьСокращение(Название) <> Название Тогда // было что обрезать
		Возврат Неопределено; // для строки не требуется дополнение сокращением
	КонецЕсли;

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Уровень", Уровень);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	АдресныеСокращения.Ссылка
	|ИЗ
	|	Справочник.АдресныеСокращения КАК АдресныеСокращения
	|
	|ГДЕ
	|	АдресныеСокращения.Уровень = &Уровень";

	Выборка = Запрос.Выполнить().Выбрать();

	СписокСокращений = Новый СписокЗначений();

	Пока Выборка.Следующий() Цикл
		СписокСокращений.Добавить(Выборка.Ссылка.Сокращение);
	КонецЦикла;

	Если СписокСокращений.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат СписокСокращений;
	КонецЕсли;

КонецФункции // киПолучитьСписокСокращений()

// Функция формирует строку с названием адресного элемента,
// которое состоит из наименования и сокращения
//
// Параметры:
//  АдресныйЭлемент - СправочникСсылка - Элемент справочника Адресный классфикатор.
//
// Возвращаемое значение:
//  Строка - Название адресного элемента
//
Функция киПолучитьНазвание(АдресныйЭлемент) Экспорт

	Если АдресныйЭлемент.Код = 0 Тогда
		Возврат "";
	Иначе
		Возврат СокрЛП(АдресныйЭлемент.Наименование) + " " + СокрЛП(АдресныйЭлемент.Сокращение)
	КонецЕсли;

КонецФункции // киПолучитьНазвание()

// Процедура раскладывает код адресного элемента на составляющие:
// Код Региона, код района, код города, код населенного пункта, код улицы и код дома
Процедура киРазложитьКодАдресногоЭлементаНаСоставляющие(Знач Код, КодРегиона, КодРайона, КодГорода, КодНаселенногоПункта, КодУлицы, КодДома)
	
	КодЭлемента = Код;
	
	КодРегиона = Цел(КодЭлемента / киМаскаРегиона());
	КодЭлемента = КодЭлемента % киМаскаРегиона();

	КодРайона = Цел(КодЭлемента / киМаскаРайона());
	КодЭлемента = КодЭлемента % киМаскаРайона();

	КодГорода = Цел(КодЭлемента / киМаскаГорода());
	КодЭлемента = КодЭлемента % киМаскаГорода();

	КодНаселенногоПункта = Цел(КодЭлемента / киМаскаНасПункта());
	КодЭлемента = КодЭлемента % киМаскаНасПункта();

	КодУлицы = Цел(КодЭлемента / киМаскаУлицы());
	КодЭлемента = КодЭлемента % киМаскаУлицы();

	КодДома = Цел(КодЭлемента / киМаскаДома());

КонецПроцедуры // РазложитьКодАдресногоЭлементаНаСоставляющие()

// Функция формирует строку с полным названием адресного элемента,
// которое состоит из наименования и сокращения самого адресного
// элемента и его "родителей"
//
// Параметры:
//  КодЭлемента - Число - Код адресного элемента.
//
// Возвращаемое значение:
//  Строка - Название адресного элемента и его родителей через запятую
//
Функция киПолучитьПолноеНазвание(Знач КодЭлемента) Экспорт

	КодРегиона = Цел(КодЭлемента / киМаскаРегиона());
	КодЭлемента = КодЭлемента % киМаскаРегиона();

	КодРайона = Цел(КодЭлемента / киМаскаРайона());
	КодЭлемента = КодЭлемента % киМаскаРайона();

	КодГорода = Цел(КодЭлемента / киМаскаГорода());
	КодЭлемента = КодЭлемента % киМаскаГорода();

	КодНаселенногоПункта = Цел(КодЭлемента / киМаскаНасПункта());
	КодЭлемента = КодЭлемента % киМаскаНасПункта();

	КодУлицы = Цел(КодЭлемента / киМаскаУлицы());
	КодЭлемента = КодЭлемента % киМаскаУлицы();

	КодДома = Цел(КодЭлемента / киМаскаДома());

	Название = "";
	НовыйКод = 0;

	Если КодРегиона > 0 Тогда
		НовыйКод = КодРегиона * киМаскаРегиона();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если КодРайона > 0 Тогда
		НовыйКод = НовыйКод + КодРайона * киМаскаРайона();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если КодГорода > 0 Тогда
		НовыйКод = НовыйКод + КодГорода * киМаскаГорода();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если КодНаселенногоПункта > 0 Тогда
		НовыйКод = НовыйКод + КодНаселенногоПункта * киМаскаНасПункта();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если КодУлицы > 0 Тогда
		НовыйКод = НовыйКод + КодУлицы * киМаскаУлицы();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если КодДома > 0 Тогда
		НовыйКод = НовыйКод + КодДома * киМаскаДома();
		Название = Название + ", " + киПолучитьНазвание(киПолучитьСтруктуруАдресногоЭлемента(НовыйКод));
	КонецЕсли;

	Если СтрДлина(Название) > 2 Тогда
		Название = Сред(Название, 3);
	КонецЕсли;

	Возврат Название;

КонецФункции // киПолучитьПолноеНазвание()

// Функция ставит в соответствие типу адресного элемента маску,
// через которую выделяется его значимый код
//
// Параметры:
//  ТипАдресногоЭлемента -  Число - тип адресного элемента.
//
// Возвращаемое значение:
// Число - маска, при делении на которую выделяется значимый код адресного элемента
//
Функция киПолучитьМаскуПоТипу(ТипАдресногоЭлемента) Экспорт

	Если ТипАдресногоЭлемента = 1 Тогда
		Возврат киМаскаРегиона();

	ИначеЕсли ТипАдресногоЭлемента = 2 Тогда
		Возврат киМаскаРайона();

	ИначеЕсли ТипАдресногоЭлемента = 3 Тогда
		Возврат киМаскаГорода();

	ИначеЕсли ТипАдресногоЭлемента = 4 Тогда
		Возврат киМаскаНасПункта();

	ИначеЕсли ТипАдресногоЭлемента = 5 Тогда
		Возврат киМаскаУлицы();

	ИначеЕсли ТипАдресногоЭлемента = 6 Тогда
		Возврат киМаскаДома();

	Иначе
		Возврат киМаскаКвартиры();

	КонецЕсли;

КонецФункции // киПолучитьМаскуПоТипу()

// Функция ставит в соответствие типу адресного элемента маску,
// через которую выделяется его значимый код
//
// Параметры:
//  ТипАдресногоЭлемента -  Число - тип адресного элемента.
//
// Возвращаемое значение:
// Число - Маска, при делении на которую выделяется значимый код адресного элемента
//
Функция киПолучитьТипАдресногоЭлемента(КодЭлемента) Экспорт
	
	Если КодЭлемента = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Если КодЭлемента % киМаскаРегиона() < 100  Тогда // регион 21 ноль и АА
		Возврат 1;
		
	ИначеЕсли КодЭлемента % киМаскаРайона() < 100 Тогда // район 18 ноль и АА
		Возврат 2;
		
	ИначеЕсли КодЭлемента % киМаскаГорода() < 100 Тогда // город 15 ноль и АА
		Возврат 3;
		
	ИначеЕсли КодЭлемента % киМаскаНасПункта() < 100 Тогда // населенный пункт 12 ноль и АА
		Возврат 4;
		
	ИначеЕсли КодЭлемента % киМаскаУлицы() < 100 Тогда // улица 8 ноль и АА
		Возврат 5;
		
	ИначеЕсли КодЭлемента % киМаскаДома() < 100 Тогда // дом 4 ноль и АА
		Возврат 6;
		
	Иначе // квартира
		Возврат 7;
		
	КонецЕсли;
	
КонецФункции // киПолучитьТипАдресногоЭлемента()

// Функция получения структуры адресного элемента
//
// Параметры:
//  КодЭлемента -  Число - Код адресного элемента.
//
// Возвращаемое значение:
// 	Структура - Структура адресного элемента
//
Функция киПолучитьСтруктуруАдресногоЭлемента(КодЭлемента) Экспорт

	ТекстЗапроса = "ВЫБРАТЬ
	               |	АдресныйКлассификатор.Код,
	               |	АдресныйКлассификатор.КодРегионаВКоде,
	               |	АдресныйКлассификатор.Наименование,
	               |	АдресныйКлассификатор.Сокращение,
	               |	АдресныйКлассификатор.Индекс,
	               |	АдресныйКлассификатор.ТипАдресногоЭлемента,
	               |	АдресныйКлассификатор.КодРайонаВКоде,
	               |	АдресныйКлассификатор.КодГородаВКоде,
	               |	АдресныйКлассификатор.КодНаселенногоПунктаВКоде,
	               |	АдресныйКлассификатор.КодУлицыВКоде
	               |ИЗ
	               |	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
	               |ГДЕ
	               |	АдресныйКлассификатор.Код = &КодЭлемента";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КодЭлемента", КодЭлемента);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Новый Структура("Код,Наименование,Сокращение,ТипАдресногоЭлемента,Индекс,КодРегионаВКоде,КодРайонаВКоде,КодГородаВКоде,КодНаселенногоПунктаВКоде,КодУлицыВКоде",
		                         Выборка.Код,
		                         Выборка.Наименование,
		                         Выборка.Сокращение,
		                         Выборка.ТипАдресногоЭлемента,
		                         Выборка.Индекс,
		                         Выборка.КодРегионаВКоде,
		                         Выборка.КодРайонаВКоде,
		                         Выборка.КодГородаВКоде,
		                         Выборка.КодНаселенногоПунктаВКоде,
		                         Выборка.КодУлицыВКоде);

	Иначе 
		Возврат киПолучитьПустуюСтруктуруАдреса();
		
	КонецЕсли;
	
КонецФункции // киПолучитьСтруктуруАдресногоЭлемента()

// Функция ставит в соответствие типу адресного элемента маску,
// через которую выделяется его значимый код
//
// Параметры:
//  АдресныйЭлемент - СправочникСсылка - Элемент справочника, для которого необходимо получить маску.
//
// Возвращаемое значение:
// 	Число - маска, при делении на которую выделяется значимый код адресного элемента
//
Функция киПолучитьМаску(АдресныйЭлемент) Экспорт
	Возврат киПолучитьМаскуПоТипу(АдресныйЭлемент.ТипАдресногоЭлемента);
КонецФункции // киПолучитьМаску()

// Функция возвращает структуру с набором полей как у записи регистра сведений
//  АдресныйКлассификатор с пустым набором значений
//
// Параметры:
// 	Нет.
//
// Возвращаемое значение:
// Структура - Структура с набором полей как у записи регистра сведений АдресныйКлассификатор
//			   с пустым набором значений
//
Функция киПолучитьПустуюСтруктуруАдреса() Экспорт
	
	Возврат Новый Структура("Код,Наименование,Сокращение,ТипАдресногоЭлемента,Индекс,КодРегионаВКоде,КодРайонаВКоде,КодГородаВКоде,КодНаселенногоПунктаВКоде,КодУлицыВКоде", 0, "", "", 0, "", 0, 0, 0, 0, 0);
	
КонецФункции // киПолучитьПустуюСтруктуруАдреса()

// Функция ищет требуемый адресный элемент по названию и типу 
// и возвращает первый найденный. В качестве дополнения может 
// быть задан элемент "родитель"
//
// Параметры:
//  НазваниеЭлемента - Строка -	Название адресного элемента ( с сокращением)
//  ТипЭлемента 	 - Число  - Тип искомого адресного элемента
//  ЭлементРодитель  - Ссылка - Элемент "родитель"
//
// Возвращаемое значение:
//  Структура - Найденный элемент справочника Адресный классификатор или пустая ссылка в случае неудачи
//
Функция киПолучитьАдресныйЭлемент(НазваниеЭлемента, ТипЭлемента, КодЭлементаРодителя = 0) Экспорт

	Перем КодРегиона, КодРайона, КодГорода, КодНаселенногоПункта, КодУлицы, КодДома;
	
	Если (СокрЛП(НазваниеЭлемента) = "") ИЛИ (ТипЭлемента = 0) Тогда
		Возврат киПолучитьПустуюСтруктуруАдреса();
	КонецЕсли;
	
	// смотрим есть ли в имени адресное сокращение этого уровня
	// если есть, то ищем по наименованию и адресному сокращению
	АдресноеСокращение = "";
	НазваниеЭлемента = киПолучитьИмяИАдресноеСокращение(НазваниеЭлемента, АдресноеСокращение);

	Запрос = Новый Запрос();
	
	ОграничениеПоКоду = "";
	Если КодЭлементаРодителя > 0 Тогда // проверка на соответствие подчинению родителю
		ТипАдрЭлемента = киПолучитьТипАдресногоЭлемента(КодЭлементаРодителя);
		МаскаРодителя = киПолучитьМаскуПоТипу(ТипАдрЭлемента);
		
		Если ТипАдрЭлемента <= 5 Тогда
			
			КодЭлемента = КодЭлементаРодителя;
			
			киРазложитьКодАдресногоЭлементаНаСоставляющие(КодЭлемента, КодРегиона, КодРайона, КодГорода, КодНаселенногоПункта, КодУлицы, КодДома);

			Если КодРегиона <> 0 Тогда
				ОграничениеПоКоду = ОграничениеПоКоду + Символы.ПС + "  И (АдресныйКлассификатор.КодРегионаВКоде = &КодРегионаВКоде)";
				Запрос.УстановитьПараметр("КодРегионаВКоде", КодРегиона);
			КонецЕсли;
			
			Если КодРайона <> 0 Тогда
				ОграничениеПоКоду = ОграничениеПоКоду + Символы.ПС + "  И (АдресныйКлассификатор.КодРайонаВКоде = &КодРайонаВКоде)";
				Запрос.УстановитьПараметр("КодРайонаВКоде", КодРайона);
			КонецЕсли;
			
			Если КодГорода <> 0 Тогда
				ОграничениеПоКоду = ОграничениеПоКоду + Символы.ПС + "  И (АдресныйКлассификатор.КодГородаВКоде = &КодГородаВКоде)";
				Запрос.УстановитьПараметр("КодГородаВКоде", КодГорода);
			КонецЕсли;
			
			Если КодНаселенногоПункта <> 0 Тогда
				ОграничениеПоКоду = ОграничениеПоКоду + Символы.ПС + "  И (АдресныйКлассификатор.КодНаселенногоПунктаВКоде = &КодНаселенногоПунктаВКоде)";
				Запрос.УстановитьПараметр("КодНаселенногоПунктаВКоде", КодНаселенногоПункта);
			КонецЕсли;
			
			Если КодУлицы <> 0 Тогда
				ОграничениеПоКоду = ОграничениеПоКоду + Символы.ПС + "  И (АдресныйКлассификатор.КодУлицыВКоде = &КодУлицыВКоде)";
				Запрос.УстановитьПараметр("КодУлицыВКоде", КодУлицы);
			КонецЕсли;
		
		Иначе
			// ограничиваем по коду элемента
			КонечноеЗначениеКода = КодЭлементаРодителя + МаскаРодителя - 1; 
			
			ОграничениеПоКоду = Символы.ПС + "  И (АдресныйКлассификатор.Код Между &НачальноеЗначениеКода И &КонечноеЗначениеКода)";
			Запрос.УстановитьПараметр("НачальноеЗначениеКода", КодЭлементаРодителя);
			Запрос.УстановитьПараметр("КонечноеЗначениеКода", КонечноеЗначениеКода);
		КонецЕсли;
		
	КонецЕсли;
	
	
	
	ТекстЗапроса = "ВЫБРАТЬ
	               |	АдресныйКлассификатор.Код,
	               |	АдресныйКлассификатор.КодРегионаВКоде,
	               |	АдресныйКлассификатор.ТипАдресногоЭлемента
	               |ИЗ
	               |	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
	               |ГДЕ
	               |	АдресныйКлассификатор.Наименование = &Наименование
	               |	И АдресныйКлассификатор.ТипАдресногоЭлемента = &ТипАдресногоЭлемента
	               |	"+?(ЗначениеЗаполнено(АдресноеСокращение),"И АдресныйКлассификатор.Сокращение = &Сокращение","");
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Наименование", НазваниеЭлемента);
	Запрос.УстановитьПараметр("ТипАдресногоЭлемента", ТипЭлемента);
	Запрос.УстановитьПараметр("Сокращение", АдресноеСокращение);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если КодЭлементаРодителя > 0 Тогда // проверка на соответствие подчинению родителю
		МаскаРодителя = киПолучитьМаскуПоТипу(киПолучитьТипАдресногоЭлемента(КодЭлементаРодителя));
	КонецЕсли;
	
	Пока Выборка.Следующий() Цикл
		Если КодЭлементаРодителя > 0 Тогда // проверка на соответствие подчинению родителю
			Если Цел(КодЭлементаРодителя / МаскаРодителя) <> Цел(Выборка.Код / МаскаРодителя) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		Возврат киПолучитьСтруктуруАдресногоЭлемента(Выборка.Код);
		
	КонецЦикла;
	
	Возврат киПолучитьПустуюСтруктуруАдреса();
	
КонецФункции // киПолучитьАдресныйЭлемент()

// Функция определяет входимость числа в заданный диапазон
//  При этом диапазон задается как это описано в комментарии к функции ЧислоВИнтервале
//
// Параметры: 
//  Номер    - Число, Строка - Номер дома с корпусом
//  Интервал - Строка - Интервал чисел (домов)
//
// Возвращаемое значение:
//  Булево - Истина, если заданное число входит в диапазон, ложь, если не входит
//
Функция киВходитВИнтервал(Знач Номер, Интервал) Экспорт

	Если ПустаяСтрока("" + Номер) Тогда
		Возврат Ложь;
	КонецЕсли;

	Если НЕ ТолькоЧисло(Номер) Тогда
		Возврат СтрЗаменить("" + Номер, " ", "") = СтрЗаменить("" + Интервал, " ", "");
	КонецЕсли;

	Номер = Число(Номер);

	Если ТолькоЧисло(Интервал) Тогда
		Если Номер = Число(Интервал) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;

	Если Найти(Интервал,"Ч") > 0 Тогда // диапазон четных чисел
		Интервал      = СтрЗаменить(Интервал, "Ч", "");
		Четность = 2;
		
	ИначеЕсли Найти(Интервал,"Н") > 0 Тогда // диапазон нечетных чисел
		Интервал      = СтрЗаменить(Интервал, "Н", "");
		Четность = 1;
		
	ИначеЕсли (Найти(Интервал, "-") = 0) И ТолькоЧисло(Интервал) Тогда 
		// интервал это дом представленный в виде строки
		Возврат Ложь;
		
	Иначе
		Четность=0;
		
	КонецЕсли;
	
	Интервал = СтрЗаменить(Интервал, ")", ""); // на всякий случай уберем скобки
	Интервал = СтрЗаменить(Интервал, "(", "");
	Позиция  = Найти(Интервал, "-");
	Попали = 0;
	
	Если Позиция <> 0 Тогда
		МинЗначение  = Число(Лев(Интервал, Позиция - 1));
		МаксЗначение = Число(Сред(Интервал, Позиция + 1));
		Если (Номер >= МинЗначение) И (Номер <= МаксЗначение) Тогда
			Попали = 1;
		КонецЕсли;
		
	Иначе
		Если ТолькоЧисло(Интервал) Тогда
			Если Номер = Число(Интервал) Тогда
				Попали = 1;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;
	
	Если (Попали = 1) И (
	((Четность = 2) И (Номер % 2 = 0)) ИЛИ 
	((Четность = 1) И (Номер % 2 = 1)) ИЛИ 
	 (Четность = 0)) Тогда
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // ВходитВИнтервал()

// Функция определяет входимость:
//  1. Номера дома (представленного в виде строки)
//     где Номер дома, это строка вида:
//     <СтрокаДом> пример: 58А, 32/1, 50А/8
//
//  2. Номера дома и номера корпуса (строения), в виде строки:
//     <СтрокаДом>к<СтрокаКорпус>,   пример: 32к1   это дом 32 корпус 1, 
//     <СтрокаДом>/<СтрокаКорпус>,   пример: 32/1   это дом 32 корпус 1, 
//     <СтрокаДом>стр<СтрокаКорпус>, пример: 32стр1 это дом 32 корпус 1, 
//		
//  3. Числа (номера дома) в заданный интервал чисел
//     При этом интервал задается строкой вида:
//     <Диапазон>[,<Диапазон>]
//     где Диапазон, это строка вида:
//     [Ч/Н]<Число>[-<Число>]
//     Префикс Ч или Н диапазона обозначает четность и нечетность входящих в него чисел
//     Пример: в интервал Ч12-14,Н1-5,20-29 входят числа 1,3,5,12,14 и все с 20 по 29
//
// Параметры: 
//  Номер    - Строка - Номер дома с корпусом
//  Интервал - Строка - Интервал чисел (домов)
//
// Возвращаемое значение:
//  Булево - Истина, если заданное число входит в диапазон, ложь, если не входит
//
Функция киНомерДомаВИнтервале(Номер, Знач Интервал) Экспорт
	
	Пока НЕ ПустаяСтрока(Интервал) Цикл

		Позиция = Найти(Интервал, ",");
		Если Позиция = 0 Тогда
			Возврат киВходитВИнтервал(Номер, Интервал);
		Иначе
			Если киВходитВИнтервал(Номер, СокрЛП(Лев(Интервал, Позиция - 1))) Тогда
				Возврат Истина;
			Иначе
				Интервал = Сред(Интервал, Позиция + 1);
			КонецЕсли;
		КонецЕсли;

	КонецЦикла;

	Возврат Ложь;

КонецФункции // НомерДомаВИнтервале()

// Функция определяет индекс по переданным улице, дому и корпусу
//
// Параметры: 
//  Улица 	     - СправочникСсылка - Элемент справочника адресный классификатор с требуемой улицей
//  НомерДома    - Строка           - Номер дома, для которого необходимо получить индекс
//  НомерКорпуса - Строка			- Номер корпуса
//
// Возвращаемое значение:
//  Строка - шестизначный почтовый индекс
//
Функция киПолучитьИндексПоУлицеДомуКорпусу(Улица, НомерДома, НомерКорпуса) Экспорт

	Запрос = Новый Запрос;
    Запрос.УстановитьПараметр("Уровень", 6);
    Запрос.УстановитьПараметр("НижнийКод", Цел(Улица.Код / 10000000000) * 10000000000);
    Запрос.УстановитьПараметр("ВерхнийКод", Цел(Улица.Код / 10000000000 + 1) * 10000000000);

	Запрос.Текст =
	"ВЫБРАТЬ
	|	АдресныйКлассификатор.Наименование,
	|	АдресныйКлассификатор.Индекс
	|ИЗ
	|	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
	|
	|ГДЕ
	|	АдресныйКлассификатор.ТипАдресногоЭлемента = &Уровень И
	|	АдресныйКлассификатор.Код МЕЖДУ &НижнийКод И &ВерхнийКод";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл

		Интервал = Врег(СокрЛП(Выборка.Наименование));

		Если (киНомерДомаВИнтервале(СокрЛП(НомерДома) + ?(НЕ ПустаяСтрока(НомерКорпуса), "К", "") + СокрЛП(НомерКорпуса), Интервал)) Тогда
			Возврат Выборка.Индекс;

		ИначеЕсли (киНомерДомаВИнтервале(СокрЛП(НомерДома) + ?(НЕ ПустаяСтрока(НомерКорпуса), "/", "") + СокрЛП(НомерКорпуса), Интервал)) Тогда
			Возврат Выборка.Индекс;

		ИначеЕсли (киНомерДомаВИнтервале(СокрЛП(НомерДома) + ?(НЕ ПустаяСтрока(НомерКорпуса), "стр", "") + СокрЛП(НомерКорпуса), Интервал)) Тогда
			Возврат Выборка.Индекс;

		КонецЕсли;

	КонецЦикла;

	Возврат Улица.Индекс;

КонецФункции // киПолучитьИндексПоУлицеДомуКорпусу()

// Функция определяет индекс по переданным региону, району, городу, населенному пункту,
// улице, дому и корпусу
//
// Параметры: 
//  НазваниеРегиона 		  - Строка - Название региона( с сокращением)
//  НазваниеРайона  		  - Строка - Название района( с сокращением)
//  НазваниеГорода  		  - Строка - Название города( с сокращением)
//  НазваниеНаселенногоПункта - Строка - Название населенного пункта( с сокращением)
//  Улица 					  - Строка - Название улицы ( с сокращением)
//  НомерДома 				  - Строка - Номер дома, для которого необходимо получить индекс
//  НомерКорпуса 			  - Строка - Номер корпуса
//
// Возвращаемое значение:
//  Строка - шестизначный почтовый индекс
//
Функция киПолучитьИндекс(Знач НазваниеРегиона, Знач НазваниеРайона, Знач НазваниеГорода, Знач НазваниеНаселенногоПункта, Знач НазваниеУлицы, Знач НомерДома, Знач НомерКорпуса) Экспорт

	РодительИндекса = киПолучитьПустуюСтруктуруАдреса();
	Индекс = "";
	
	Регион = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(НазваниеРегиона), 1);
	Если Регион.Код > 0 Тогда
        РодительИндекса = Регион;
		Если НЕ ПустаяСтрока(Регион.Индекс) Тогда
			Индекс = Регион.Индекс;
		КонецЕсли;
	КонецЕсли;
	
	Район = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(НазваниеРайона), 2, РодительИндекса.Код);
	Если Район.Код > 0 Тогда
		РодительИндекса = Район;
		Если НЕ ПустаяСтрока(Район.Индекс) Тогда
			Индекс = Район.Индекс;
		КонецЕсли;
	КонецЕсли;
	
	Город = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(НазваниеГорода), 3, РодительИндекса.Код);
	Если Город.Код > 0 Тогда
		РодительИндекса = Город;
		Если НЕ ПустаяСтрока(Город.Индекс) Тогда
			Индекс = Город.Индекс;
		КонецЕсли;
	КонецЕсли;
	
	НаселенныйПункт = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(НазваниеНаселенногоПункта), 4, РодительИндекса.Код);
	Если НаселенныйПункт.Код > 0 Тогда
		РодительИндекса = НаселенныйПункт;
		Если НЕ ПустаяСтрока(НаселенныйПункт.Индекс) Тогда
			Индекс = НаселенныйПункт.Индекс;
		КонецЕсли;
	КонецЕсли;
	
	//Улица = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(НазваниеУлицы), 5, РодительИндекса.Код);
	Улица = киПолучитьАдресныйЭлемент(НазваниеУлицы, 5, РодительИндекса.Код);
	Если Улица.Код > 0 Тогда
		ИндексУлицы = киПолучитьИндексПоУлицеДомуКорпусу(Улица, НомерДома, НомерКорпуса);
		Если НЕ ПустаяСтрока(ИндексУлицы) Тогда
			Индекс = ИндексУлицы;
		КонецЕсли;
	КонецЕсли;

	Возврат Индекс;

КонецФункции // киПолучитьИндекс()

#Если Клиент Тогда
// процедура формирования текста автоподбора
//
// Параметры:
// Элемент - Строка    - Элемент адреса
// Форма   - Форма     - Переданная форма
// Объект  - Структура - Структура объекта адреса
// Текст   - Строка    - Текст автоподбора
//
Процедура киСформироватьТекстАвтоподбора(Элемент, Форма, Объект, Текст) Экспорт
	Если СтрДлина(СокрЛП(Текст)) > 2 Тогда
		ТипАдресногоЭлемента = 0;
		Если Найти(Элемент.Имя, "ПолеРегион") > 0  Тогда
			ТипАдресногоЭлемента = 1;
		ИначеЕсли Найти(Элемент.Имя, "ПолеРайон") > 0  Тогда
			ТипАдресногоЭлемента = 2;
		ИначеЕсли Найти(Элемент.Имя, "ПолеГород") > 0  Тогда
			ТипАдресногоЭлемента = 3;
		ИначеЕсли Найти(Элемент.Имя, "ПолеНаселенныйПункт") > 0  Тогда
			ТипАдресногоЭлемента = 4;
		ИначеЕсли Найти(Элемент.Имя, "ПолеУлица") > 0  Тогда
			ТипАдресногоЭлемента = 5;
		КонецЕсли;
		Если ТипАдресногоЭлемента <> 0 Тогда
			ТаблицаАдресныхЭлементов = киПоискВАдресномКлассификаторе(Текст, ТипАдресногоЭлемента, Объект);
			Если ТаблицаАдресныхЭлементов.Количество() = 0 Тогда
				СтрокаАвтоПодбора = Неопределено;
			ИначеЕсли ТаблицаАдресныхЭлементов.Количество() = 1 Тогда
				СтрокаАвтоПодбора = ТаблицаАдресныхЭлементов.Получить(0);
			Иначе
				СписокЗначенийПоиска = Новый СписокЗначений();
				Для Каждого СтрокаТаблицы Из ТаблицаАдресныхЭлементов Цикл
					СписокЗначенийПоиска.Добавить(СокрЛП(СтрокаТаблицы.НаименованиеЭлемента) + " " + СокрЛП(СтрокаТаблицы.СокращениеЭлемента)); 
				КонецЦикла;	
				ЭлементСпискаЗначенийПоиска = Форма.ВыбратьИзСписка(СписокЗначенийПоиска, Элемент);
				Если ЭлементСпискаЗначенийПоиска = Неопределено Тогда
					СтрокаАвтоПодбора = Неопределено;
				Иначе
					СтрокаАвтоПодбора = ТаблицаАдресныхЭлементов.Получить(СписокЗначенийПоиска.Индекс(ЭлементСпискаЗначенийПоиска));	 
				КонецЕсли;	 
			КонецЕсли;
			Если СтрокаАвтоПодбора <> Неопределено Тогда
				Объект.Поле1 = СтрокаАвтоПодбора.ИндексЭлемента;
				Элемент.Значение = СокрЛП(СтрокаАвтоПодбора.НаименованиеЭлемента) + " " + СокрЛП(СтрокаАвтоПодбора.СокращениеЭлемента);
				Представление = киПолучитьПредставлениеАдреса(Объект);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли; 	
КонецПроцедуры// киСформироватьТекстАвтоподбора(Элемент, Текст)

// функция поиска в адресном классификаторе
//
// Параметры:
//
//	НаименованиеАдресногоЭлемента - Строка - Наименование адресного элемента
//	ТипАдресногоЭлемента          - Число  - Тип адресного элемента
//	Объект                        - Строка - Элемент адреса
//	КоличествоЭлементовСписка     - Число  - Количество элементов списка
//
// Возвращаемое значение:
//	ТаблицаЗначений - Таблица результатов поиска
//
Функция киПоискВАдресномКлассификаторе(НаименованиеАдресногоЭлемента, ТипАдресногоЭлемента, Объект, КоличествоЭлементовСписка = 30)
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
				   |	АдресныйКлассификатор.Наименование КАК НаименованиеЭлемента,
				   |	АдресныйКлассификатор.Сокращение КАК СокращениеЭлемента,
				   |	АдресныйКлассификатор.Индекс КАК ИндексЭлемента
				   |ИЗ
				   |	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
				   |ГДЕ
				   |	АдресныйКлассификатор.Наименование ПОДОБНО &НаименованиеАдресногоЭлемента
				   |	И АдресныйКлассификатор.ТипАдресногоЭлемента = &ТипАдресногоЭлемента";
	Запрос.УстановитьПараметр("НаименованиеАдресногоЭлемента", НаименованиеАдресногоЭлемента+"%");
	Запрос.УстановитьПараметр("ТипАдресногоЭлемента", ТипАдресногоЭлемента);
	
	Если ТипАдресногоЭлемента > 1 Тогда
		РодительскийЭлемент = киПолучитьПустуюСтруктуруАдреса();
		КодРодителяРодителя = 0;
	 
		Регион = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(Объект.Поле2), 1);

		Если Регион.Код > 0 Тогда
			РодительскийЭлемент = Регион;
			КодРодителяРодителя = Регион.Код;
		КонецЕсли;
		
		Если ТипАдресногоЭлемента > 2 Тогда
			
			Район = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(Объект.Поле3), 2, КодРодителяРодителя);

			Если Район.Код > 0 Тогда
				РодительскийЭлемент = Район;
				КодРодителяРодителя = Район.Код;
			КонецЕсли;
			
			Если ТипАдресногоЭлемента > 3 Тогда
				Город = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(Объект.Поле4), 3, КодРодителяРодителя);
			
				Если Город.Код > 0 Тогда
					РодительскийЭлемент = Город;
					КодРодителяРодителя = Город.Код;
				КонецЕсли;
				Если ТипАдресногоЭлемента > 4 Тогда
					НаселенныйПункт = киПолучитьАдресныйЭлемент(киОбрезатьСокращение(Объект.Поле5), 4, КодРодителяРодителя);
					Если НаселенныйПункт.Код > 0 Тогда
						РодительскийЭлемент = НаселенныйПункт;
						КодРодителяРодителя = НаселенныйПункт.Код;
					КонецЕсли;
				КонецЕсли;//Если ТипАдресногоЭлемента > 4 Тогда
			КонецЕсли;//Если ТипАдресногоЭлемента > 3 Тогда
		КонецЕсли;//Если ТипАдресногоЭлемента > 2 Тогда
		КодРодительскогоЭлемента = РодительскийЭлемент.Код;
		
		КодРегионаРодительскогоЭлемента   = Цел(КодРодительскогоЭлемента / киМаскаРегиона());
		Запрос.Текст = Запрос.Текст + "
									  |	И АдресныйКлассификатор.КодРегионаВКоде = &КодРегионаРодительскогоЭлемента";
		Запрос.УстановитьПараметр("КодРегионаРодительскогоЭлемента", КодРегионаРодительскогоЭлемента);
		Если ТипАдресногоЭлемента > 2 Тогда
			КодРайонаРодительскогоЭлемента    = Цел(КодРодительскогоЭлемента / киМаскаРайона()) % 1000;
			Запрос.Текст = Запрос.Текст + "
										  |	И АдресныйКлассификатор.КодРайонаВКоде = &КодРайонаРодительскогоЭлемента";
			Запрос.УстановитьПараметр("КодРайонаРодительскогоЭлемента", КодРайонаРодительскогоЭлемента);
			Если ТипАдресногоЭлемента > 3 Тогда
				КодГородаРодительскогоЭлемента    = Цел(КодРодительскогоЭлемента / киМаскаГорода()) % 1000;
				Запрос.Текст = Запрос.Текст + "
											  |	И АдресныйКлассификатор.КодГородаВКоде = &КодГородаРодительскогоЭлемента";
				Запрос.УстановитьПараметр("КодГородаРодительскогоЭлемента", КодГородаРодительскогоЭлемента);
				Если ТипАдресногоЭлемента > 4 Тогда
					КодНасПунктаРодительскогоЭлемента = Цел(КодРодительскогоЭлемента / киМаскаНасПункта()) % 1000;
					Запрос.Текст = Запрос.Текст + "
												  |	И АдресныйКлассификатор.КодНаселенногоПунктаВКоде = &КодНасПунктаРодительскогоЭлемента";
					Запрос.УстановитьПараметр("КодНасПунктаРодительскогоЭлемента", КодНасПунктаРодительскогоЭлемента);
				КонецЕсли;//Если ТипАдресногоЭлемента > 4 Тогда
			КонецЕсли;//Если ТипАдресногоЭлемента > 3 Тогда
		КонецЕсли;//Если ТипАдресногоЭлемента > 2 Тогда
	КонецЕсли;//Если ТипАдресногоЭлемента > 1 Тогда
	
	ТаблицаРезультатовПоиска = Запрос.Выполнить().Выгрузить();
	Если ТаблицаРезультатовПоиска.Количество() > КоличествоЭлементовСписка Тогда
		Предупреждение("Найдено более "+КоличествоЭлементовСписка+" значений, удовлетворяющих условиям выбора.
						   |Задайте более длинную строку.");
		Пока ТаблицаРезультатовПоиска.Количество() > КоличествоЭлементовСписка Цикл
			ТаблицаРезультатовПоиска.Удалить(ТаблицаРезультатовПоиска.Получить(КоличествоЭлементовСписка));
		КонецЦикла;	
	КонецЕсли;
	Возврат ТаблицаРезультатовПоиска;
КонецФункции// киПоискВАдресномКлассификаторе()
#КонецЕсли

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С АДРЕСНЫМ КОДОМ

// Маска  СС РРР ГГГ ППП УУУУ ДДДД КККК АА
//
//        СС   - код региона
//        РРР  - код района
//        ГГГ  - код города
//        ППП  - код населенного пункта
//        УУУУ - код улицы
//        ДДДД - код дома
//        КККК - код квартиры
//        АА   - код актуальности

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаРегиона() Экспорт
	Возврат 100000000000000000000000;
КонецФункции // киСформироватьТекстАвтоподбора()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаРайона() Экспорт
	Возврат 100000000000000000000;
КонецФункции // киМаскаРайона()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаГорода() Экспорт
	Возврат 100000000000000000;
КонецФункции // киМаскаГорода()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаНасПункта() Экспорт
	Возврат 100000000000000;
КонецФункции // киМаскаНасПункта()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаУлицы() Экспорт
	Возврат 10000000000;
КонецФункции // киМаскаУлицы()

// Функция проверяет содержит ли строка только число
// без лидирующих нулей.
// Применяется при вычислении почтового индекса для адреса.
//
// Параметры:
//  ИспытуемаяСтрока - Строка - Строка для проверки
//
// Возвращаемое значение:
//  Булево - Истина, если строка содержит только число, иначе Ложь
//
Функция ТолькоЧисло(ИспытуемаяСтрока)

	Попытка
		Временно = Число(ИспытуемаяСтрока);
	Исключение
		Возврат Ложь;
	КонецПопытки;

	Возврат Строка(Число(ИспытуемаяСтрока)) = ИспытуемаяСтрока;

КонецФункции // ТолькоЧисло()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаДома() Экспорт
	Возврат 1000000;
КонецФункции // киМаскаДома()

// Функция возвращает маску  для определения номера элемента в структуре кода 
//
// Параметры: 
//	Нет
//
// Возвращаемое значение:
//  Число - маска с единица в значимых разрядах и нулями в остальных
//
Функция киМаскаКвартиры() Экспорт
	Возврат 100;
КонецФункции // киМаскаКвартиры()

// Функция возвращает набор записей регистра сведений КонтактнаяИнформация
//
// Параметры:
//  Объект 					- СправочникСсылка  - Ссылка на элемент справочников: Контрагенты,
//							Контактные лица, Организации, Сотрудники. Для этого элемента выбираются
//							записи регистра КонтактнаяИнформация.
//  ТипКонтактнойИнформации - ПеречислениеСсылка - Тип контактной информации, записи которого
//							выбираются в набор записей. Если равен неопределено, выбираются все записи.
//
// Возвращаемое значение:
// 	РегистрСведенийНаборЗаписей	 - Набор записей контактной информации
//
Функция киНаборЗаписейКонтактнойИнформацииОбъекта(Объект, ТипКонтактнойИнформации = Неопределено) Экспорт
	РегистрКонтактнойИнформации = РегистрыСведений.КонтактнаяИнформация;
	НаборЗаписейКонтактнойИнформации = РегистрКонтактнойИнформации.СоздатьНаборЗаписей();
	
	НаборЗаписейКонтактнойИнформации.Отбор.Объект.Установить(Объект);
	Если Не ТипКонтактнойИнформации = Неопределено Тогда
		НаборЗаписейКонтактнойИнформации.Отбор.Тип.Установить(ТипКонтактнойИнформации);
	КонецЕсли;
	НаборЗаписейКонтактнойИнформации.Прочитать();
	
	Возврат НаборЗаписейКонтактнойИнформации;
	
КонецФункции// НаборЗаписейКонтактнойИнформацииОбъекта(Объект, ТипКонтактнойИнформации = Неопределено);	

// Процедура проверяет, есть ли записи по умолчанию данного типа и если нет ни одной, тогда свойство ПоУмолчанию
// устанавливается у первой записи данного типа.
//
// Параметры:
//  НаборЗаписейКонтактнойИнформации - РегистрСведенийНаборЗаписей - Набор записей, который проверяется
//									 на предмет наличия записи по умолчанию;
//  ТипКонтактнойИнформации 		 - ПеречислениеСсылка 		   - Тип контактной информации, записи 
//   								которого проверяются на предмет наличия записей по умолчанию.
//         							Если равен неопределено, перебираются все типы.
//
Процедура киПроверитьНаличиеЗаписиПоУмолчанию(НаборЗаписейКонтактнойИнформации, ТипКонтактнойИнформации = Неопределено, Записывать = Ложь) Экспорт	// если тип заранее неизвестен, то переберём все возможные типы контактной информации
	Если ТипКонтактнойИнформации = Неопределено Тогда
		Для Каждого ОчереднойТипКонтактнойИнформации Из Перечисления.ТипыКонтактнойИнформации Цикл
			киПроверитьНаличиеЗаписиПоУмолчанию(НаборЗаписейКонтактнойИнформации, ОчереднойТипКонтактнойИнформации, Записывать);
		КонецЦикла;
	Иначе	
		ПерваяЗаписьИскомогоТипа = Неопределено;
		НайденаЗаписьПоУмолчанию = Ложь;
		Для Каждого ЗаписьКонтактнойИнформации Из НаборЗаписейКонтактнойИнформации Цикл
			Если ЗаписьКонтактнойИнформации.Тип = ТипКонтактнойИнформации Тогда
				Если ЗаписьКонтактнойИнформации.ЗначениеПоУмолчанию Тогда
					НайденаЗаписьПоУмолчанию = Истина;
					Прервать;
				Иначе
					Если ПерваяЗаписьИскомогоТипа = Неопределено Тогда
						ПерваяЗаписьИскомогоТипа = ЗаписьКонтактнойИнформации;
					КонецЕсли;	
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Если (Не НайденаЗаписьПоУмолчанию) И (Не ПерваяЗаписьИскомогоТипа = Неопределено) Тогда
			ПерваяЗаписьИскомогоТипа.ЗначениеПоУмолчанию = Истина;
			Если Записывать Тогда
				НаборЗаписейКонтактнойИнформации.Записать(Истина);
			КонецЕсли;	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры// киПроверитьНаличиеЗаписиПоУмолчанию()	

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТЕЛЕФОНАМИ

// Функция возвращает список телефонов объекта с сортировкой по значению по умолчанию
//
Функция киПолучитьСписокТелефоновОбъекта(Контрагент) Экспорт
	
	Телефоны = Новый СписокЗначений;
	
	Если ЗначениеЗаполнено(Контрагент) И ТипЗнч(Контрагент)=Тип("СправочникСсылка.Контрагенты") Тогда	
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ
		               |	КонтактнаяИнформация.Вид КАК ВидТелефона,
		               |	КонтактнаяИнформация.Представление КАК ПредставлениеТелефона,
		               |	КонтактнаяИнформация.Поле1 КАК КодРегиона,
		               |	КонтактнаяИнформация.Поле2 КАК КодГорода,
		               |	КонтактнаяИнформация.Поле3 КАК НомерТелефона,
		               |	КонтактнаяИнформация.Поле4 КАК ВнутреннийНомер
		               |ИЗ
		               |	РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
		               |ГДЕ
		               |	КонтактнаяИнформация.Объект = &Контрагент
		               |	И КонтактнаяИнформация.Тип = &Тип
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	КонтактнаяИнформация.ЗначениеПоУмолчанию УБЫВ";
		Запрос.УстановитьПараметр("Тип",Перечисления.ТипыКонтактнойИнформации.Телефон);
		Запрос.УстановитьПараметр("Контрагент",Контрагент);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			СтруктураТелефона = Новый Структура;
			СтруктураТелефона.Вставить("ВидТелефона",Выборка.ВидТелефона);				
			СтруктураТелефона.Вставить("КодРегиона",Выборка.КодРегиона);
			СтруктураТелефона.Вставить("КодГорода",Выборка.КодГорода);	
			СтруктураТелефона.Вставить("НомерТелефона",Выборка.НомерТелефона);
			СтруктураТелефона.Вставить("ВнутреннийНомер",Выборка.ВнутреннийНомер);
			СтруктураТелефона.Вставить("ПредставлениеТелефона",Выборка.ПредставлениеТелефона);	
			Телефоны.Добавить(СтруктураТелефона,Строка(Выборка.ВидТелефона) + ": " + Выборка.ПредставлениеТелефона);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Телефоны;
	
КонецФункции //киПолучитьСписокТелефоновОбъекта()

// Функция выполняет попытку сохранить указанный в документе телефон в контактную информацию 
//
Функция киОбновитьТелефонКонтрагентаПослеЗаписи(ДокументСсылка,Контрагент=Неопределено) Экспорт 
	
	Если ДокументСсылка = Неопределено Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ДокументСсылка.ПредставлениеТелефона) Тогда
		Возврат Неопределено;		
	КонецЕсли;
	
	СтруктураКИ = Новый Структура;
	Если ЗначениеЗаполнено(Контрагент) Тогда
		СтруктураКИ.Вставить("Объект",Контрагент);				
	Иначе
		СтруктураКИ.Вставить("Объект",ДокументСсылка.Контрагент);				
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(СтруктураКИ.Объект) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураКИ.Вставить("Тип",Перечисления.ТипыКонтактнойИнформации.Телефон);	
	Если ЗначениеЗаполнено(ДокументСсылка.ВидТелефона) Тогда
		СтруктураКИ.Вставить("Вид",ДокументСсылка.ВидТелефона);
	Иначе
		СтруктураКИ.Вставить("Вид",Справочники.ВидыКонтактнойИнформации.ТелефонСотовый);
	КонецЕсли;
	СтруктураКИ.Вставить("Поле1",ДокументСсылка.КодРегиона);
	СтруктураКИ.Вставить("Поле2",ДокументСсылка.КодГорода);	
	СтруктураКИ.Вставить("Поле3",ДокументСсылка.НомерТелефона);
	СтруктураКИ.Вставить("Поле4",ДокументСсылка.ВнутреннийНомер);
	СтруктураКИ.Вставить("Представление",ДокументСсылка.ПредставлениеТелефона);	
	
	НайденныйТелефон = "";
	ДоступныВидыКИ = Новый СписокЗначений;
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ЕСТЬNULL(КонтактнаяИнформация.Представление, """") КАК Представление,
	               |	КонтактнаяИнформация.Вид,
	               |	КонтактнаяИнформация.ЗначениеПоУмолчанию
	               |ПОМЕСТИТЬ ТелефоныОбъекта
	               |ИЗ
	               |	РегистрСведений.КонтактнаяИнформация КАК КонтактнаяИнформация
	               |ГДЕ
	               |	КонтактнаяИнформация.Объект = &Объект
	               |	И КонтактнаяИнформация.Тип = &Тип
	               |;
	               |
	               |////////////////////////////////////////////////////////////////////////////////
	               |ВЫБРАТЬ
	               |	ВидыКонтактнойИнформации.Ссылка КАК Вид,
	               |	ВидыКонтактнойИнформации.Наименование КАК Наименование,
	               |	ЕСТЬNULL(ТелефоныОбъекта.Представление, """") КАК Представление,
	               |	ЕСТЬNULL(ТелефоныОбъекта.ЗначениеПоУмолчанию, Ложь) КАК ЗначениеПоУмолчанию
	               |ИЗ
	               |	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
	               |		ЛЕВОЕ СОЕДИНЕНИЕ ТелефоныОбъекта КАК ТелефоныОбъекта
	               |		ПО ВидыКонтактнойИнформации.Ссылка = ТелефоныОбъекта.Вид
	               |ГДЕ
	               |	ВидыКонтактнойИнформации.Тип = &Тип";
	Запрос.УстановитьПараметр("Тип",СтруктураКИ.Тип);
	Запрос.УстановитьПараметр("Объект",СтруктураКИ.Объект);
	Выборка = Запрос.Выполнить().Выбрать();
	
	ЯвляетсяЗначениемПоУмолчанию = Ложь;
	НайденоЗначениеПоУмолчанию = Ложь;
	Пока Выборка.Следующий() Цикл
		Если Выборка.Представление = СтруктураКИ.Представление Тогда
			//телефон уже есть в регистре, ничего записывать не нужно
			Возврат Неопределено;	
		КонецЕсли;
		Если Выборка.Вид = СтруктураКИ.Вид Тогда   
			НайденныйТелефон = Выборка.Представление;	
			Если Выборка.ЗначениеПоУмолчанию Тогда
				ЯвляетсяЗначениемПоУмолчанию = Истина;
			КонецЕсли;
		КонецЕсли;
		Если Выборка.Представление = "" Тогда
			ДоступныВидыКИ.Добавить(Выборка.Вид,Выборка.Наименование);	
		КонецЕсли;
		НайденоЗначениеПоУмолчанию = (Выборка.ЗначениеПоУмолчанию ИЛИ НайденоЗначениеПоУмолчанию);
	КонецЦикла;
	
	Если НайденныйТелефон = "" Тогда
		//у контрагента еще не было этого телефона - записываем без вопросов
		ВыбранныйВид = СтруктураКИ.Вид;
	Иначе
		//у контрагента уже есть телефон этого вида в регистре - спросим о дальнейших действиях
		ФормаИзмененияТелефона = Обработки.РедактированиеКонтактнойИнформации.ПолучитьФорму("ФормаИзмененияТелефона");
		ФормаИзмененияТелефона.Контрагент = СтруктураКИ.Объект;
		ФормаИзмененияТелефона.ПредставлениеТелефона = НайденныйТелефон;
		ФормаИзмененияТелефона.ВидТелефона = СтруктураКИ.Вид;
		ФормаИзмененияТелефона.ЭлементыФормы.СписокВидовКИ.СписокВыбора=ДоступныВидыКИ;
		ВыбранныйВид	= ФормаИзмененияТелефона.ОткрытьМодально();
		Если ВыбранныйВид = Неопределено Тогда
			Возврат Неопределено;	
		КонецЕсли;
	КонецЕсли;	
	
	ИзменитьЗначениеПоУмолчанию = (НЕ НайденоЗначениеПоУмолчанию ИЛИ ЯвляетсяЗначениемПоУмолчанию);
	
	//пишем данные в регистр с заменой записей
	НаборКИ = РегистрыСведений.КонтактнаяИнформация.СоздатьНаборЗаписей();
	НаборКИ.Отбор.Объект.Установить(СтруктураКИ.Объект);
	НаборКИ.Отбор.Тип.Установить(СтруктураКИ.Тип);
	НаборКИ.Прочитать();
	
	Для Каждого ТекЗапись Из НаборКИ Цикл
		Если ТекЗапись.Вид = ВыбранныйВид Тогда
			РедактируемаяЗапись = ТекЗапись;
		КонецЕсли;
		Если ИзменитьЗначениеПоУмолчанию Тогда
			ТекЗапись.ЗначениеПоУмолчанию = Ложь;	
		КонецЕсли;
	КонецЦикла;
	
	Если РедактируемаяЗапись = Неопределено Тогда
		РедактируемаяЗапись = НаборКИ.Добавить();
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(РедактируемаяЗапись, СтруктураКИ);
	РедактируемаяЗапись.Вид = ВыбранныйВид;
	РедактируемаяЗапись.ЗначениеПоУмолчанию = ИзменитьЗначениеПоУмолчанию;
	
	Попытка
		НаборКИ.Записать();
	Исключение
		Сообщить("Не удалось записать контактную информацию",СтатусСообщения.Важное);	
	КонецПопытки;
	
	Если ИзменитьЗначениеПоУмолчанию Тогда
		ОбъектКонтрагент = СтруктураКИ.Объект.ПолучитьОбъект();		
		ОбъектКонтрагент.ОсновнойТелефон = СтруктураКИ.Представление;
		Попытка
			ОбъектКонтрагент.Записать();
		Исключение
			Сообщить("Не удалось записать основной телефон в справочник ""Контрагенты""",СтатусСообщения.Важное);	
		КонецПопытки;
	КонецЕсли;
	
КонецФункции //киОбновитьТелефонКонтрагентаПослеЗаписи()

// Проверка на наличие пустой строки
Функция киПроверкаПустойСтроки(ВыбСтрока, ПризнакЗапятой=Истина) Экспорт
	
	Если ПустаяСтрока(ВыбСтрока) Тогда
		Возврат "";
	Иначе
		Возврат ?(ПризнакЗапятой,",","")+" ";
	КонецЕсли; 
	
КонецФункции // ПроверкаПустойСтроки()

// Функция приводит телефонный номер к одному из указанных в настройке шаблонов
//
// Параметры
//  НомерТЛФ – строка, номер телефона, который надо преобразовывать
//
// Возвращаемое значение:
//   Приведенный номер – строка, номер, приведенный к одному из шаблонов
//
Функция киПривестиНомерТелефонаКШаблону(Знач НомерТЛФ) Экспорт
	
	ТолькоЦифрыНомера = "";
	КоличествоЦифрНомера = 0;
	
	Для а=1 По СтрДлина(НомерТЛФ) Цикл
		Если СтрЧислоВхождений("1234567890",Сред(НомерТЛФ,а,1)) > 0 Тогда
			КоличествоЦифрНомера = КоличествоЦифрНомера + 1;
			ТолькоЦифрыНомера = ТолькоЦифрыНомера + Сред(НомерТЛФ,а,1);
		КонецЕсли;
	КонецЦикла;
	
	Если КоличествоЦифрНомера = 0 Тогда
		Возврат НомерТЛФ;
	КонецЕсли;
	
	СтруктураШаблонов = киПолучитьШаблоныВВидеСоответствия();
	Если ТипЗнч(СтруктураШаблонов)<>Тип("Соответствие") Тогда
		Возврат НомерТЛФ;
	КонецЕсли; 
	ПолученныйШаблон = СтруктураШаблонов.Получить(КоличествоЦифрНомера);
	
	Если ПолученныйШаблон=Неопределено Тогда
		Возврат НомерТЛФ;
	КонецЕсли;
	
	ПриведенныйНомер = "";
	НомерЦифры = 0;
	
	Для а=1 По СтрДлина(ПолученныйШаблон) Цикл
		Если Сред(ПолученныйШаблон,а,1) = "9" Тогда
			НомерЦифры = НомерЦифры + 1;
			ПриведенныйНомер = ПриведенныйНомер + Сред(ТолькоЦифрыНомера,НомерЦифры,1);
		Иначе
			ПриведенныйНомер = ПриведенныйНомер + Сред(ПолученныйШаблон,а,1);
		КонецЕсли;
	КонецЦикла; 

	Возврат ПриведенныйНомер;
	
КонецФункции // ПривестиКШаблону()

// Получает шаблоны телефонов из строки, которая хранится в настройках и представляет их в виде соответствия.
//
// Параметры:
//  НЕТ
//
// Возвращаемое значение:
//   Соответствие: Ключ-Количество цифр в номере; Значение-Строка шаблона
// 
Функция киПолучитьШаблоныВВидеСоответствия() Экспорт
	ШаблоныСоответствие = Новый Соответствие;	
	СтрокаСШаблонами   = СокрЛП(обПраво("ШаблоныТелефонныхНомеров"));
	
	// Начинаем разбор форматной строки. удалим пробелы.
	СтрокаСШаблонами = СтрЗаменить(СтрокаСШаблонами, " ", "");	
	
	Если ПустаяСтрока(СтрокаСШаблонами) Тогда
		Возврат ШаблоныСоответствие;	
	КонецЕсли;
		
	// Лишних символов нет.
	МассивШаблонов = Новый Массив;
	Пока Истина Цикл
		НомерСимвола = Найти(СтрокаСШаблонами, ";");
		Если НомерСимвола=0 Тогда
			Если СтрДлина(СтрокаСШаблонами)<>0 Тогда
				МассивШаблонов.Добавить(СтрокаСШаблонами);	
			КонецЕсли;
			Прервать;
		Иначе		
			ВремСтрока = Лев(СтрокаСШаблонами, НомерСимвола-1); 
			Если СтрДлина(ВремСтрока)<>0 Тогда
				МассивШаблонов.Добавить(ВремСтрока);	
			КонецЕсли;
			Если НомерСимвола<>СтрДлина(СтрокаСШаблонами) Тогда				
				СтрокаСШаблонами = Сред(СтрокаСШаблонами, НомерСимвола+1);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Теперь у нас массив с шаблонами. Сделаем из него соответствие. При этом,
	// не должно быть шаблонов с одинаковым количеством цифр.
	Для Каждого ТекЭлемент Из МассивШаблонов Цикл  	
		КоличествоДевяток = СтрЧислоВхождений(ТекЭлемент, "9");
		Если (КоличествоДевяток<>0) И (ШаблоныСоответствие.Получить(КоличествоДевяток)=Неопределено) Тогда
			ШаблоныСоответствие.Вставить(КоличествоДевяток, ТекЭлемент);	
		КонецЕсли;
	КонецЦикла;
	
		
	Возврат ШаблоныСоответствие;
КонецФункции // ПолучитьШаблоныВВидеСоответствия()

// Оставляет в номере телефона только цифры, все остальные символы удаляются
Функция киУбратьИзНомераТелефонаВсеБуквы(НомерТелефона) Экспорт
	ТолькоЦифрыНомера = "";
	Для а=1 По СтрДлина(НомерТелефона) Цикл
		Если СтрЧислоВхождений("1234567890",Сред(НомерТелефона,а,1)) > 0 Тогда
			ТолькоЦифрыНомера = ТолькоЦифрыНомера + Сред(НомерТелефона,а,1);
		КонецЕсли;
	КонецЦикла;
	Возврат ТолькоЦифрыНомера;
КонецФункции

// Функция убирает из номера телефона все префиксы, например, 999-99*99, будет 9999999 
//  префиксы передаются в СтрокеПрефиксов
Функция киУбратьИзНомераТелефонаВсеПрефиксы(НомерТелефона, СтрокаПрефиксов=" /*-+=_.\,!;%:?()") Экспорт
	Для НомерПрефикс = 1 По СтрДлина(СтрокаПрефиксов) Цикл
		ТекущийПрефикс = Сред(СтрокаПрефиксов, НомерПрефикс, 1);
		НомерТелефона = СтрЗаменить(НомерТелефона, ТекущийПрефикс, "");
	КонецЦикла;
	Возврат НомерТелефона;
КонецФункции

