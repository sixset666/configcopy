// Процедуры и функции общего назначения

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

// Возвращает модуль числа
//
// Параметры:
//  Х – Число - Исходное число
// Возвращаемое значение:
//  Число – модуль исходного числа
//
Функция обМод(Х) Экспорт
	Возврат ?(Х >= 0, Х, -Х);
КонецФункции // обМод()

// Возвращает дробную часть числа
//
// Параметры:
//  Х – Число - Исходное число
// Возвращаемое значение:
//  Число – дробная часть исходного числа
//
Функция обДроб(Х) Экспорт
	Возврат Х - Цел(Х);
КонецФункции // обДроб()

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ ФОРМАТИРОВАНИЯ ДАННЫХ

// Функция возвращает номер месяца по названию или название по номеру
//
// Параметры:
//  ЗначЧисла - Число  - номер месяца или
//              Строка - название месяца
//  Реж 	  - Число  - 1 - кратко
//                       2 - полно
//  Язык      - Число  - 1 - русский
//                       2 - английский
//
// Возвращаемое значение:
//	Число, Строка - Номер или название месяца
//
Функция обПолучитьМесяц(Знач Зн,Реж=1,Язык=1) Экспорт
	Если Язык=1 Тогда
		ПВ=9;
		СП="Январь  ,Февраль ,Март    ,Апрель  ,Май     ,Июнь    ,Июль    ,Август  ,Сентябрь,Октябрь ,Ноябрь  ,Декабрь  ";
	ИначеЕсли Язык=2 Тогда
		ПВ=11;
		СП="January   ,February  ,March     ,April     ,May       ,June      ,July      ,August    ,September ,October   ,November  ,December   ";
	Иначе
		Возврат 1;
	КонецЕсли;
	
	Если (Реж<>1) И (Реж<>2) Тогда
		Возврат ?(ТипЗнч(Зн)=Тип("Строка"),"Янв",1);
	КонецЕсли;
	
	Если ТипЗнч(Зн)=Тип("Число") Тогда
		Возврат СокрЛП(Сред(СП,(Зн-1)*ПВ+1,?(Реж=1,3,ПВ-1)));
	ИначеЕсли ТипЗнч(Зн)=тиП("Строка") Тогда
		Возврат Цел(Найти(СП,Зн)/ПВ)+1;
	Иначе
		Возврат Зн;
	КонецЕсли;
КонецФункции // обПолучитьМесяц()

// Возвращает полное или краткое / русское или английское название дня недели.
// по номеру или по дате
// Так же может вернуть номер дня недели по строке
//
// Параметры:
//  Зн   - Число  - номер дня недели или
//         Строка - название дня недели
//  Реж  - Число  - 1 - кратко
//                  2 - полно
//  Язык - Число  - 1 - русский
//                  2 - английский
//
// Возвращаемое значение:
//  Число, Строка - Номер или название дня недели
//
Функция обПолучитьДеньНедели(Знач Зн, Реж=1, Язык=1) Экспорт
	Если ТипЗнч(Зн)=Тип("Дата") Тогда
		Зн=ДеньНедели(Зн);
	ИначеЕсли СтрДлина(Зн)=1 Тогда
		Зн=Число(Зн);
	Иначе
		Зн=СокрЛП(Зн);
	КонецЕсли;
	
	Если (Язык=1)И(Реж=1) Тогда
		ПВ=12;
		СП="Понедельник,Вторник    ,Среда      ,Четверг    ,Пятница    ,Суббота    ,Воскресенье";
	ИначеЕсли (Язык=1)И(Реж=2) Тогда
		ПВ=3;
		СП="Пн,Вт,Ср,Чт,Пт,Сб,Вс";
	ИначеЕсли (Язык=2)И(Реж=1) Тогда
		ПВ=10;
		СП="Monday   ,Tuesday  ,Wednesday,Thursday ,Friday   ,Saturday ,Sunday   ";
	ИначеЕсли (Язык=2)И(Реж=2) Тогда
		ПВ=3;
		СП="Mo,Tu,We,Th,Fr,Sa,Su";
	Иначе
		Возврат 1;
	КонецЕсли;
	
	Если ТипЗнч(Зн)=Тип("Число") Тогда
		Возврат СокрЛП(Сред(СП,(Зн-1)*ПВ+1,ПВ-1));
	ИначеЕсли ТипЗнч(Зн)=Тип("Строка") Тогда
		Возврат Цел(Найти(СП,Зн)/ПВ)+1;
	Иначе
		Возврат Зн;
	КонецЕсли;
КонецФункции // обПолучитьДеньНедели()

// Возвращает правильное склонение слова "день" по количеству дней.
//
// Параметры:
//  КолДней   - Число  - количество дней
//
// Возвращаемое значение:
// Строка - Слово в нужном склонении
//
Функция обПолучитьПредставлениеДня(Знач КолДней) Экспорт
	КолДней = Макс(КолДней, -КолДней); 
	ОстатокОтДеления = КолДней%10; 
	Если ОстатокОтДеления = 0 ИЛИ ОстатокОтДеления >=5 И ОстатокОтДеления <=9 
		ИЛИ КолДней%100 >= 10 И КолДней%100 <= 19 Тогда
		Возврат "дней";	
	ИначеЕсли ОстатокОтДеления = 1 Тогда
		Возврат "день";
	ИначеЕсли ОстатокОтДеления >=2 И ОстатокОтДеления <=4 Тогда
		Возврат "дня";
	КонецЕсли;		
КонецФункции // обПолучитьПредставлениеДня()

// Возвращает текстовый параметр для запроса по переданному виду сравнения.
//
// Параметры:
//	Сравнение - ВидСравнения - Вид сравнения, для которого получается представление
//
// Возвращаемое значение:
//	Структура - Текстовое описание сравнения
//
Функция обПолучитьПредставлениеИнтервала(Сравнение) Экспорт
	Результат = Новый Структура("Тип, Представление");
	Если      Сравнение         = ВидСравнения.Больше Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " > ";
	ИначеЕсли Сравнение         = ВидСравнения.БольшеИлиРавно Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " >=";
	ИначеЕсли Сравнение         = ВидСравнения.Меньше Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " < ";
	ИначеЕсли Сравнение         = ВидСравнения.МеньшеИлиРавно Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " <=";
	ИначеЕсли Сравнение         = ВидСравнения.НеРавно Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " <> ";
	ИначеЕсли Сравнение         = ВидСравнения.Равно Тогда
		Результат.Тип           = "Простое";
		Результат.Представление = " = ";
	ИначеЕсли Сравнение         = ВидСравнения.Интервал Тогда
		Результат.Тип           = "Интервал";
		Результат.Представление = " >   <  ";
	ИначеЕсли Сравнение         = ВидСравнения.ИнтервалВключаяГраницы Тогда
		Результат.Тип           = "ИнтервалОбе";
		Результат.Представление = " МЕЖДУ ";
	ИначеЕсли Сравнение         = ВидСравнения.ИнтервалВключаяНачало Тогда
		Результат.Тип           = "ИнтервалНачало";
		Результат.Представление = " >=  <  ";
	ИначеЕсли Сравнение         = ВидСравнения.ИнтервалВключаяОкончание Тогда
		Результат.Тип           = "ИнтервалОкончание";
		Результат.Представление = " >   <= ";
	ИначеЕсли Сравнение         = ВидСравнения.Содержит Тогда
		Результат.Тип           = "Содержит";
		Результат.Представление = " ПОДОБНО ";
	ИначеЕсли Сравнение         = ВидСравнения.ВСписке Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " В ";
	ИначеЕсли Сравнение         = ВидСравнения.НеВСписке Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " НЕ В ";
	ИначеЕсли Сравнение         = ВидСравнения.ВИерархии Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " В ИЕРАРХИИ";
	ИначеЕсли Сравнение         = ВидСравнения.НеВИерархии Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " НЕ В ИЕРАРХИИ";
	ИначеЕсли Сравнение         = ВидСравнения.ВСпискеПоИерархии Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " В ИЕРАРХИИ";
	ИначеЕсли Сравнение         = ВидСравнения.НеВСпискеПоИерархии Тогда
		Результат.Тип           = "Список";
		Результат.Представление = " НЕ В ИЕРАРХИИ";
	ИначеЕсли Сравнение         = ВидСравнения.НеСодержит Тогда
		Результат.Тип           = "Содержит";
		Результат.Представление = " НЕ ПОДОБНО ";
	Иначе
		Возврат Неопределено
	КонецЕсли;

	Возврат Результат;
КонецФункции // обПолучитьПредставлениеИнтервала()

// Функция, приводящая строку к необходимой длине строки символом
//
// Параметры:
//	Стр    - Строка - Исходная строка
//	Символ - Строка - Символ, добавляемый в строку
//	Длина  - Число  - Требуемая длина строки
// 	Реж    - Число  - 1 - добавлять символы слева, 2 - справа, 3 - слева и справа
//
// Возвращаемое значение:
//	Строка - Строка после обработки
//
Функция обСтрокаПривести(Стр,Символ,Длина,Реж=1) Экспорт
 	ДопСтр=""; Сч=Длина-СтрДлина(Стр);
	Если Сч>0  Тогда
		Для к=1 По Сч Цикл
			ДопСтр=ДопСтр+Символ;
		КонецЦикла;
		Если Реж=1 Тогда Возврат ДопСтр+Стр;
		ИначеЕсли Реж=2 Тогда Возврат Стр+ДопСтр;
		Иначе к=Окр(Сч/2); Возврат Лев(ДопСтр,к)+Стр+Прав(ДопСтр,Сч-к);
		КонецЕсли;
	Иначе 
		Если Реж = 1 Тогда  
			Стр = Лев(Стр, Длина);
		ИначеЕсли Реж = 2 Тогда
			Стр = Прав(Стр, Длина);
		Иначе
			Нач = обМод(Окр(Сч/2)); 
			Стр = Сред(Стр, Нач, Длина);
		КонецЕсли;
		Возврат Стр;
	КонецЕсли;
КонецФункции // обСтрокаПривести()

// Функция, приводящая строку к необходимой длине строки, обрезая лишнее.
//
// Параметры:
//	ИсходнаяСтрока	- Строка - Исходная строка;
//	Длина			- Число  - Требуемая конечная длина строки;
//	ПодстрокаВКонце - Строка - Символы, добавляемые в конце конечной строки.
//
// Возвращаемое значение:
//	Строка - Строка после обработки
//
Функция обОбрезатьСтроку(ИсходнаяСтрока, Длина, ПодстрокаВКонце = "")	Экспорт
	Если СтрДлина(ИсходнаяСтрока) > Длина Тогда
		Возврат Лев(ИсходнаяСтрока, Длина-СтрДлина(ПодстрокаВКонце))+ ПодстрокаВКонце;
	Иначе
		Возврат ИсходнаяСтрока;
	КонецЕсли;
КонецФункции // обОбрезатьСтроку()

// Функция возвращает строку символов, полученную из исходной <Стр>
// заменой всех символов, не входящих в <Маска> на символ <Симв>
//
//Параметры:
//	Стр   - Строка - Исходная строка
//  Маска - Строка - Строка допустимых символов
//	Симв  - Строка - Символ замены
//
// Возвращаемое значение:
//	Строка - Строка после обработки
//
Функция обСтрокаПоМаске(Стр,Маска="",Симв="") Экспорт
	Ст=""; Если ПустаяСтрока(Маска) Тогда Возврат Ст; КонецЕсли;
	Для Сч=1 По СтрДлина(Стр) Цикл
		Сим=Сред(Стр,Сч,1);
		Если Найти(Маска,Сим)>0 Тогда Ст=Ст+Сим; Иначе Ст=Ст+Симв; КонецЕсли; 
	КонецЦикла;
	Возврат Ст;
КонецФункции // обСтрокаПоМаске()

// Функция возвращает истина если строка введена с допустимыми символами, иначе - ложь.
//
//Параметры:
//	Строка   - Строка - Исходная строка
//  ДопустимыеСимволы - Строка - Строка допустимых символов
//
// Возвращаемое значение:
//	Результат - Булево - Истина: в строке нет недопустимых символов; Ложь: такие имеются.
//
Функция обСтрокаСодержитТолькоДопустимыеСимволы(Строка, ДопустимыеСимволы) Экспорт 
	МассивСимволов = Новый Массив;
	Для Позиция = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		МассивСимволов.Добавить(Сред(ДопустимыеСимволы,Позиция,1));
	КонецЦикла;
	
	Для Позиция = 1 По СтрДлина(Строка) Цикл
		Если МассивСимволов.Найти(Сред(Строка, Позиция, 1)) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции // обСтрокаСодержитТолькоДопустимыеСимволы()

// Приводит произвольную строку к идентификатору, который затем можно использовать как ключ структуры
// Преобразование выполняется разрушающим способом (обратное преобразование невозможно)
//
//Параметры:
//	Стр   - Строка - Исходная строка
//
// Возвращаемое значение:
//	Строка - Строка после обработки
//
Функция обСтрокуКID(Стр) Экспорт
	Ст=обСтрокаПоМаске(Стр,"_0123456789
	                       |ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
	                       |АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюя");
	Возврат ?(Найти("0123456789",Лев(Ст,1))>0,"_"+Ст,Ст);
КонецФункции // обСтрокуКID()

// Функция возвращает информационную строку регистра КартинкиИФайлы
// по ОбъектИнформации
//
//Параметры:
//	ОбъектИнформации - СправочникСсылка - Объект информации
//
// Возвращаемое значение:
//	Строка - Информационная строка регистра
//
Функция обФайлыКартинки(ОбъектИнформации=Неопределено) Экспорт
	СписокФайловКартинок = "Файлы и картинки";
	Если ОбъектИнформации=Неопределено Тогда
		Возврат СписокФайловКартинок;
	КонецЕсли;
	
	//проверим право
	Если НЕ обПраво("ПроверятьНаличиеФайловОткрываемыхЭлементов") Тогда
		Возврат СписокФайловКартинок;
	КонецЕсли;
	
	//Получим СписокФайловКартинок
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	КартинкиИФайлы.Идентификатор
	|ИЗ
	|	РегистрСведений.КартинкиИФайлы КАК КартинкиИФайлы
	|ГДЕ
	|	КартинкиИФайлы.Объект = &ОбъектИнформации
	|АВТОУПОРЯДОЧИВАНИЕ");
	Запрос.УстановитьПараметр("ОбъектИнформации",ОбъектИнформации);
	РезультатЗапроса = Запрос.Выполнить().Выгрузить();
	Если РезультатЗапроса.Количество()=0 Тогда
		Возврат СписокФайловКартинок;
	Иначе
		СписокФайловКартинок = "Файлы, картинки ("+РезультатЗапроса.Количество()+") ";
		Для Каждого ФайлКартинка Из РезультатЗапроса Цикл
			СписокФайловКартинок = СписокФайловКартинок + ФайлКартинка.Идентификатор + ", ";
		КонецЦикла;
		СписокФайловКартинок = Сред(СписокФайловКартинок,1,СтрДлина(СписокФайловКартинок)-2)+".";
		Возврат СписокФайловКартинок;
	КонецЕсли;
КонецФункции // обФайлыКартинки()

//Функция выполняет преобразование числа в строку в соответствии с параметрами форматирования
//
// Параметры:
//	Число         - Число            - Число для преобразования
//	Валюта        - СправочникСсылка - Валюта документа
//	ФормСтрока    - Строка 			 - Форматная строка
//	ПарамПредмета - Строка			 - Параметры прописи. Если задана Валюта - берется из справочника
//
//Возвращаемое значений:
//	Строка - Число прописью
//
Функция обЧислоПрописью(Число,Валюта=Неопределено,ФормСтрока="",ПарамПредмета="") Экспорт
	Если Валюта = Неопределено Тогда
		
	Иначе
		ФормСтрока = "Л=ru_RU;ДП=Ложь";
		ПарамПредмета = Валюта.ПараметрыПрописиНаРусском;
		Если ПарамПредмета = "" Тогда
			Возврат ЧислоПрописью(Число) + Валюта
		КонецЕсли;
	КонецЕсли;
Возврат ЧислоПрописью(Число,ФормСтрока,ПарамПредмета);
КонецФункции //обЧислоПрописью()

// Формирует префикс объекта, согласно настроек для фирмы, указанных в правах
//
// Параметры
//  ЭтотОбъект  – Ссылка или Объект – Ссылка на объект или сам объект,
//                 для которого требуется сформировать префикс.
//  Префикс  – Строка – Шаблон формирования префикса объекта, отличный от настроек.
//                 Если не задан, то берется из настроек.
//  УзелРИБ  – СсылкаПланОбмена – Ссылка на план обмена,
//                 для которого требуется сформировать префикс.
//
// Возвращаемое значение:
//   Строка   – Префикс объекта, сформированный на основании шаблона.
//
Функция обПолучитьПрефиксОбъекта(ЭтотОбъект, Знач Префикс="", УзелРИБ=Неопределено) Экспорт
	ЭтотОбъектМетаданные=ЭтотОбъект.Метаданные();
	
	//Получим шаблон префикса объекта
	Если ПустаяСтрока(Префикс) Тогда
		Префикс=обПраво("Режим префиксации "+ЭтотОбъектМетаданные.Имя);
		// если не найдено правило префиксации
		Если Префикс = неопределено Тогда
		    Префикс="";
		КонецЕсли; 
	ИначеЕсли Префикс="<пусто>" Тогда
		Префикс="";
	КонецЕсли;
	
	//Найдем данные для префиксации
	Попытка
		ЭтотОбъектОрганизация=ЭтотОбъект.Организация;
	Исключение
		ЭтотОбъектОрганизация=ПараметрыСеанса.Организация;
	КонецПопытки; 
	Попытка
		ЭтотОбъектПодразделениеКомпании=ЭтотОбъект.ПодразделениеКомпании;
	Исключение
		Попытка
			ЭтотОбъектПодразделениеКомпании=ЭтотОбъект.Подразделение;
		Исключение
			ЭтотОбъектПодразделениеКомпании=ПараметрыСеанса.ПодразделениеКомпании;
		КонецПопытки; 
	КонецПопытки; 
	Попытка
		ЭтотОбъектДата=ЭтотОбъект.Дата;
	Исключение
		ЭтотОбъектДата=ТекущаяДата();
	КонецПопытки;
	
	//Заменим префиксы организации
	Если Найти(Префикс,"[О]")<>0 Тогда
		Если обЗначениеНеЗаполнено(ЭтотОбъектОрганизация) Тогда
			// тогда пропустим установку номера и отработаем потом еще раз
			// т.к. номер может зависеть от этих реквизитов
			Возврат Неопределено; 
		КонецЕсли;
		Префикс=СтрЗаменить(Префикс,"[О]",ЭтотОбъектОрганизация.Префикс);
	КонецЕсли; 
	
	//Заменим префиксы Подразделения
	Если Найти(Префикс,"[П]")<>0 Тогда
		Если обЗначениеНеЗаполнено(ЭтотОбъектПодразделениеКомпании) Тогда
			// тогда пропустим установку номера и отработаем потом еще раз
			// т.к. номер может зависеть от этих реквизитов
			Возврат Неопределено; 
		КонецЕсли;
		Префикс=СтрЗаменить(Префикс,"[П]",ЭтотОбъектПодразделениеКомпании.Префикс);
	КонецЕсли;
	
	//Заменим префиксы по дате
	Если Найти(Префикс,"[yy]")<>0 ИЛИ Найти(Префикс,"[yyyy]")<>0 ИЛИ
		 Найти(Префикс,"[M]")<>0 ИЛИ Найти(Префикс,"[MM]")<>0 ИЛИ
		 Найти(Префикс,"[d]")<>0 ИЛИ Найти(Префикс,"[dd]")<>0 Тогда
		 Если обЗначениеНеЗаполнено(ЭтотОбъектДата) Тогда
			// тогда пропустим установку номера и отработаем потом еще раз
			// т.к. номер может зависеть от этих реквизитов
			Возврат Неопределено; 
		 КонецЕсли;
		 Префикс=СтрЗаменить(Префикс,"[yy]",Формат(ЭтотОбъектДата,"ДФ=yy"));
		 Префикс=СтрЗаменить(Префикс,"[yyyy]",Формат(ЭтотОбъектДата,"ДФ=yyyy"));
		 Префикс=СтрЗаменить(Префикс,"[M]",Формат(ЭтотОбъектДата,"ДФ=M"));
		 Префикс=СтрЗаменить(Префикс,"[MM]",Формат(ЭтотОбъектДата,"ДФ=MM"));
		 Префикс=СтрЗаменить(Префикс,"[d]",Формат(ЭтотОбъектДата,"ДФ=d"));
		 Префикс=СтрЗаменить(Префикс,"[dd]",Формат(ЭтотОбъектДата,"ДФ=dd"));
	КонецЕсли;
	
	//Заменим префиксы узла
	Если Найти(Префикс,"[У]")<>0 Тогда
		ПрефиксУзла="";
		ПланОбмена=Метаданные.ПланыОбмена.Найти("УдаленныеПодразделения");
		Если ПланОбмена<>Неопределено Тогда
			Если ПланОбмена.РаспределеннаяИнформационнаяБаза Тогда
				Если УзелРИБ=Неопределено Тогда
					ПрефиксУзла=ПланыОбмена.УдаленныеПодразделения.ЭтотУзел().Префикс;
				Иначе
					ПрефиксУзла=УзелРИБ.Префикс;
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
		Префикс=СтрЗаменить(Префикс,"[У]",ПрефиксУзла);
	КонецЕсли;
	
	Возврат Префикс;
КонецФункции // обПолучитьПрефиксОбъекта() 

// Функция заменяет в строке спец символы xml на их символические аналоги
//
// Параметры:
//	Строка - Строка для замены
//
Функция обЗаменитьСпециальныеСимволыXML(Строка) Экспорт
	
	ВремСтрока = СтрЗаменить(Строка     , "&" , "&amp;");
	ВремСтрока = СтрЗаменить(ВремСтрока , "<" , "&lt;");
	ВремСтрока = СтрЗаменить(ВремСтрока , ">" , "&gt;");
	ВремСтрока = СтрЗаменить(ВремСтрока , """", "&quot;");
	ВремСтрока = СтрЗаменить(ВремСтрока , "'" , "&apos;");
	
	Возврат ВремСтрока;
	
КонецФункции

// Блок клиентских функций и процедур
#Если Клиент Тогда
	
// функция получает имя формы для выбора или изменения характеристик номенклатуры исходя из текущих настроек
//
// Параметры:
//	ВладелецХарактеристики - СправочникСсылка - Владелец
//	ФормаВыбора            - Булево			  - Истина - получаем форму для выбора. Ложь - получаем форму элемента
//
// Возвращаемое значение:
//	Строка - Имя формы
//
Функция обПолучитьИмяФормыХарактеристик(ВладелецХарактеристики,ФормаВыбора=Истина) Экспорт
	ДопИмяФормы="Все"; ИмяФормы=?(ФормаВыбора,"ФормаСписка","ФормаЭлемента");
	Ограничение=НЕОПРЕДЕЛЕНО; ТипНоменклатуры=НЕОПРЕДЕЛЕНО;
	Если ТипЗнч(ВладелецХарактеристики)=Тип("СправочникСсылка.Номенклатура") Тогда
		ТипНоменклатуры=ВладелецХарактеристики.ТипНоменклатуры;
	ИначеЕсли ТипЗнч(ВладелецХарактеристики)=Тип("СправочникСсылка.ТипыНоменклатуры") Тогда
		ТипНоменклатуры=ВладелецХарактеристики;
	КонецЕсли;
	Если НЕ обЗначениеНеЗаполнено(ТипНоменклатуры) Тогда
		Ограничение=ТипНоменклатуры.ОграничениеДанныхХарактеристик;
		Если НЕ обЗначениеНеЗаполнено(Ограничение) Тогда
			ДопИмяФормы=Метаданные.Перечисления.ОграниченияДанныхХарактеристики.ЗначенияПеречисления[Перечисления.ОграниченияДанныхХарактеристики.Индекс(Ограничение)].Имя;
		КонецЕсли;
		Если ФормаВыбора И (Найти(ДопИмяФормы,"Свойства")>0) И (Найти(ДопИмяФормы,"СерийныйНомер")>0) Тогда
			Если НЕ ТипНоменклатуры.УникальностьСерийногоНомера Тогда
				ДопИмяФормы="Свойства"; // При неуникальном сер.№ удобнее использовать форму с отборами и поиском
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Попытка
		Форма=Справочники.ХарактеристикиНоменклатуры.ПолучитьФормуСписка(ИмяФормы+ДопИмяФормы);
		ИмяФормы=ИмяФормы+ДопИмяФормы;
	Исключение
		ИмяФормы=ИмяФормы+"Все";
	КонецПопытки;
	
	Возврат ИмяФормы;
КонецФункции // обПолучитьИмяФормыХарактеристик()
	
#КонецЕсли

///////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Получение синонима реквизита объекта метаданных
//
// Параметры:
//  ЭтотОбъектМетаданные – Ссылка - Сам объект или его метаданные
//  ИмяРеквизита 		 – Строка - Строка с именем реквизита
//  ИмяТабличнойЧасти 	 – Строка - Строка с именем табличной части
//
// Возвращаемое значение:
//	Строка - Синоним реквизита объекта
//
Функция обПолучитьСинонимРеквизита(ЭтотОбъектМетаданные,ИмяРеквизита="",ИмяТабличнойЧасти="") Экспорт
	Если ТипЗнч(ЭтотОбъектМетаданные)<>Тип("ОбъектМетаданных") Тогда
		ТекЭтотОбъектМетаданные=ЭтотОбъектМетаданные.Метаданные();
	Иначе
		ТекЭтотОбъектМетаданные = ЭтотОбъектМетаданные;
	КонецЕсли; 
	СинонимРеквизита=ИмяРеквизита;
	Если ПустаяСтрока(ИмяТабличнойЧасти) Тогда
		Реквизит=ТекЭтотОбъектМетаданные.Реквизиты.Найти(ИмяРеквизита);
	Иначе
		Если ПустаяСтрока(ИмяРеквизита) Тогда
			Реквизит=ТекЭтотОбъектМетаданные.ТабличныеЧасти.Найти(ИмяТабличнойЧасти);
		Иначе
			Реквизит=ТекЭтотОбъектМетаданные.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты.Найти(ИмяРеквизита);
		КонецЕсли;
	КонецЕсли; 
	Если Реквизит<>Неопределено Тогда
		СинонимРеквизита=Реквизит.Синоним;
	КонецЕсли; 
	Возврат СинонимРеквизита;
КонецФункции // обПолучитьСинонимРеквизита()

// Получение имени перечисления по его ссылке
//
// Параметры:
//	Значение – ПеречислениеСсылка - Значение перечисления
//
// Возвращаемое значение:
//	Строка - Имя переданного значения перечисления как оно задано в конфигураторе
//
Функция обПолучитьИмяЗначенияПеречисления(Значение) Экспорт
  Результат = "";
  Если НЕ Значение.Пустая() тогда
    МДОбъект = Значение.Метаданные();
    ИндексЗначения = Перечисления[МДОбъект.Имя].Индекс(Значение);
    Результат = МДОбъект.ЗначенияПеречисления[ИндексЗначения].Имя;
  КонецЕсли;
  Возврат Результат;
КонецФункции // обПолучитьИмяЗначенияПеречисления()
 
///////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

// Определяет заполнено ли переданное значение
//
// Параметры: 
//  Значение - Неопределено - Значение, заполнение которого надо проверить
//
// Возвращаемое значение:
//  Булево - Истина, если значение не заполнено, иначе ложь.
//
Функция обЗначениеНеЗаполнено(Значение) Экспорт

	Результат = Ложь;
	
	Попытка
		Результат = Не ЗначениеЗаполнено(Значение)	
	Исключение // Мутабельные типы (Объекты)
		Результат = Ложь
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции // обЗначениеНеЗаполнено()

// Предназначена для получения пустого значения заданного типа
//
// Параметры:
//	ЗаданныйТип - ТипЗначения - Тип, пустое значение которого нужно получить
//
// Возвращаемое значение:
//	Неопределено - Пустое значение или новый объект
//
Функция обПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
КонецФункции // обПустоеЗначениеТипа();

// Возвращает курс валюты на дату
//
// Параметры:
//	Валюта    - СправочникСсылка - Валюта (элемент справочника "Валюты")
//  ДатаКурса - Дата			 - Дата, на которую следует получить курс
//
// Возвращаемое значение: 
//	Число - Курс, с учетом кратности
//
Функция обКурсДляВалюты(Валюта, ДатаКурса) Экспорт
	Структура = РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ДатаКурса, Новый Структура("Валюта", Валюта));
	Возврат Структура;
КонецФункции // обКурсДляВалюты()

// Функция получает список подразделений-родителей для переданного подразделения.
//
// Параметры:
//  Подразделение – "СправочникСсылка.ПодразделениеКомпании" - Ссылка на элемент справочника,
//  для которого необходимо получить родителей.
//
// Возвращаемое значение:
//   Массив - список родителей элемента справочника.
// 
Функция обПолучитьСписокПодразделенийРодителей(Подразделение) Экспорт
	СписокПодразделений = Новый Массив;		
	Родитель = Подразделение;
	Пока Не Родитель.Пустая() Цикл
		СписокПодразделений.Добавить(Родитель);
		Родитель = Родитель.Родитель;	
	КонецЦикла;
		
	Возврат СписокПодразделений;
КонецФункции // обПолучитьСписокПодразделенийРодителей() 

// Функция возвращает цену товара.
//
// Параметры:
//	ТипЦен       - СправочникСсылка - Тип цен для которого получаем цену.
//  Номенклатура - СправочникСсылка - Товар для которого цена получается.
//	НаМомент     - Дата 			-  Дата,МоментВремени,ДокументСсылка на какой момент получаем цену,
//				 если неопределен, то на конец рабочей даты
//	Контрагент   - СправочникСсылка - для получения цен контрагентов.
//	Валюта       - СправочникСсылка - Валюта (элемент справочника "Валюты")
//	Курс	     - Число 			- Курс валюты, с учетом кратности
//	ХарактеристикаНоменклатуры	- СправочникСсылка  - Характеристика номенклатуры
//	ЕдиницаИзмерения			- СправочникСсылка  - Единица измерения номенклатуры
//	ПодразделениеКомпании		- СправочникСсылка  - Подразделение компании
//	ПолучитьЦенуБазовойЕдиницы	- Булево			- Признак необходимости пересчета цены в цену базовой единицы
//
// Возвращаемое значение:
//	Число - Цена
//
Функция обПолучитьЦену(ТипЦен, Номенклатура,Знач НаМомент=Неопределено, Знач Контрагент=Неопределено,Валюта=Неопределено,Курс=0, Знач ХарактеристикаНоменклатуры=Неопределено, Знач ЕдиницаИзмерения=Неопределено, Знач ПодразделениеКомпании=Неопределено, ПолучитьЦенуБазовойЕдиницы=Истина, ВариантПоставки=Неопределено) Экспорт
	
	// может быть отраслевое переопределение функции модуля...
	Цена = орПолучитьЦену(ТипЦен, Номенклатура, НаМомент, Контрагент, Валюта, Курс, ХарактеристикаНоменклатуры, ЕдиницаИзмерения, ПодразделениеКомпании, ПолучитьЦенуБазовойЕдиницы, ВариантПоставки);
	Если Цена <> Неопределено Тогда
		Возврат Цена;
	Иначе
		Цена = 0;
	КонецЕсли; 
	
	Если обЗначениеНеЗаполнено(ТипЦен) ИЛИ обЗначениеНеЗаполнено(Номенклатура) Тогда Возврат 0; КонецЕсли;
	// определим на какой момент получаем цену
	Если НаМомент=Неопределено Тогда
		#Если Клиент Тогда
		НаМомент=РабочаяДата;
		#Иначе
		НаМомент=ТекущаяДата();
		#КонецЕсли
		НаМомент=КонецДня(НаМомент);
	КонецЕсли;
	// проверим, а не на документ ли получаем цену
	Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(НаМомент)) Тогда
		// если документ еще не записан, то получим цену на дату документа, иначе на момент времени
		Если обЗначениеНеЗаполнено(НаМомент) Тогда
			#Если Клиент Тогда
			НаМомент=РабочаяДата;
			#Иначе
			НаМомент=ТекущаяДата();
			#КонецЕсли
			НаМомент=КонецДня(НаМомент);
		Иначе
			НаМомент=НаМомент.МоментВремени();
		КонецЕсли;
	КонецЕсли;
	// если тип цен - расчетный, то рассчитаем цену
	Если ТипЦен.Рассчитывается Тогда
		// получим цену базового типа
		БазоваяЦена = обПолучитьЦену(ТипЦен.БазовыйТипЦен, Номенклатура, НаМомент, Контрагент, Валюта, Курс, ХарактеристикаНоменклатуры, ЕдиницаИзмерения, ПодразделениеКомпании,, ВариантПоставки);
		Если БазоваяЦена = 0 Тогда Возврат 0; КонецЕсли;
		
		// выполним пересчет по валюте
		Если ЗначениеЗаполнено(Валюта) Тогда
			ВалютаБазовойЦены = Валюта;
			КурсЦены          = ?(Курс = 0, НаМомент, Курс);
		Иначе
			ВалютаЦены = обВалютаТипаЦены(Номенклатура, ТипЦен);
			КурсЦены   = НаМомент;
		КонецЕсли;
		
		ВалютаБазовойЦены = обВалютаТипаЦены(Номенклатура, ТипЦен.БазовыйТипЦен);
		
		// рассчитаем цену
		Цена = БазоваяЦена + (БазоваяЦена*ТипЦен.ПроцентСкидкиНаценки/100);
		
		Если ЗначениеЗаполнено(ВалютаЦены) И ВалютаЦены <> ВалютаБазовойЦены Тогда
			Цена = обПересчет(Цена, ВалютаБазовойЦены, НаМомент, ВалютаЦены, КурсЦены);
		КонецЕсли;
		
	Иначе
		АлгоритмРасчетаЦены = ?(ТипЦен.АлгоритмПолученияЦены.Пустая(), Перечисления.АлгоритмПолученияЦены.ПоНоменклатуре, ТипЦен.АлгоритмПолученияЦены);
		УчетЦенТолькоВРазрезеДопПараметров = Номенклатура.ТипНоменклатуры.УчетЦенТолькоВРазрезеДопПараметров;
		
		Контрагент                 = ?(Контрагент=Неопределено, Справочники.Контрагенты.ПустаяСсылка(), Контрагент);
		ХарактеристикаНоменклатуры = ?(ХарактеристикаНоменклатуры=Неопределено, Справочники.ХарактеристикиНоменклатуры.ПустаяСсылка(), ХарактеристикаНоменклатуры);
		ЕдиницаИзмерения           = ?(ЕдиницаИзмерения=Неопределено, Справочники.ЕдиницыИзмерения.ПустаяСсылка(), ЕдиницаИзмерения);
		
		// Работа с подразделениями отличается. Т.к. в документах назначающих цену
		// (Установка цен, Поступление ТМЦ и проч.) подразделение
		// берется из шапки, то фактически в регистре сведений "Цены", для типа цен поддерживающего учет
		// в разрезе подразделений, не 
		// может быть записей в пустыми подразделениями. Чтобы назначить цену для всех подразделений,
		// необходимо в шапке документа
		// выбрать корневое подразделение. Записи с пустыми подразделениями могут быть только в одном случае - если после 
		// внедрения нового ценообразования не выполнялось перепроведение документов
		// (что, конечно, будет у всех клиентов). Но в этом случае, 
		// мы считаем, что пустое значение подразделения соответствует корневому подразделению.
		Если ПодразделениеКомпании=Неопределено Или ПодразделениеКомпании.Пустая() Тогда
			ПодразделениеКомпании = Справочники.ПодразделенияКомпании.ОсновноеПодразделение;	
		КонецЕсли;
		
		Запрос = Новый Запрос;
		ДопУсловия = "";
		МассивПодразделений = Новый Массив;
				
		ТекстЗапросаНачало = "";
		
		// Необходимо добавить дополнительное поле, для выполнения сортировки.
		// Предполагаем, что большим приоритетом пользуются записи, дополнительные характеристики которых совпадают с 
		// доп. характеристиками переданными в функцию. Затем идут записи, у которых доп. характеристики - пустые значения.
		Если АлгоритмРасчетаЦены=Перечисления.АлгоритмПолученияЦены.ПоХарактеристике Тогда
			ТекстЗапросаНачало = ТекстЗапросаНачало + " 
			|ВЫБОР
			|	КОГДА ХарактеристикаНоменклатуры=&ХарактеристикаНоменклатуры ТОГДА 0
			|	ИНАЧЕ 1 КОНЕЦ";		
		ИначеЕсли АлгоритмРасчетаЦены=Перечисления.АлгоритмПолученияЦены.ПоЕдиницеИзмерения Тогда
			ТекстЗапросаНачало = ТекстЗапросаНачало + " 
			|ВЫБОР
			|	КОГДА ЕдиницаИзмерения=&ЕдиницаИзмерения ТОГДА 0
			|	ИНАЧЕ 1 КОНЕЦ";		
		Иначе
			ТекстЗапросаНачало = ТекстЗапросаНачало + "
			|	0";
		КонецЕсли;
		
		ТекстЗапросаНачало = ТекстЗапросаНачало + " + ВЫБОР";
		
		// Сформируем отбор и сортировку по подразделению
		ТекущееПодразделение = ПодразделениеКомпании;
		ПеременнаяЦикла = 0;
		Пока Истина Цикл
			// Отбор подразделений
			МассивПодразделений.Добавить(ТекущееПодразделение);
			
			// Сортировка подразделений
			ТекстЗапросаНачало = ТекстЗапросаНачало + "
			|	КОГДА ЦеныСрезПоследних.ПодразделениеКомпании = &Подразделение"+ПеременнаяЦикла+"
			|		ТОГДА "+ПеременнаяЦикла;
			
			Запрос.УстановитьПараметр("Подразделение"+ПеременнаяЦикла,ТекущееПодразделение);
			
			// Получаем родителя подразделения
			ТекущееПодразделение = ТекущееПодразделение.Родитель;
			Если обЗначениеНеЗаполнено(ТекущееПодразделение) Тогда
				// Добавим пустое подразделение
				ПеременнаяЦикла = ПеременнаяЦикла + 1;
				ТекущееПодразделение = Справочники.ПодразделенияКомпании.ПустаяСсылка();
				МассивПодразделений.Добавить(ТекущееПодразделение);
				
				ТекстЗапросаНачало = ТекстЗапросаНачало + "
				|	КОГДА ЦеныСрезПоследних.ПодразделениеКомпании = &Подразделение"+ПеременнаяЦикла+"
				|		ТОГДА "+ПеременнаяЦикла;
				
				Запрос.УстановитьПараметр("Подразделение"+ПеременнаяЦикла,ТекущееПодразделение);
				
				Прервать;
			КонецЕсли;
			
			ПеременнаяЦикла = ПеременнаяЦикла + 1;
		КонецЦикла;
			
		ТекстЗапросаНачало = ТекстЗапросаНачало + "
		|	ИНАЧЕ 999
		|КОНЕЦ";
		
		Запрос.УстановитьПараметр("МассивПодразделений",МассивПодразделений);
		
		// Сформируем текст с дополнительными условиями для виртуальной таблицы "СрезПоследних".
		Если АлгоритмРасчетаЦены=Перечисления.АлгоритмПолученияЦены.ПоХарактеристике Тогда
			Если УчетЦенТолькоВРазрезеДопПараметров Тогда
				Если ХарактеристикаНоменклатуры.Пустая() Тогда
					Возврат 0;
				Иначе
					ДопУсловия = " И
					|	(ХарактеристикаНоменклатуры=&ХарактеристикаНоменклатуры)";		
				КонецЕсли;
			Иначе					
				Если ХарактеристикаНоменклатуры.Пустая() Тогда					
					ДопУсловия = " И
					|	(ХарактеристикаНоменклатуры=ЗНАЧЕНИЕ(Справочник.ХарактеристикиНоменклатуры.ПустаяСсылка))";
				Иначе
					ДопУсловия = " И
					|	(ХарактеристикаНоменклатуры=&ХарактеристикаНоменклатуры ИЛИ ХарактеристикаНоменклатуры=ЗНАЧЕНИЕ(Справочник.ХарактеристикиНоменклатуры.ПустаяСсылка))";
				КонецЕсли;	
			КонецЕсли;
			
		ИначеЕсли АлгоритмРасчетаЦены=Перечисления.АлгоритмПолученияЦены.ПоЕдиницеИзмерения Тогда
			Если УчетЦенТолькоВРазрезеДопПараметров Тогда
				Если ЕдиницаИзмерения.Пустая() Тогда
					Возврат 0;
				Иначе
					ДопУсловия = " И
					|	(ЕдиницаИзмерения=&ЕдиницаИзмерения)";		
				КонецЕсли;
			Иначе
				Если ЕдиницаИзмерения.Пустая() Тогда
					ДопУсловия = " И
					|	(ЕдиницаИзмерения=ЗНАЧЕНИЕ(Справочник.ЕдиницыИзмерения.ПустаяСсылка))";
				Иначе
					ДопУсловия = " И
					|	(ЕдиницаИзмерения=&ЕдиницаИзмерения ИЛИ ЕдиницаИзмерения=ЗНАЧЕНИЕ(Справочник.ЕдиницыИзмерения.ПустаяСсылка))"; 			
				КонецЕсли;					
			КонецЕсли;	
		КонецЕсли;
		
		Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
		|	ЦеныСрезПоследних.Цена КАК Цена,
		|	ВЫБОР
		|		КОГДА ЦеныСрезПоследних.ЕдиницаИзмерения=ЗНАЧЕНИЕ(Справочник.ЕдиницыИзмерения.ПустаяСсылка) ТОГДА 1
		|		ИНАЧЕ ЦеныСрезПоследних.ЕдиницаИзмерения.Коэффициент
		|	КОНЕЦ КАК Коэффициент,
		|" + ТекстЗапросаНачало + " КАК ПолеДляСортировки
		|ИЗ
		|	РегистрСведений.Цены.СрезПоследних(&Момент,
		|	ТипЦен=&ТипЦен И
		|	Номенклатура=&Номенклатура " + ДопУсловия + "И
		|	Контрагент=&Контрагент И
		|	ПодразделениеКомпании В (&МассивПодразделений)) КАК ЦеныСрезПоследних
		|ГДЕ"+ТекстЗапросаНачало+" < 999 И 
		|	ЦеныСрезПоследних.Цена <> 0
		|
		|УПОРЯДОЧИТЬ ПО ПолеДляСортировки";
		
		Запрос.УстановитьПараметр("ТипЦен",                     ТипЦен);
		Запрос.УстановитьПараметр("Номенклатура",               Номенклатура);
		Запрос.УстановитьПараметр("Момент",                     НаМомент);
		Запрос.УстановитьПараметр("ХарактеристикаНоменклатуры", ХарактеристикаНоменклатуры);
		Запрос.УстановитьПараметр("ЕдиницаИзмерения",           ЕдиницаИзмерения);
		Запрос.УстановитьПараметр("ПодразделениеКомпании",      ПодразделениеКомпании);
		Запрос.УстановитьПараметр("Контрагент",                 Контрагент);
		
		Коэффициент = 1;
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Цена = Выборка.Цена;
			Коэффициент = Выборка.Коэффициент;
		ИначеЕсли Контрагент.Пустая() Тогда
			// Значим ищем наиболее свежую цену произвольного поставщика.
			Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
			|	ЦеныСрезПоследних.Цена КАК Цена,
			|	ВЫБОР
			|		КОГДА ЦеныСрезПоследних.ЕдиницаИзмерения=ЗНАЧЕНИЕ(Справочник.ЕдиницыИзмерения.ПустаяСсылка) ТОГДА 1
			|		ИНАЧЕ ЦеныСрезПоследних.ЕдиницаИзмерения.Коэффициент
			|	КОНЕЦ КАК Коэффициент,
			|	"+ТекстЗапросаНачало+" КАК ПолеДляСортировки
			|ИЗ
			|	РегистрСведений.Цены.СрезПоследних(&Момент,ТипЦен=&ТипЦен И Номенклатура=&Номенклатура " + ДопУсловия + " И ПодразделениеКомпании В (&МассивПодразделений)) КАК ЦеныСрезПоследних
			|ГДЕ" + ТекстЗапросаНачало + " < 999 И 
			|	ЦеныСрезПоследних.Цена <> 0
			|
			|УПОРЯДОЧИТЬ ПО ЦеныСрезПоследних.Период УБЫВ, ПолеДляСортировки";
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				Цена = Выборка.Цена;
				Коэффициент = Выборка.Коэффициент;
			КонецЕсли;	
		КонецЕсли;
		
		Если ПолучитьЦенуБазовойЕдиницы И АлгоритмРасчетаЦены=Перечисления.АлгоритмПолученияЦены.ПоЕдиницеИзмерения Тогда
			Цена = ?(Коэффициент=0,Цена,Цена/Коэффициент);
		КонецЕсли; 
		
		// Если указана валюта, то пересчитаем цену в нее
		ВалютаТипаЦены = обВалютаТипаЦены(Номенклатура, ТипЦен);
		Если НЕ обЗначениеНеЗаполнено(Валюта) И Валюта <> ВалютаТипаЦены Тогда
			Цена=обПересчет(Цена,ВалютаТипаЦены,НаМомент,Валюта,?(Курс=0,НаМомент,Курс));
		КонецЕсли;
	КонецЕсли;
	
	// Округлим цену.
	Если ТипЦен.ОкруглятьВБольшуюСторону Тогда
		Цена = Окр(Цена,ТипЦен.Точность,1);
	Иначе
		Цена = Окр(Цена,ТипЦен.Точность,0);
	КонецЕсли;

	Возврат Цена;
КонецФункции // обПолучитьЦену()

// Визуализирует структуру списочного типа
//
// Параметры:
//	Таблица  		 – ТаблицаЗначений 	– Списочная  структура, которому надо отобразить интерактивно
//	Реж				 - Строка 			- Режим открытия:
//										"Отдельно" - в новом окне,
//										"Модально" - в модальном режиме,
//										"Печать" - напечатать и закрыться,
//										"Выбор" - для выбора значения, иначе просто открыть.
//	КлючУникальности - Произвольный		- Ключ определяющий форму в которой будет происходить визуализация
//
// Возвращаемое значение:
//	Форма - Форма обработки
//
Функция обТаблицаПоказать(Таблица,Реж="Отдельно",КлючУникальности=Неопределено) Экспорт
	Перем ФормаОбработки;
	
#Если Клиент Тогда
// Вывести форму таблицы можно только на клиенте, однако это отладочная функция
// и может случайно попасть на сервер или внешнее соединение, тогда она ничего не должна делать !

	Если КлючУникальности=Неопределено Тогда
		ФормаОбработки = Обработки.ФормаТаблицыЗначений.ПолучитьФорму("Форма",,);
	Иначе	
		ФормаОбработки = Обработки.ФормаТаблицыЗначений.ПолучитьФорму("Форма",,КлючУникальности);
    КонецЕсли; 

	ФормаОбработки.ИсточникДанных = Таблица;
	Если Реж="Отдельно" Тогда
        Обработка = Обработки.ФормаТаблицыЗначений.Создать();
		Обработка.ПолучитьФорму("Форма",,);
        ФормаОбработки.ИсточникДанных = Таблица;
		ФормаОбработки.Открыть();
	ИначеЕсли Реж="Совместно" Тогда
		ФормаОбработки.Открыть();
	ИначеЕсли Реж="Модально" Тогда
		ФормаОбработки.ОткрытьМодально();
	КонецЕсли; 
	
#КонецЕсли

	Возврат ФормаОбработки;
КонецФункции // обТаблицаПоказать()

// функция пересчитывает Цену из ВалютаНач и возвращает значение Цена в ВалютаКон.
// в параметрах ПоКурсуВалютыНач и ПоКурсуВалютыНач могут передаваться либо сами курсы либо даты
//
// Параметры:
//	ЧислСумма        - Число 			- Сумма для пересчета
//	ВалютаНач        - СправочникСсылка - Начальная валюта
//	ПоКурсуВалютыНач - Число, Дата		- Курс валюты или дата курса
//	ВалютаКон        - СправочникСсылка - Конечная валюта
//	ПоКурсуВалютыКон - Число, Дата		- Курс валюты или дата курса
//	РежимОкр         - РежимОкругления  - Режим округления
//
// Возвращаемое значение:
//	Число - Сумма после пересчета
//
Функция обПересчет(Знач ЧислСумма,ВалютаНач,ПоКурсуВалютыНач,ВалютаКон,ПоКурсуВалютыКон,Знач РежимОкр=Неопределено) Экспорт
	
	Если ЧислСумма = NULL Тогда
		ЧислСумма = 0;
	КонецЕсли;
	
	Если обЗначениеНеЗаполнено(ВалютаНач) ИЛИ обЗначениеНеЗаполнено(ВалютаКон) Тогда
		Возврат ЧислСумма;
	КонецЕсли; 
	
	Попытка
		Если ВалютаНач=ВалютаКон Тогда
			Возврат ЧислСумма;
		КонецЕсли;
	Исключение
	КонецПопытки; 

	ТипЗн=ТипЗнч(ПоКурсуВалютыНач);
	Если ТипЗн=Тип("Число") Тогда КурсВалютыНач=ПоКурсуВалютыНач;
	ИначеЕсли (ТипЗн=Тип("Дата")) ИЛИ (ТипЗн=Тип("МоментВремени")) ИЛИ (ТипЗн=Тип("Граница")) Тогда 
		стКурс=РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ПоКурсуВалютыНач,Новый Структура("Валюта",ВалютаНач));
		Попытка
			КурсВалютыНач=стКурс.Курс/?(стКурс.Кратность=0,1,стКурс.Кратность);
		Исключение
			КурсВалютыНач=0;
		КонецПопытки;
	Иначе 
		Сообщить("Неверный тип параметра при пересчете валюты!(1)");
		Возврат ЧислСумма;
	КонецЕсли;

	ТипЗн=ТипЗнч(ПоКурсуВалютыКон);
	Если ТипЗн=Тип("Число") Тогда КурсВалютыКон=ПоКурсуВалютыКон;
	ИначеЕсли (ТипЗн=Тип("Дата")) ИЛИ (ТипЗн=Тип("МоментВремени")) ИЛИ (ТипЗн=Тип("Граница")) Тогда 
		стКурс=РегистрыСведений.КурсыВалют.ПолучитьПоследнее(ПоКурсуВалютыКон,Новый Структура("Валюта",ВалютаКон));
		Попытка
			КурсВалютыКон=стКурс.Курс/?(стКурс.Кратность=0,1,стКурс.Кратность);
		Исключение
			КурсВалютыКон=0;
		КонецПопытки;
	Иначе
		Сообщить("Неверный тип параметра при пересчете валюты!(2)");
		Возврат ЧислСумма;
	КонецЕсли;

	Если (КурсВалютыНач*КурсВалютыКон)=0 Тогда
		Сообщить("При пересчете валюты обнаружен нулевой курс валюты."
		+СокрЛП(?(КурсВалютыНач=0,ВалютаНач,ВалютаКон)));
		Возврат ЧислСумма;
	КонецЕсли;
	Если КурсВалютыКон=0 Тогда
		Возврат 0;
	Иначе
		Если КурсВалютыНач<>КурсВалютыКон Тогда
			ЧислоРезультат=ЧислСумма*КурсВалютыНач/КурсВалютыКон;
			Если РежимОкр<>Неопределено Тогда
				ЧислоРезультат=Окр(ЧислоРезультат,2,РежимОкр);
			КонецЕсли; 
			Возврат ЧислоРезультат;
		КонецЕсли;
	КонецЕсли; 

	Возврат ЧислСумма;	
КонецФункции	// обПересчет

// Функция проверяет является ли значение указанного типа
//
Функция обЭтотТип(Значение, Тип) Экспорт
	Если ТипЗнч(Тип) = Тип("Строка") Тогда
		Возврат (ТипЗнч(Значение) = Тип(Тип));
	Иначе
		Возврат (ТипЗнч(Значение) = Тип);
	КонецЕсли;
КонецФункции

// функция создает построитель отчета для отбора печатных форм
Функция обИнициализироватьПостроительПечатныхФорм(ИмяТаблицы, СинонимТаблицы) Экспорт
	Построитель=Новый ПостроительОтчета;
	
	Построитель.Текст=
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Объект.Ссылка КАК Ссылка
	|ИЗ
	|	" + ИмяТаблицы + " КАК Объект
	|ГДЕ
	|	Объект.Ссылка = &Ссылка
	|{ГДЕ
	|	Объект.Ссылка.*}";
	
	ПолеОбъекта=Построитель.ДоступныеПоля.Найти("Ссылка");
	ПолеОбъекта.Представление = ?(НЕ ЗначениеЗаполнено(СинонимТаблицы), ИмяТаблицы, СинонимТаблицы);
	
	Возврат Построитель;
КонецФункции

#Если Клиент Тогда

// Возвращает картинку, соответствующую представлению типу, переданному в функцию
// 
// Параметры:
//  Тип - Строка - Представление типа
//
// Возвращаемое значение:
//  Картинка - Картинка, соответствующая переданному типу
//
Функция обВернутьСтандартнуюКартинку(Тип) Экспорт
	
	Если Тип = "Справочник" Тогда
		Возврат БиблиотекаКартинок.СправочникОбъект;
	ИначеЕсли Тип = "Справочники" ИЛИ Тип="СправочникОбъект" Тогда
		Возврат БиблиотекаКартинок.Справочник;
	ИначеЕсли Тип = "Документ" ИЛИ Тип="ДокументОбъект" Тогда
		Возврат БиблиотекаКартинок.ДокументОбъект;
	ИначеЕсли Тип = "Документы" Тогда
		Возврат БиблиотекаКартинок.Документ;
	ИначеЕсли Тип = "ЖурналыДокументов" Или Тип = "ЖурналДокументов" Тогда
		Возврат БиблиотекаКартинок.ЖурналДокументов;
	ИначеЕсли Тип = "Отчеты" Или Тип = "Отчет" Тогда
		Возврат БиблиотекаКартинок.Отчет;
	ИначеЕсли Тип = "Обработки" Или Тип = "Обработка" Тогда
		Возврат БиблиотекаКартинок.Обработка;
	ИначеЕсли Тип = "ПланыВидовХарактеристик" Тогда
		Возврат БиблиотекаКартинок.ПланВидовХарактеристик;
	ИначеЕсли Тип = "ПланВидовХарактеристик" Тогда
		Возврат БиблиотекаКартинок.ПланВидовХарактеристикОбъект;
	ИначеЕсли Тип = "ПланыОбмена" Тогда
		Возврат БиблиотекаКартинок.ПланОбмена;
	ИначеЕсли Тип = "ПланОбмена" Тогда
		Возврат БиблиотекаКартинок.ПланОбменаОбъект;
	ИначеЕсли Тип = "ПланыСчетов" Тогда
		Возврат БиблиотекаКартинок.ПланСчетов;
	ИначеЕсли Тип = "ПланСчетов" Тогда
		Возврат БиблиотекаКартинок.ПланСчетовОбъект;
	ИначеЕсли Тип = "ПланыВидовРасчета" Тогда
		Возврат БиблиотекаКартинок.ПланВидовРасчета;
	ИначеЕсли Тип = "ПланВидовРасчета" Тогда
		Возврат БиблиотекаКартинок.ПланВидовРасчетаОбъект;
	ИначеЕсли Тип = "РегистрыСведений" Тогда
		Возврат БиблиотекаКартинок.РегистрСведений;
	ИначеЕсли Тип = "РегистрСведений" Тогда
		Возврат БиблиотекаКартинок.РегистрСведенийЗапись;
	ИначеЕсли Тип = "РегистрыНакопления" Или Тип = "РегистрНакопления" Тогда
		Возврат БиблиотекаКартинок.РегистрНакопления;
	ИначеЕсли Тип = "РегистрыБухгалтерии" Или Тип = "РегистрБухгалтерии " Тогда
		Возврат БиблиотекаКартинок.РегистрБухгалтерии;
	ИначеЕсли Тип = "РегистрыРасчета" Или Тип = "РегистрРасчета" Тогда
		Возврат БиблиотекаКартинок.РегистрРасчета;
	ИначеЕсли Тип = "БизнесПроцессы" Тогда
		Возврат БиблиотекаКартинок.БизнесПроцесс;
	ИначеЕсли Тип = "БизнесПроцесс" Или Тип = "Бизнес-процесс" Тогда
		Возврат БиблиотекаКартинок.БизнесПроцессОбъект;
	ИначеЕсли Тип = "Константы" ИЛИ Тип = "Константа" Тогда
		Возврат БиблиотекаКартинок.Константа;
	ИначеЕсли Тип = "Задачи" Тогда
		Возврат БиблиотекаКартинок.Задача;
	ИначеЕсли Тип = "Задача" Тогда
		Возврат БиблиотекаКартинок.ЗадачаОбъект;
	ИначеЕсли Тип = "Папка" Тогда
		Возврат БиблиотекаКартинок.Папка;
	ИначеЕсли Тип = "Избранное" Тогда
		Возврат БиблиотекаКартинок.ДобавитьВИзбранное;
	ИначеЕсли Тип = "ТабличныйДокумент" Тогда
		Возврат БиблиотекаКартинок.ТабличныйДокумент;	
	Иначе
		Возврат БиблиотекаКартинок.Предупреждение;
	КонецЕсли;
	
КонецФункции // обВернутьСтандартнуюКартинку()

#КонецЕсли

// Проверка наличия переданной строки в ТЧ документа
// Проверка осуществляется через попытку обращения к реквизиту строки.
// Если строки нет - произойдет ошибка, по которой и принимается решение об ее отсутствии.
// Это обход ошибки 1С. При попытке получения индекса удаленной строки возвращается 
// значение отличное от -1.
//
// Параметры:
//	СтрокаТЧ – ДокументТабличнаяЧастьСтрока – Строка табличной части документа
//
// Возвращаемое значение:
//	Булево – Истина, если строка ТЧ существует
//
Функция обДопустимаяСтрока(СтрокаТЧ) Экспорт
	Попытка
		НомерСтроки=СтрокаТЧ.НомерСтроки;
	Исключение
		Возврат Ложь;
	КонецПопытки; 
	Возврат Истина;
КонецФункции // обДопустимаяСтрока()

// Функция определяет пол человека по его имени 
//
// Параметры:
//   Имя  – Строка – Имя, по последней букве которого пытаемся определить пол
//
// Возвращаемое значение:
//   ПеречислениеСсылка.ПолФизическихЛиц – пол человека, определенный по его имени
//
Функция обОпределитьПол(Имя) Экспорт
	
	СписокМужскихИсключений = Новый СписокЗначений;
	СписокМужскихИсключений.Добавить("ИЛЬЯ");
	СписокМужскихИсключений.Добавить("НИКОЛА");
	СписокМужскихИсключений.Добавить("САВВА");
	СписокМужскихИсключений.Добавить("КУЗЬМА");

	СписокЖенскихИсключений = Новый СписокЗначений;
	СписокЖенскихИсключений.Добавить("ЛЮБОВЬ");
	
	Окончание = ВРег(Прав(СокрП(Имя),1));               
	Если (Найти("АЯ",Окончание) и СписокМужскихИсключений.НайтиПоЗначению(ВРег(Имя)) = Неопределено) Или
		 СписокЖенскихИсключений.НайтиПоЗначению(ВРег(Имя)) <> Неопределено	Тогда // Вероятно женщина
		Пол = Перечисления.ПолФизическихЛиц.Женский;
	Иначе 	
		Пол = Перечисления.ПолФизическихЛиц.Мужской;
	КонецЕсли; 
	Возврат Пол;

КонецФункции // обОпределитьПол()

// Функция возвращает значение свойства для переданного объекта
//
// Параметры:
//	Объект   			- ДокументСсылка, СправочникСсылка 	- Ссылка на документ или справочник,
//						для которого получается значение свойства
//  Свойство 			- Строка 							- Свойство, значение которого необходимо получить
// 	ЗначениеПоУмолчанию - Неопределено 						- Значение по умолчанию, которое возвращает функция,
//						если значения свойства или свойства не существует
//
// Возвращаемое значение:
//	Неопределено - Значение свойства для данного объекта или переданное значение по умолчанию
//
Функция обПолучитьЗначениеСвойства(Объект,Свойство,ЗначениеПоУмолчанию=Неопределено) Экспорт
	Если ОбЗначениеНеЗаполнено(Объект) ИЛИ ОбЗначениеНеЗаполнено(Свойство) Тогда Возврат ЗначениеПоУмолчанию КонецЕсли;
	Попытка
		ОбъектСсылка = Объект.Ссылка
	Исключение
		Возврат ЗначениеПоУмолчанию	
	КонецПопытки;
	
	// Найдем ссылку на переданное свойство
	
	ТипЗначения=ТипЗнч(Свойство);
	Если ТипЗначения=Тип("ПланВидовХарактеристикСсылка.СвойстваОбъектов") Тогда
		СвойствоСсылка = Свойство 
	ИначеЕсли ТипЗначения=Тип("Строка") Тогда
		// Поиск предопределенного или по наименованию
		Попытка		СвойствоСсылка = ПланыВидовХарактеристик.СвойстваОбъектов[СокрЛП(Свойство)];
		Исключение	СвойствоСсылка = ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоНаименованию(СокрЛП(Свойство),Истина);
		КонецПопытки; 
	ИначеЕсли ТипЗначения=Тип("Число") Тогда
		// Поиск по коду
		СвойствоСсылка = ПланыВидовХарактеристик.СвойстваОбъектов.НайтиПоКоду(Свойство);
	Иначе СвойствоСсылка = ПланыВидовХарактеристик.СвойстваОбъектов.ПустаяСсылка()
	КонецЕсли;
	Если СвойствоСсылка.Пустая() Тогда Возврат ЗначениеПоУмолчанию КонецЕсли;
	
	// Если свойство найдено, осталось только получить его значение
	СтруктураОтбора = Новый Структура("Объект,Свойство",ОбъектСсылка,СвойствоСсылка);
	ЗначениеСвойства = РегистрыСведений.ЗначенияСвойствОбъектов.Получить(СтруктураОтбора).Значение;
	ВозвратЗначениеПоУмолчанию = ?(ЗначениеПоУмолчанию = Неопределено,обПустоеЗначениеТипа(СвойствоСсылка.ТипЗначения.Типы()[0]),ЗначениеПоУмолчанию);
	
	Возврат ?(ЗначениеСвойства = Неопределено,ВозвратЗначениеПоУмолчанию,ЗначениеСвойства);
КонецФункции // обПолучитьЗначениеСвойства()

// функция формирования КПП по ИНН
//
// Параметры:
//	ИНН	- Строка - ИНН
//
// Возвращаемое значение:
//	Строка - КПП
//
Функция обСформироватьКППпоИНН(ИНН) Экспорт
	//Если КПП формируется стандартным образом по ИНН, то для КПП берутся 
	//первые 4 цифры ИНН + 01001, например:
	//ИНН 7712563009
	//КПП 771201001
	
	// если не указано ИНН или заполнено КПП то прерываем выполнение операции
	Если (СтрДлина(ИНН) < 4) Тогда
		Возврат "";
	КонецЕсли;
	
	ПервыеСимволыИНН = Лев(ИНН, 4);
	НовоеЗначениеКПП = ПервыеСимволыИНН + "01001";
	
	Возврат НовоеЗначениеКПП;
	
КонецФункции // обСформироватьКППпоИНН()

// Процедура формирует таблицу со всеми документами, в которых присутствует заданный контрагент.
//
// Параметры:
//  Ограничения – "Структура" - ограничения на формируемую таблицу.
//
// Возвращаемое значение:
//   ТаблицаЗначений - таблица с документами.
// 
Функция обПолучитьТаблицуДокументовКритерияОтбора(Ограничения=Неопределено) Экспорт
	Если Ограничения=Неопределено Тогда
		Ограничения = Новый Структура;
		Ограничения.Вставить("Контрагент", Справочники.Контрагенты.ПустаяСсылка());
	КонецЕсли;
	
	Запрос = Новый Запрос;
	СтруктураИсключений = Новый Структура("Контрагент,ВидДокументов,ДатаНачала,ДатаОкончания");
	МассивВидовДокументов = Неопределено;
	ДатаНачала            = Неопределено;
	ДатаОкончания         = Неопределено;
	
	Ограничения.Свойство("ВидДокументов",   МассивВидовДокументов);
	Ограничения.Свойство("ДатаНачала",      ДатаНачала);
	Ограничения.Свойство("ДатаОкончания",   ДатаОкончания);

	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	КритерийОтбораКонтрагенты.Документ КАК Документ,
	|	КритерийОтбораКонтрагенты.Дата КАК Дата,
	|	КритерийОтбораКонтрагенты.ХозОперация КАК ХозОперация,
	|	КритерийОтбораКонтрагенты.СуммаДокумента КАК СуммаДокумента,
	|	КритерийОтбораКонтрагенты.ВалютаДокумента КАК ВалютаДокумента,
	|	КритерийОтбораКонтрагенты.ДанныеКартинки КАК ДанныеКартинки
	|ИЗ (
	|		ВЫБРАТЬ
	|			Контрагенты.Ссылка КАК Документ,
	|			Контрагенты.Ссылка.Дата КАК Дата,
	|			Контрагенты.Ссылка.ХозОперация КАК ХозОперация,
	|			Контрагенты.Ссылка.СуммаДокумента КАК СуммаДокумента,
	|			Контрагенты.Ссылка.ВалютаДокумента КАК ВалютаДокумента,
	|			ВЫБОР
	|				КОГДА Контрагенты.Ссылка.ПометкаУдаления
	|					ТОГДА 3
	|				ИНАЧЕ ВЫБОР
	|						КОГДА Контрагенты.Ссылка.Проведен
	|							ТОГДА 1
	|						ИНАЧЕ 0
	|				КОНЕЦ
	|			КОНЕЦ КАК ДанныеКартинки
	|		ИЗ
	|			КритерийОтбора.Контрагенты(&Контрагент) КАК Контрагенты
	|";
	
	ТекстУсловий = "";
	// Отбор по интервалу времени
	Если ДатаНачала<>Неопределено Тогда
		ТекстУсловий = ТекстУсловий + ?(ТекстУсловий="", "ГДЕ ", " И ") + "Контрагенты.Ссылка.Дата>=&ДатаНачала";	
	КонецЕсли;
	
	Если ДатаОкончания<>Неопределено Тогда
		ТекстУсловий = ТекстУсловий + ?(ТекстУсловий="", "ГДЕ ", " И ") + " Контрагенты.Ссылка.Дата<=&ДатаОкончания";
	КонецЕсли;
	
	Если НЕ обЗначениеНеЗаполнено(Ограничения) Тогда
		// отбор по значению ограничений
		Для Каждого Ограничение Из Ограничения Цикл
			Если СтруктураИсключений.Свойство(Ограничение.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			Если НЕ обЗначениеНеЗаполнено(Ограничение.Значение) Тогда
				ТекстУсловий = ТекстУсловий + ?(ПустаяСтрока(ТекстУсловий), "ГДЕ ", " И ") + "Контрагенты.Ссылка."+Ограничение.Ключ+"=&"+Ограничение.Ключ;
				Запрос.УстановитьПараметр(Ограничение.Ключ,Ограничение.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Отбор по виду документов
	Если (МассивВидовДокументов<>Неопределено) И (МассивВидовДокументов.Количество()<>0) Тогда
		ТекстУсловий = ТекстУсловий + ?(ТекстУсловий="", "ГДЕ (", " И (");
		
		Для Сч=0 По (МассивВидовДокументов.Количество()-1) Цикл  	
			Если Сч<>0 Тогда
				ТекстУсловий = ТекстУсловий + " ИЛИ ";	
			КонецЕсли;
			ТекстУсловий = ТекстУсловий + "Контрагенты.Ссылка ССЫЛКА Документ." + МассивВидовДокументов[Сч];		
		КонецЦикла;	
		
		ТекстУсловий = ТекстУсловий + ")";
	КонецЕсли;
	  	
	ТекстЗапроса = ТекстЗапроса + ТекстУсловий;
	
	ТекстЗапроса = ТекстЗапроса + "
	|) КАК КритерийОтбораКонтрагенты
	|УПОРЯДОЧИТЬ ПО
	|	Дата";
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Контрагент",      Ограничения.Контрагент);
	Запрос.УстановитьПараметр("ДатаНачала",      ДатаНачала); 	
	Запрос.УстановитьПараметр("ДатаОкончания",   ДатаОкончания);
	
	Возврат Запрос.Выполнить().Выгрузить();	
КонецФункции // ЗаполнитьТаблицуДокументами() 

#Если Клиент Тогда

// Процедура открывает обработку фронт кассира, определенную для текущего пользователя
Процедура обОткрытьФронтКассира() Экспорт
	
	// Получим права текущего пользователя
	Права = обПолучитьПраваИНастройкиПользователя(ПараметрыСеанса.Пользователь);

	// Получим форму фронта кассира по умолчанию
	ФормаФронтаПоУмолчанию = обПраво("ФронтРабочегоМеста", Права);
	
	Если ФормаФронтаПоУмолчанию = Перечисления.ТипыФормФронта.ФормаБезКнопок Тогда
		Форма = Обработки.ФронтКассира.ПолучитьФорму("ФормаБезКнопок");		
	ИначеЕсли ФормаФронтаПоУмолчанию = Перечисления.ТипыФормФронта.ФормаМенеджера Тогда
    	Форма = Обработки.ФронтКассира.ПолучитьФорму("ФормаМенеджера");
	Иначе	
		Форма = Обработки.ФронтКассира.ПолучитьФорму();
	КонецЕсли;
	
	// открываем форму модально, но прежде следует проверить не открыта ли она.
	Если Форма.Открыта() Тогда
		Форма.Активизировать();
	Иначе
		Форма.ОткрытьМодально();
	КонецЕсли;
	
	// Закрываем предприятие, если дальнейшая работа с системой запрещена
	Если обПраво("РаботаСФронтомКассира")=Перечисления.РаботаСФронтомКассира.ТолькоСФронтом Тогда
		ЗавершитьРаботуСистемы(ЛОЖЬ);
	КонецЕсли;
	
КонецПроцедуры  // обОткрытьФронтКассира()

#КонецЕсли

// функция обращается к внешнему серверу и получает обратно ip
Функция обПолучитьВнешнийIpАдрес() Экспорт
	SSL = Новый ЗащищенноеСоединениеOpenSSL();
	Попытка
		ОпределениеСервиса = Новый WSОпределения("http://rarus.ru/api/ip.wsdl",,,,,SSL);
		ПроксиСайта = Новый WSПрокси(ОпределениеСервиса, "urn:IP", "IPService", "IPExchangePort",,,SSL);
		ip = ПроксиСайта.getYourIP();
		Возврат ip;
	Исключение
		Возврат "";
	КонецПопытки;
КонецФункции

#Область ДанныеВБазе

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция обЗначенияРеквизитовОбъекта(Ссылка, Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		
		СтруктураРеквизитов = Новый Структура(Реквизиты);
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Структура")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		
		СтруктураРеквизитов = Реквизиты;
		
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив")
	      ИЛИ ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		
		СтруктураРеквизитов = Новый Структура;
		Для каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтрШаблон("Неверный тип второго параметра Реквизиты: %1", Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция обЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = обЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

// Возвращает значения реквизитов, прочитанные из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  Ссылки - Массив
//         - ФиксированныйМассив - ссылки на объекты.
//                    Если массив пуст, то результатом будет пустое соответствие.
//  Реквизиты - Строка - имена реквизитов перечисленные через запятую, в формате требований к свойствам
//                       структуры. Например, "Код, Наименование, Родитель".
//            - Массив
//            - ФиксированныйМассив - имена реквизитов в формате требований
//                       к свойствам структуры.
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - список объектов и значений их реквизитов:
//   * Ключ - ЛюбаяСсылка - ссылка на объект;
//   * Значение - Структура:
//    ** Ключ - Строка - имя реквизита;
//    ** Значение - Произвольный - значение реквизита.
// 
Функция обЗначенияРеквизитовОбъектов(Ссылки, Знач Реквизиты, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Реквизиты = СтрСоединить(Реквизиты, ",");
	КонецЕсли;
	
	Если ПустаяСтрока(Реквизиты) Тогда 
		ВызватьИсключение 
			НСтр("ru = 'Неверный второй параметр Реквизиты в функции ОбщегоНазначения.ЗначенияРеквизитовОбъектов: 
			           |- Поле объекта должно быть указано'");
	КонецЕсли;
	
	Если СтрНайти(Реквизиты, ".") <> 0 Тогда 
		ВызватьИсключение 
			НСтр("ru = 'Неверный второй параметр Реквизиты в функции ОбщегоНазначения.ЗначенияРеквизитовОбъектов: 
			           |- Обращение через точку не поддерживается'");
	КонецЕсли;
	
	ЗначенияРеквизитов = Новый Соответствие;
	Если Ссылки.Количество() = 0 Тогда
		Возврат ЗначенияРеквизитов;
	КонецЕсли;
	
	РеквизитыТекстЗапроса = Реквизиты;
	
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого Ссылка Из Ссылки Цикл
		Тип = ТипЗнч(Ссылка);
		Если СсылкиПоТипам[Тип] = Неопределено Тогда
			СсылкиПоТипам[Тип] = Новый Массив;
		КонецЕсли;
		ЭлементПоТипу = СсылкиПоТипам[Тип]; // Массив
		ЭлементПоТипу.Добавить(Ссылка);
	КонецЦикла;
	
	ТекстыЗапросов = Новый Массив;
	ПараметрыЗапроса = Новый Структура;
	
	ИменаОбъектовМетаданных = Новый Массив;
	
	Для Каждого СсылкиПоТипу Из СсылкиПоТипам Цикл
		Тип = СсылкиПоТипу.Ключ;
		ОбъектМетаданных = Метаданные.НайтиПоТипу(Тип);
		Если ОбъектМетаданных = Неопределено Тогда
			ВызватьИсключение 
				НСтр("ru = 'Неверный первый параметр Ссылки в функции ОбщегоНазначения.ЗначенияРеквизитовОбъектов: 
				           |- Значения массива должны быть ссылками'");
		КонецЕсли;
		
		ПолноеИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
		ИменаОбъектовМетаданных.Добавить(ПолноеИмяОбъектаМетаданных);
		
		ТекстЗапроса =
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ
			|	Ссылка,
			|	&Реквизиты
			|ИЗ
			|	&ПолноеИмяОбъектаМетаданных КАК ПсевдонимЗаданнойТаблицы
			|ГДЕ
			|	ПсевдонимЗаданнойТаблицы.Ссылка В (&Ссылки)";
		Если Не ВыбратьРазрешенные Или ТекстыЗапросов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ", ""); // @Query-part-1
		КонецЕсли;
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Реквизиты", РеквизитыТекстЗапроса);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", ПолноеИмяОбъектаМетаданных);
		ИмяПараметра = "Ссылки" + СтрЗаменить(ПолноеИмяОбъектаМетаданных, ".", "");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Ссылки", "&" + ИмяПараметра); // @Query-part-1
		ПараметрыЗапроса.Вставить(ИмяПараметра, СсылкиПоТипу.Значение);
				
		ТекстыЗапросов.Добавить(ТекстЗапроса);
		
	КонецЦикла;
	
	ТекстЗапроса = СтрСоединить(ТекстыЗапросов, Символы.ПС + "ОБЪЕДИНИТЬ ВСЕ" + Символы.ПС);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Для Каждого Параметр Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	Попытка
		Выборка = Запрос.Выполнить().Выбрать();
	Исключение
		
		// Удаление пробелов.
		Реквизиты = СтрЗаменить(Реквизиты, " ", "");
		// Преобразование параметра в массив полей.
		Реквизиты = СтрРазделить(Реквизиты, ",");
		
		// Поиск ошибки доступности полей.
		СписокОшибок = Новый Массив;
		Для Каждого ПолноеИмяОбъектаМетаданных Из ИменаОбъектовМетаданных Цикл
			Результат = НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, Реквизиты);
			Если Результат.Ошибка Тогда 
				СписокОшибок.Добавить(Результат.ОписаниеОшибки);
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(СписокОшибок) Тогда
			ВызватьИсключение СтрШаблон("Неверный второй параметр Реквизиты в функции ОбщегоНазначения.ЗначенияРеквизитовОбъектов: %1", 
				СтрСоединить(СписокОшибок, Символы.ПС));
		КонецЕсли;
		
		// Не удалось распознать ошибку, проброс первичной ошибки.
		ВызватьИсключение;
		
	КонецПопытки;
	
	Пока Выборка.Следующий() Цикл
		Результат = Новый Структура(Реквизиты);
		ЗаполнитьЗначенияСвойств(Результат, Выборка);
		ЗначенияРеквизитов[Выборка.Ссылка] = Результат;
		
	КонецЦикла;
	
	Возврат ЗначенияРеквизитов;
	
КонецФункции

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// Рекомендуется использовать вместо обращения к реквизитам объекта через точку от ссылки на объект
// для быстрого чтения отдельных реквизитов объекта из базы данных.
//
// Если необходимо зачитать реквизит независимо от прав текущего пользователя,
// то следует использовать предварительный переход в привилегированный режим.
//
// Параметры:
//  МассивСсылок       - Массив - массив ссылок на объекты.
//  ИмяРеквизита       - Строка - например, "Код".
//  ВыбратьРазрешенные - Булево - если Истина, то запрос к объектам выполняется с учетом прав пользователя;
//                                если какой-либо объект будет исключен из выборки по правам, то этот объект
//                                будет исключен и из результата;
//                                если Ложь, то возникнет исключение при отсутствии прав на таблицу
//                                или любой из реквизитов.
//
// Возвращаемое значение:
//  Соответствие из КлючИЗначение:
//      * Ключ     - ЛюбаяСсылка  - ссылка на объект,
//      * Значение - Произвольный - значение прочитанного реквизита.
// 
Функция обЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные = Ложь) Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда 
		ВызватьИсключение НСтр("ru = 'Неверный второй параметр ИмяРеквизита в функции ОбщегоНазначения.ЗначениеРеквизитаОбъектов: 
		                             |- Имя реквизита должно быть заполнено'");
	КонецЕсли;
	
	ЗначенияРеквизитов = обЗначенияРеквизитовОбъектов(МассивСсылок, ИмяРеквизита, ВыбратьРазрешенные);
	Для каждого Элемент Из ЗначенияРеквизитов Цикл
		ЗначенияРеквизитов[Элемент.Ключ] = Элемент.Значение[ИмяРеквизита];
	КонецЦикла;
		
	Возврат ЗначенияРеквизитов;
	
КонецФункции

#КонецОбласти

#Область ЗначенияРеквизитов

// Выполняет поиск проверяемых выражений среди реквизитов объекта метаданных.
// 
// Параметры:
//  ПолноеИмяОбъектаМетаданных - Строка - полное имя проверяемого объекта.
//  ПроверяемыеВыражения       - Массив - имена полей или проверяемые выражения объекта метаданных.
// 
// Возвращаемое значение:
//  Структура:
//   * Ошибка         - Булево - найдена ошибка.
//   * ОписаниеОшибки - Строка - описание найденных ошибок.
//
// Пример:
//  
// Реквизиты = Новый Массив;
// Реквизиты.Добавить("Номер");
// Реквизиты.Добавить("Валюта.НаименованиеПолное");
//
// Результат = ОбщегоНазначения.НайтиОшибкуДоступностиРеквизитовОбъекта("Документ._ДемоЗаказПокупателя", Реквизиты);
//
// Если Результат.Ошибка Тогда
//     ВызватьИсключение Результат.ОписаниеОшибки;
// КонецЕсли;
//
Функция НайтиОшибкуДоступностиРеквизитовОбъекта(ПолноеИмяОбъектаМетаданных, ПроверяемыеВыражения)
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	
	Если МетаданныеОбъекта = Неопределено Тогда 
		Возврат Новый Структура("Ошибка, ОписаниеОшибки", Истина, 
			СтрШаблон("Ошибка получения метаданных ""%1"""), ПолноеИмяОбъектаМетаданных);
	КонецЕсли;

	// Разрешение вызова из безопасного режима внешней обработки или расширения.
	// Информация о доступности полей источника схемы при проверке метаданных не является секретной.
	УстановитьОтключениеБезопасногоРежима(Истина);
	УстановитьПривилегированныйРежим(Истина);
	
	Схема = Новый СхемаЗапроса;
	Пакет = Схема.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = Пакет.Операторы.Получить(0);
	
	Источник = Оператор.Источники.Добавить(ПолноеИмяОбъектаМетаданных, "Таблица");
	ТекстОшибки = "";
	
	Для Каждого ТекущееВыражение Из ПроверяемыеВыражения Цикл
		
		Если Не ПолеИсточникаСхемыЗапросаДоступно(Источник, ТекущееВыражение) Тогда 
			ТекстОшибки = ТекстОшибки + Символы.ПС 
				+ СтрШаблон("Поле объекта ""%1"" не существует", ТекущееВыражение);
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат Новый Структура("Ошибка, ОписаниеОшибки", Не ПустаяСтрока(ТекстОшибки), ТекстОшибки);
	
КонецФункции 

// Используется в НайтиОшибкуДоступностиРеквизитовОбъекта.
// Выполняет проверку доступности поля проверяемого выражения в источнике оператора схемы запроса.
//
Функция ПолеИсточникаСхемыЗапросаДоступно(ИсточникОператора, ПроверяемоеВыражение)
	
	ЧастиИмениПоля = СтрРазделить(ПроверяемоеВыражение, ".");
	ДоступныеПоля = ИсточникОператора.Источник.ДоступныеПоля;
	
	ТекущаяЧастьИмениПоля = 0;
	Пока ТекущаяЧастьИмениПоля < ЧастиИмениПоля.Количество() Цикл 
		
		ТекущееПоле = ДоступныеПоля.Найти(ЧастиИмениПоля.Получить(ТекущаяЧастьИмениПоля)); 
		
		Если ТекущееПоле = Неопределено Тогда 
			Возврат Ложь;
		КонецЕсли;
		
		// Инкрементация следующей части имени поля и соответствующего списка доступности полей.
		ТекущаяЧастьИмениПоля = ТекущаяЧастьИмениПоля + 1;
		ДоступныеПоля = ТекущееПоле.Поля;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

// Получение значение из структуры, по полному пути к параметру
// 
// Параметры:
//  Структура           - Структура    - Структура, у которой нужно получить значение.
//  ПутьКПараметру      - Строка       - Полный путь к параметру, включая имя самого параметра.
//  ЗначениеПоУмолчанию - Произвольный - Значение, которое подставится если параметр отсутствует или пустой.
//
Функция обПолучитьЗначениеПараметраСтруктуры(Структура, ПутьКПараметру, ЗначениеПоУмолчанию=Неопределено) Экспорт
	
	МассивИменПараметров = СтрРазделить(ПутьКПараметру, ".", Ложь);
	
	ЭлементСтруктуры = Структура;
	
	Для каждого ИмяПараметра Из МассивИменПараметров Цикл
		
		ТипСтруктуры = ТипЗнч(ЭлементСтруктуры);
		
		Если ТипСтруктуры=Тип("Структура") ИЛИ ТипСтруктуры=Тип("ДанныеФормыСтруктура") ИЛИ ТипСтруктуры=Тип("ДанныеФормыЭлементКоллекции") ИЛИ ТипСтруктуры=Тип("ДанныеФормыЭлементДерева") Тогда
			// Проверка наличия свойства возможна
		Иначе
			Возврат ЗначениеПоУмолчанию;
		КонецЕсли;
		
		ЗначениеПараметра = Неопределено;
		ЭлементСтруктуры.Свойство(ИмяПараметра, ЗначениеПараметра);
		
		Если ЗначениеПараметра = Неопределено Тогда
			Возврат ЗначениеПоУмолчанию;
		КонецЕсли;		
		
		ЭлементСтруктуры = ЗначениеПараметра;
		
	КонецЦикла; 
	
	Возврат ЗначениеПараметра;		
	
КонецФункции

///////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ АВТОРИЗАЦИИ И РАБОТЫ С ПРАВАМИ ПОЛЬЗОВАТЕЛЕЙ

// Функция возвращает ссылку на элемент справочника "Пользователи",
// соответствующий текущему пользователю информационной базы.
// Вызывается при начале работы системы и может осуществлять первичное создание
// элемента пользователя, для вошедшего первый раз.
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	СправочникСсылка - элемент справочника "Пользователи"
//
Функция обОпределитьТекущегоПользователя() Экспорт

	Если ПустаяСтрока(ИмяПользователя()) Тогда
		ИмяПользователя           = "Администратор";
		ПолноеИмяПользователя     = "Администратор информационной базы";
	Иначе
		ИмяПользователя           = ИмяПользователя();
		Если ПустаяСтрока(ПолноеИмяПользователя()) Тогда
			ПолноеИмяПользователя = ИмяПользователя;
		Иначе
			ПолноеИмяПользователя = ПолноеИмяПользователя();
		КонецЕсли;
	КонецЕсли;
	
	// Попытаемся найти этого пользователя.
	Пользователь = Справочники.Пользователи.НайтиПоКоду(ИмяПользователя);
	Если обЗначениеНеЗаполнено(Пользователь) Тогда
		// Пользователь входит в систему первый раз
		#Если Клиент Тогда
			Предупреждение("Зарегистрирован первый вход в систему для пользователя 
					   |"""+ИмяПользователя + """", 5);
		#Иначе	
			Сообщить("Зарегистрирован первый вход в систему для пользователя "+ИмяПользователя,СтатусСообщения.Важное);
		#КонецЕсли
		ОбъектПользователь = Справочники.Пользователи.СоздатьЭлемент();
		ОбъектПользователь.Код           = ИмяПользователя;
		ОбъектПользователь.Наименование  = ПолноеИмяПользователя;
		ОбъектПользователь.Организация	 = Справочники.Организации.ОсновнаяОрганизация;
		ОбъектПользователь.Подразделение = Справочники.ПодразделенияКомпании.ОсновноеПодразделение;
		// Посмотрим на роли пользователя и постараемся подставить шаблон по доступным ролям (по старшинству)
		Для Каждого Роль Из Метаданные.Роли Цикл
			Если РольДоступна(Роль) Тогда
				// Нашли доступную роль, постараемся найти шаблон..
				Роль = Строка(Роль);
				// сначала ищем шаблон с подчеркиванием
				Шаблон = Справочники.Пользователи.НайтиПоКоду("_"+Роль);
				Если Шаблон.Пустая() Тогда						// не найден
				ИначеЕсли НЕ Шаблон.ШаблонПрав.Пустая() Тогда	// циклические ссылки шаблонов недопустимы
				Иначе											// подходит в качестве шаблона
					Сообщить("Использован шаблон прав пользователя "+Шаблон.Код,СтатусСообщения.Информация);
					ОбъектПользователь.ШаблонПрав = Шаблон;
					Прервать;
				КонецЕсли;
				// если не нашли, ищем по роли без подчеркивания
				Шаблон = Справочники.Пользователи.НайтиПоКоду(Роль);
				Если Шаблон.Пустая() Тогда						// не найден
				ИначеЕсли НЕ Шаблон.ШаблонПрав.Пустая() Тогда	// циклические ссылки шаблонов недопустимы
				Иначе											// подходит в качестве шаблона
					Сообщить("Использован шаблон прав пользователя "+Шаблон.Код,СтатусСообщения.Информация);
					ОбъектПользователь.ШаблонПрав = Шаблон;
					Прервать;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		ОбъектПользователь.ОбменДанными.Загрузка = Истина;
		ОбъектПользователь.Записать();
		Пользователь = ОбъектПользователь.Ссылка;
	КонецЕсли;

	Возврат Пользователь;
КонецФункции // обОпределитьТекущегоПользователя()

// Преобразование имени права в ссылку на ПВХ
// Так же поддерживается идентификация по коду ПВХ
//
// Параметры:
//	Право – Строка, Число, ссылка на ПВХ ПраваИНастройки – Имя или ссылка права
//
// Возвращаемое значение:
//	Ссылка - ссылка на ПВХ ПраваИНастройки или Неопределено для недопустимого имени ПВХ
//
Функция обПолучитьСсылкуПВХПравИНастроек(Право) Экспорт
	ТипЗначения=ТипЗнч(Право);
	
	Если ТипЗначения=Тип("ПланВидовХарактеристикСсылка.ПраваИНастройки") Тогда
		//Если право уже является ссылкой - вернем ее
		Возврат Право;
		
	ИначеЕсли ТипЗначения=Тип("Строка") Тогда
		// Если право задано в виде имени - преобразуем его в ссылку на ПВХ
		// Если такого предопределенного элемента нет. Попробуем найти добавленный по наименованию
		Попытка		Возврат ПланыВидовХарактеристик.ПраваИНастройки[СокрЛП(Право)];
		Исключение	Возврат ПланыВидовХарактеристик.ПраваИНастройки.НайтиПоНаименованию(СокрЛП(Право),Истина);
		КонецПопытки; 
		
	ИначеЕсли ТипЗначения=Тип("Число") Тогда
		// Возможно, хотя и не рекомендуется использовать поиск по коду ПВХ
		Возврат ПланыВидовХарактеристик.ПраваИНастройки.НайтиПоКоду(Право);
		
	Иначе Возврат ПланыВидовХарактеристик.ПраваИНастройки.ПустаяСсылка();
		
	КонецЕсли;
КонецФункции // обПолучитьСсылкуПВХПравИНастроек()

// Получить значение права по имени или значению
//
// Параметры:
//	Право 			- Строка	- Строка с именем или ссылка на ПВХ ПраваИНастройки искомого права
//	ЗначенияПрав 	- Соответствие	- Список прав (типа соответствие), в котором надо произвести поиск
//					значения конкретного права (в этот параметр обычно будет передаваться глобальная 
//					переменная "глПрава", в которой кэшируются права пользователя)
//	ОбъектДанных	- ДокументОбъект, ДокументСсылка, СправочникОбъект, СправочникСсылка. Объект, для которого 
//					получается расширение прав доступа
//
// Возвращаемое значение:
//	Ссылка - Значение запрошенного права 
//
Функция обПраво(Право, ЗначенияПрав=Неопределено, ВыводитьОшибки=Истина, ОбъектДанных=Неопределено) Экспорт

	Результат = НЕОПРЕДЕЛЕНО;
	
	#Если Клиент Тогда
		Если ЗначенияПрав = Неопределено Тогда
			ЗначенияПрав = Обработки.Защита.Создать().Права;
		КонецЕсли; 
	#КонецЕсли
	
	Если НЕ (ЗначенияПрав = Неопределено) Тогда
		// Если это дополнительное право доступа справочников или документов
		Если (ТипЗнч(Право)=Тип("Строка")) 
			И (Найти(Право,"Значения Право доступа")>0 ИЛИ Найти(Право,"Значения Утверждение") > 0)  Тогда
			Возврат ЗначенияПрав[Право];
		КонецЕсли;
		// кеш с правами передан, попытаемся получить нужное право из него напрямую.
		ПравоСсылка=обПолучитьСсылкуПВХПравИНастроек(Право);
		Если обЗначениеНеЗаполнено(ПравоСсылка) Тогда
			Если ВыводитьОшибки Тогда
				// Такого права нет в системе - явная ошибка. Нужен специалист
				Сообщить("Неизвестное право: "+Право,СтатусСообщения.Важное);
			КонецЕсли;
		Иначе
			Если ОбъектДанных<>Неопределено Тогда
				Попытка
					ОбъектДанныхИмя=ОбъектДанных.Метаданные().Имя;
					ПравоНаименование=ПравоСсылка.Наименование+" "+ОбъектДанныхИмя;
					Если ПравоНаименование<>Неопределено Тогда
						ЗначениеПрава=ЗначенияПрав.Получить(ПравоНаименование);
						Если ЗначениеПрава<>Неопределено Тогда
							Возврат ЗначениеПрава;
						КонецЕсли;  
					КонецЕсли; 
				Исключение
				КонецПопытки; 
			КонецЕсли; 
			Результат = ЗначенияПрав[ПравоСсылка];
		КонецЕсли;
	Иначе
		// Кэш прав не передан (вероятно мы на сервере), значит придется запрашивать данные из БД
		// Момент тонкий - чтобы не писать разные функции получения прав в кэш
		// и точечного получения, вызовем стандартную функцию с фильтром по праву.
		Пользователь = ПараметрыСеанса.Пользователь;
		// Если это дополнительное право доступа справочников или документов
		Если (ТипЗнч(Право)=Тип("Строка")) И Найти(Право,"Значения Право доступа")>0 Тогда
			ПравоСсылка=обПолучитьСсылкуПВХПравИНастроек(Сред(Право,СтрДлина("Значения ")+1));
			Текст="ВЫБРАТЬ
			|	ДоступКСправочникам.Право КАК Право,
			|	ДоступКСправочникам.Объект КАК Объект,
			|	ДоступКСправочникам.ДоступЕсть КАК ДоступЕсть
			|ИЗ
			|	РегистрСведений.ДоступКСправочникам КАК ДоступКСправочникам
			|ГДЕ
			|	ДоступКСправочникам.Пользователь = &Пользователь
			|	И ДоступКСправочникам.ДоступЕсть = ИСТИНА
			|	И ДоступКСправочникам.Право = &ПравоСсылка
			|
			|ОБЪЕДИНИТЬ ВСЕ
			|
			|ВЫБРАТЬ
			|	ДоступКДокументам.Право,
			|	ДоступКДокументам.Объект,
			|	ДоступКДокументам.ДоступЕсть
			|ИЗ
			|	РегистрСведений.ДоступКДокументам КАК ДоступКДокументам
			|ГДЕ
			|	ДоступКДокументам.Пользователь = &Пользователь
			|	И ДоступКДокументам.ДоступЕсть = ИСТИНА
			|	И ДоступКДокументам.Право = &ПравоСсылка
			|";
			Запрос=Новый Запрос(Текст);
			Запрос.УстановитьПараметр("ПравоСсылка", ПравоСсылка);
			Запрос.УстановитьПараметр("Пользователь", Пользователь);
			РезультатПраво=Запрос.Выполнить().Выбрать();
			// Перебор полученных значений и формирование соответствия прав
			Результат = Новый Соответствие;
			Пока РезультатПраво.Следующий() Цикл
				Результат.Вставить(РезультатПраво.Объект, РезультатПраво.ДоступЕсть);
			КонецЦикла;
			Возврат Результат;
		Иначе
			// Получаем ссылку на ПВХ по ее имени
			ПравоСсылка=обПолучитьСсылкуПВХПравИНастроек(Право);
		КонецЕсли;
		Если обЗначениеНеЗаполнено(ПравоСсылка) Тогда
			// Такого права нет в системе - явная ошибка. Нужен специалист
			Сообщить("Неизвестное право: "+Право,СтатусСообщения.Важное);
		Иначе
			Результат = обПолучитьПраваИНастройкиПользователя(Пользователь, ПравоСсылка, ОбъектДанных);
		КонецЕсли;
	КонецЕсли;
	// 
	Возврат(Результат);
		
КонецФункции // обПраво()

// Получить значение права на утверждение по имени или значению
//
// Параметры:
//	Право 			- Строка	- Строка с именем или ссылка на ПВХ ПраваИНастройки искомого права
//	ЗначенияПрав 	- Соответствие	- Список прав (типа соответствие), в котором надо произвести поиск
//					значения конкретного права (в этот параметр обычно будет передаваться глобальная 
//					переменная "глПрава", в которой кэшируются права пользователя)
//
// Возвращаемое значение:
//	Ссылка - Значение запрошенного права 
//
Функция обУтверждение(ДокументОбъект) Экспорт
	
	Результат = НЕОПРЕДЕЛЕНО;
	Пользователь = ПараметрыСеанса.Пользователь;
	ВидДокумента = ДокументОбъект.Метаданные().Имя;
	ПравоПодразделение = "Значения Утверждение по пользователю " + ВидДокумента;
	ПравоПользователь = "Значения Утверждение по подразделению " + ВидДокумента;
	
	ТекПрава = ДокументОбъект.Права;
	СоответствиеПравПодразделение = ДокументОбъект.Права[ПравоПодразделение];
	СоответствиеПравПользователь  = ДокументОбъект.Права[ПравоПользователь];
	ПраваУтверждения = Новый Соответствие;
	ПраваУтверждения.Вставить(Перечисления.СтатусыДокументов.Подготовлен,
		СоответствиеПравПодразделение[Перечисления.СтатусыДокументов.Подготовлен] ИЛИ СоответствиеПравПользователь[Перечисления.СтатусыДокументов.Подготовлен]);
	ПраваУтверждения.Вставить(Перечисления.СтатусыДокументов.Согласован,
		СоответствиеПравПодразделение[Перечисления.СтатусыДокументов.Согласован] ИЛИ СоответствиеПравПользователь[Перечисления.СтатусыДокументов.Согласован]);
	ПраваУтверждения.Вставить(Перечисления.СтатусыДокументов.Утвержден,
		СоответствиеПравПодразделение[Перечисления.СтатусыДокументов.Утвержден] ИЛИ СоответствиеПравПользователь[Перечисления.СтатусыДокументов.Утвержден]);
	ПраваУтверждения.Вставить(Перечисления.СтатусыДокументов.Отклонен,
		СоответствиеПравПодразделение[Перечисления.СтатусыДокументов.Отклонен] ИЛИ СоответствиеПравПользователь[Перечисления.СтатусыДокументов.Отклонен]);
		
    Возврат ПраваУтверждения;
	
КонецФункции // обУтверждение()

//bz
// Получает текущие значение прав и настроек для пользователя
// из регистра ПраваИНастройки. Кроме пользователя так же может фигурировать
// подразделение, организация, компания (пустая ссылка)
//
// Параметры:
//	Объект 			- СправочникСсылка	- Ссылка на пользователя (или другой объект) для которого
//					необходимо собрать права
//	ТолькоЭтоПраво 	- Справочникссылка	- Ссылка на элемент ПВХ, если задан то накладывается фильтр
//					для получения значения только именно этого права, по умолчанию НЕОПРЕДЕЛЕНО (все права)
//	ОбъектДанных	- ДокументОбъект, ДокументСсылка, СправочникОбъект, СправочникСсылка. Объект, для которого 
//					получается расширение прав доступа
//
// Возвращаемое значение:
//	Структура - Соответствие (в ключе ссылка на элемент ПВХ, а в значении оно и есть), если параметр
//				ТолькоЭтоПраво был не задан (неопределен), иначе возвращается текущее значение
//				запрошенного права для группы прав доступа к справочникам и документам формируются
//				записи соответствия вида:
// 				Ключ: "Значения <Имя права>"
// 				Значение: Соответствие, где ключ - значение доступа, значение - флаг доступа
//
// Примеры использования:  
//   Получение всего набора прав пользователя:
//   	глПрава=обПолучитьПраваИНастройкиПользователя(ПараметрыСеанса.Пользователь);
//   Получение одного права:
//   	Если обПолучитьПраваИНастройкиПользователя(ПараметрыСеанса.Пользователь,"ПроведениеЗаднимЧислом") Тогда
//
Функция обПолучитьПраваИНастройкиПользователя(Объект,Знач ТолькоЭтоПраво=Неопределено,ОбъектДанных=Неопределено) Экспорт
	Результат = Новый Соответствие;
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ПланВидовХарактеристикПраваИНастройки.Ссылка,
	|	ПланВидовХарактеристикПраваИНастройки.ТипЗначения,
	|	ЕСТЬNULL(РегистрСведенийПраваИНастройки.Значение, ПланВидовХарактеристикПраваИНастройки.ЗначениеПоУмолчанию) КАК Значение
	|ИЗ
	|	ПланВидовХарактеристик.ПраваИНастройки КАК ПланВидовХарактеристикПраваИНастройки
	|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПраваИНастройки КАК РегистрСведенийПраваИНастройки
	|		ПО ПланВидовХарактеристикПраваИНастройки.Ссылка = РегистрСведенийПраваИНастройки.ПравоНастройка
	|			И (ПланВидовХарактеристикПраваИНастройки.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Пользователь)
	|//anton
	|					И НЕ ПланВидовХарактеристикПраваИНастройки.ПравоПользователя
	|					И РегистрСведенийПраваИНастройки.Объект = &Пользователь
	|				ИЛИ ПланВидовХарактеристикПраваИНастройки.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Пользователь)
	|					И ПланВидовХарактеристикПраваИНастройки.ПравоПользователя
	|					И РегистрСведенийПраваИНастройки.Объект = &ПользовательИБ
	|//anton
	|				ИЛИ ПланВидовХарактеристикПраваИНастройки.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Подразделение)
	|					И РегистрСведенийПраваИНастройки.Объект = &Подразделение
	|				ИЛИ ПланВидовХарактеристикПраваИНастройки.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Организация)
	|					И РегистрСведенийПраваИНастройки.Объект = &Организация
	|				ИЛИ ПланВидовХарактеристикПраваИНастройки.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Компания)
	|					И РегистрСведенийПраваИНастройки.Объект = НЕОПРЕДЕЛЕНО)
	|ГДЕ
	|	ПланВидовХарактеристикПраваИНастройки.ЭтоГруппа = ЛОЖЬ
	|	И ПланВидовХарактеристикПраваИНастройки.ПометкаУдаления = ЛОЖЬ

	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	РегистрСведенийРасширениеПравДоступа.Право.Наименование + "" "" + РегистрСведенийРасширениеПравДоступа.Объект,
	|	РегистрСведенийРасширениеПравДоступа.Право.ТипЗначения,
	|	РегистрСведенийРасширениеПравДоступа.Значение
	|ИЗ
	|	РегистрСведений.РасширениеПравДоступа КАК РегистрСведенийРасширениеПравДоступа
	|ГДЕ
	|	РегистрСведенийРасширениеПравДоступа.Право.ЭтоГруппа = ЛОЖЬ
	|	И РегистрСведенийРасширениеПравДоступа.Право.ПометкаУдаления = ЛОЖЬ
	|	И (РегистрСведенийРасширениеПравДоступа.Право.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Пользователь)
	|//anton
	|				И НЕ РегистрСведенийРасширениеПравДоступа.Право.ПравоПользователя
	|				И РегистрСведенийРасширениеПравДоступа.Пользователь = &Пользователь
	|			ИЛИ РегистрСведенийРасширениеПравДоступа.Право.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Пользователь)
	|				И РегистрСведенийРасширениеПравДоступа.Право.ПравоПользователя
	|				И РегистрСведенийРасширениеПравДоступа.Пользователь = &ПользовательИБ
	|//anton
	|			ИЛИ РегистрСведенийРасширениеПравДоступа.Право.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Подразделение)
	|				И РегистрСведенийРасширениеПравДоступа.Пользователь = &Подразделение
	|			ИЛИ РегистрСведенийРасширениеПравДоступа.Право.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Организация)
	|				И РегистрСведенийРасширениеПравДоступа.Пользователь = &Организация
	|			ИЛИ РегистрСведенийРасширениеПравДоступа.Право.Назначение = ЗНАЧЕНИЕ(Перечисление.НазначениеПравИНастроек.Компания)
	|				И РегистрСведенийРасширениеПравДоступа.Пользователь = НЕОПРЕДЕЛЕНО)";
	Если ТолькоЭтоПраво <> Неопределено Тогда
		//ТекстЗапроса = ТекстЗапроса + "
		//|	И ПланВидовХарактеристикПраваИНастройки.Ссылка = &Право";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"//ОТБОР ПО ПРАВУ ДЛЯ ПВХ","И ПланВидовХарактеристикПраваИНастройки.Ссылка = &Право");
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,"//ОТБОР ПО ПРАВУ ДЛЯ РАСШИРЕНИЯ","И РегистрСведенийРасширениеПравДоступа.Право = &Право");
		Если ТипЗнч(ТолькоЭтоПраво) <> Тип("ПланВидовХарактеристикСсылка.ПраваИНастройки") Тогда
			ТолькоЭтоПраво = обПолучитьСсылкуПВХПравИНастроек(ТолькоЭтоПраво);
		КонецЕсли;
		Запрос.УстановитьПараметр("Право",ТолькоЭтоПраво);
	КонецЕсли; 
	
	Запрос.Текст = ТекстЗапроса;
	Если ТипЗнч(Объект)=Тип("СправочникСсылка.Пользователи") Тогда
		Пользователь = ?(обЗначениеНеЗаполнено(Объект.ШаблонПрав),Объект,Объект.ШаблонПрав);
		Подразделение = Объект.Подразделение;
		Организация = Объект.Организация;
	ИначеЕсли ТипЗнч(Объект)=Тип("СправочникСсылка.Организации") Тогда
		Пользователь = Неопределено;
		Подразделение = Неопределено;
		Организация = Объект;
	ИначеЕсли ТипЗнч(Объект)=Тип("СправочникСсылка.ПодразделенияКомпании") Тогда
		Пользователь = Неопределено;
		Подразделение = Объект;
		Организация = Объект.Организация;
	КонецЕсли; 
	Запрос.УстановитьПараметр("Пользователь",Пользователь);
	Запрос.УстановитьПараметр("Подразделение",Подразделение);
	Запрос.УстановитьПараметр("Организация",Организация);
	//anton
	Запрос.УстановитьПараметр("ПользовательИБ",Объект);
	//anton
	
	Выборка = Запрос.Выполнить().Выбрать();
	//Перебор полученных значений и формирование соответствия прав
	Пока Выборка.Следующий() Цикл
		// Попробуем получить значение права в соответствии с назначением
		Значение=Выборка.Значение;
		// Если и по умолчанию ничего нет, то типизируем (на всякий случай)
		Если обЗначениеНеЗаполнено(Значение) Тогда
			Значение = Выборка.ТипЗначения.ПривестиЗначение(Неопределено);
		КонецЕсли;
		Результат.Вставить(Выборка.Ссылка,Значение);
	КонецЦикла;
	
	// Запрос для кэширования дополнительных настроек доступа справочников и документов
	// из регистров сведений ДоступКСправочникам и ДоступКДокументам
	Если  (ТолькоЭтоПраво = Неопределено) Тогда
		Если Пользователь<>Неопределено Тогда
			Текст="ВЫБРАТЬ
			      |	ДоступКСправочникам.Право КАК Право,
			      |	""Значения "" + ДоступКСправочникам.Право.Наименование КАК ПравоНаименование,
			      |	ДоступКСправочникам.Объект КАК Объект,
			      |	ДоступКСправочникам.ДоступЕсть КАК ДоступЕсть
			      |ИЗ
			      |	РегистрСведений.ДоступКСправочникам КАК ДоступКСправочникам
			      |ГДЕ
			      |	ДоступКСправочникам.Пользователь = &Пользователь
			      |	И ДоступКСправочникам.ДоступЕсть = ИСТИНА
			      |
			      |ОБЪЕДИНИТЬ ВСЕ
			      |
			      |ВЫБРАТЬ
			      |	ДоступКДокументам.Право,
			      |	""Значения "" + ДоступКДокументам.Право.Наименование,
			      |	ДоступКДокументам.Объект,
			      |	ДоступКДокументам.ДоступЕсть
			      |ИЗ
			      |	РегистрСведений.ДоступКДокументам КАК ДоступКДокументам
			      |ГДЕ
			      |	ДоступКДокументам.Пользователь = &Пользователь
			      |	И ДоступКДокументам.ДоступЕсть = ИСТИНА
			      |
			      |ИТОГИ
			      |	МАКСИМУМ(ДоступЕсть)
			      |ПО
			      |	Право,
			      |	Объект";
			Запрос.Текст=Текст;
			Запрос.УстановитьПараметр("Пользователь", Пользователь);
			
			РезультатПраво=Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			// Перебор полученных значений и формирование соответствия прав
			Пока РезультатПраво.Следующий() Цикл
				РезультатОбъект=РезультатПраво.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
				СОбъектыПрава = Новый Соответствие;
				Пока РезультатОбъект.Следующий() Цикл
					СОбъектыПрава.Вставить(РезультатОбъект.Объект, РезультатОбъект.ДоступЕсть);
				КонецЦикла;
				Результат.Вставить(РезультатПраво.ПравоНаименование,СОбъектыПрава);
			КонецЦикла;
			
			// Кэшируем права утверждения документов из Регистра сведений УтверждениеДокументов
			// по пользователю и подразделению
			Текст="ВЫБРАТЬ  РАЗЛИЧНЫЕ
			      |	УтверждениеДокументов.Право,
				  |	ВЫБОР КОГДА
				  |    УтверждениеДокументов.Право.Родитель = ЗНАЧЕНИЕ(ПланВидовХарактеристик.ПраваИНастройки.УтверждениеДокументовПодразделение)
				  |    ТОГДА ПОДСТРОКА(УтверждениеДокументов.Право.Наименование,30,100)
				  |    ИНАЧЕ ПОДСТРОКА(УтверждениеДокументов.Право.Наименование,29,100)
				  | КОНЕЦ КАК ВидДокумента,
			      |	""Значения "" + УтверждениеДокументов.Право.Наименование КАК ПравоНаименование,
				  |	УтверждениеДокументов.СтатусДокумента КАК СтатусДокумента,
			      |	УтверждениеДокументов.Объект,
			      |	УтверждениеДокументов.Использование
			      |ИЗ
			      |	РегистрСведений.УтверждениеДокументов КАК УтверждениеДокументов
			      |ГДЕ
			      |	УтверждениеДокументов.Объект = &Пользователь ИЛИ УтверждениеДокументов.Объект = &Подразделение
			      |	И УтверждениеДокументов.Использование = ИСТИНА
			      |
			      |ИТОГИ
			      |	МАКСИМУМ(Использование)
			      |ПО
				  |	ВидДокумента,
			      |	Право,
			      |	Объект";
			Запрос.Текст=Текст;
			Запрос.УстановитьПараметр("Пользователь", Пользователь);
			Запрос.УстановитьПараметр("Подразделение", Подразделение);
			
			РезультатВидДокумента =  Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока  РезультатВидДокумента.Следующий() Цикл
				ВидДокумента  = РезультатВидДокумента.ВидДокумента;
				РезультатПраво=РезультатВидДокумента.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
				// Перебор полученных значений и формирование соответствия прав
				Пока РезультатПраво.Следующий() Цикл
					РезультатОбъект=РезультатПраво.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
					СОбъектыПрава = Новый Соответствие;
					
					Если Найти(СокрЛП(РезультатПраво.Право),"Утверждение по подразделению") > 0 Тогда
					    СоответствиеПравПодразделение = Новый Соответствие;
						ПоПодразделению = Истина; ПоПользователю = Ложь;
					Иначе
						СоответствиеПравПользователь = Новый Соответствие;
						ПоПодразделению = Ложь; ПоПользователю = Истина;
					КонецЕсли; 
					
					Пока РезультатОбъект.Следующий() Цикл
						СОбъектыПрава.Вставить(РезультатОбъект.Объект, РезультатОбъект.Использование);
						РезультатСтатус = РезультатОбъект.Выбрать();
						Пока РезультатСтатус.Следующий() Цикл
							Если ПоПодразделению Тогда
								СоответствиеПравПодразделение.Вставить(РезультатСтатус.СтатусДокумента, РезультатСтатус.Использование);
							Иначе	
								СоответствиеПравПользователь.Вставить(РезультатСтатус.СтатусДокумента, РезультатСтатус.Использование);
							КонецЕсли;
						КонецЦикла;
					КонецЦикла;
					Результат.Вставить(РезультатПраво.ПравоНаименование,СОбъектыПрава);
				КонецЦикла;
				// добавляем дополнительно права на утверждение (общие)=пользователь+подразделение
								
				ПравоПодразделение = "Значения Утверждение по пользователю " + ВидДокумента;
				ПравоПользователь = "Значения Утверждение по подразделению " + ВидДокумента;
				СОбъектыПрава = Новый Соответствие;
				Если СоответствиеПравПодразделение = неопределено Тогда
				     СоответствиеПравПодразделение = Новый Соответствие;
				КонецЕсли; 
				Если СоответствиеПравПользователь = неопределено Тогда
				     СоответствиеПравПользователь = Новый Соответствие;
				КонецЕсли; 

				Для Каждого ТекЗначПеречисления Из Метаданные.Перечисления.СтатусыДокументов.ЗначенияПеречисления Цикл
					ИспользованиеПодразделение = ?(СоответствиеПравПодразделение[Перечисления.СтатусыДокументов[ТекЗначПеречисления.Имя]]=неопределено,
						Ложь,СоответствиеПравПодразделение[Перечисления.СтатусыДокументов[ТекЗначПеречисления.Имя]]);
					ИспользованиеПользователь = ?(СоответствиеПравПользователь[Перечисления.СтатусыДокументов[ТекЗначПеречисления.Имя]]=неопределено,
						Ложь,СоответствиеПравПользователь[Перечисления.СтатусыДокументов[ТекЗначПеречисления.Имя]]);
						
					СОбъектыПрава.Вставить(Перечисления.СтатусыДокументов[ТекЗначПеречисления.Имя],
						ИспользованиеПодразделение ИЛИ ИспользованиеПользователь);
				КонецЦикла;
				
				Результат.Вставить("Значения Утверждение " + СокрЛП(ВидДокумента),СОбъектыПрава);	
			КонецЦикла;
			
			Возврат Результат;
		КонецЕсли; 
	Иначе
		Если ОбъектДанных<>Неопределено Тогда
			Попытка
				ОбъектДанныхИмя=ОбъектДанных.Метаданные().Имя;
				ПравоНаименование=ТолькоЭтоПраво.Наименование+" "+ОбъектДанныхИмя;
				Если ПравоНаименование<>Неопределено Тогда
					ЗначениеПрава=Результат.Получить(ПравоНаименование);
					Если ЗначениеПрава<>Неопределено Тогда
						Возврат ЗначениеПрава;
					КонецЕсли;  
				КонецЕсли; 
			Исключение
			КонецПопытки; 
		КонецЕсли; 
		Возврат Результат[ТолькоЭтоПраво];
	КонецЕсли;
	
	Возврат Результат;
КонецФункции // обПолучитьПраваИНастройкиПользователя()
#Если Клиент Тогда

// Открывает АРМ администратора для редактирования прав и настроек пользователей/подразделений/организаций
//
// Параметры
//  ОбъектПрав  – СправочникСсылка.Пользователи,ПодразделенияКомпании,Организации – 
//                Объект, права которого требуется редактировать.
//                Если неопределено, открывается редактирование фирмы в целом.
//
Процедура обОткрытьПраваИНастройки(ОбъектПрав=Неопределено) Экспорт
	//Сначала проверим: а можно ли вообще пользователю использовать АРМ администратора
	МетаданныеАРМАдминистратор=Метаданные.Обработки.АРМАдминистратор;
	Если НЕ (ПравоДоступа("Использование", МетаданныеАРМАдминистратор) И ПравоДоступа("Просмотр", МетаданныеАРМАдминистратор)) Тогда
		Сообщить("Нет прав на использование АРМ <"+МетаданныеАРМАдминистратор+">.");
		Возврат;
	КонецЕсли;
	
	//Проверим, открыта ли панель АРМ
	ФормаФункциональнойПанели=Обработки.ФункциональнаяПанель.ПолучитьФорму();
	Если ФормаФункциональнойПанели.Открыта() Тогда
		//Если открыта, переключимся на АРМ администратора (если надо)
		ФормаФункциональнойПанели.ОткрытьАРМ(МетаданныеАРМАдминистратор.Имя,ФормаФункциональнойПанели);
	Иначе
		//Если функциональная панель АРМ не открыта, откроем (с выбором АРМ администратора)
		ФормаФункциональнойПанели.НачальноеЗначениеВыбора=МетаданныеАРМАдминистратор.Имя;
		ФормаФункциональнойПанели.Открыть();
	КонецЕсли;
	
	//Проверим открылась ли форма АРМ администратора
	ФормаАРМАдминистратор=Обработки.АРМАдминистратор.ПолучитьФорму(,ФормаФункциональнойПанели);
	Если НЕ ФормаАРМАдминистратор.Открыта() Тогда
		ФормаФункциональнойПанели.ОткрытьАРМ(МетаданныеАРМАдминистратор.Имя,ФормаФункциональнойПанели);
	КонецЕсли;
	
	//Активируем закладку с правами
	Если ФормаАРМАдминистратор.ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ФормаАРМАдминистратор.ЭлементыФормы.ПанельОсновная.Страницы.СтраницаПраваИНастройки Тогда
		ФормаАРМАдминистратор.ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ФормаАРМАдминистратор.ЭлементыФормы.ПанельОсновная.Страницы.СтраницаПраваИНастройки;
	КонецЕсли; 
	ФормаАРМАдминистратор.ПриОткрытииПрава(ОбъектПрав);
	ФормаАРМАдминистратор.Активизировать();
КонецПроцедуры // обОткрытьПраваИНастройки() 
 
#КонецЕсли

// функция проверяет используется ли объект как значение константы
//
// Параметры:
//	Объект			- Ссылка	- объект или ссылка на конкретный элемент справочника, 
//					документа, ПВХ, плана счетов, плана обмена, который нужно проверить
//					на "присутствие" в константах
//	ИмяКонстанты 	- Строка	- Необязательный "возвратный" параметр, в котором
//					возвращается имя константы которая ссылается на Объект
//
// Возвращаемое значение:
//	Булево	- Ложь если на объект не указывает ни одна из констант, Истина если есть константа,
//			которая ссылается на Объект (при этом имя константы можно получить из ИмяКонстанты)
//
// Пример использования:
//   ИмяКонстанты="";
//	 Если обОбъектУказанВКонстантах(ЭтотОбъект.Ссылка,ИмяКонстанты) Тогда
//      Сообщить("Текущий объект указан в константе <"+ИмяКонстанты+">",СтатусСообщения.Важное);
//
Функция обОбъектУказанВКонстантах(Объект,ИмяКонстанты="") Экспорт
	
	Результат =	Ложь;
	Ссылка  =	Объект.Ссылка;
	
	Если НЕ обЗначениеНеЗаполнено(Ссылка) Тогда
		ТипСсылки =	ТипЗнч(Ссылка);
		Для Каждого Константа из Константы Цикл
			
			Значение = Константа.Получить();
			
			Если (ТипЗнч(Значение) <> ТипСсылки)  Тогда
				// не тот тип значит не может ссылаться
				Продолжить;
			ИначеЕсли обЗначениеНеЗаполнено(Значение) Тогда
				// если сама константа не заполнена то идем дальше
				Продолжить;
			ИначеЕсли (Ссылка = Значение.Ссылка) Тогда
				// вот и нашли константу которая на нас ссылается
				Результат 	= Истина;
				МнджрЗнач 	= Константа.СоздатьМенеджерЗначения();
				ИмяКонстанты= МнджрЗнач.Метаданные().Синоним;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	Возврат(Результат);
	
КонецФункции // обОбъектУказанВКонстантах()

// Функция возвращает строковое представление отбора
//
// Параметры:
//	Отборы	- Структура	- Объект типа Отбор (напр.СправочникСписок.Отбор)
//
// Возвращаемое значение:
//	Строка	- Строковое представление отбора
//
Функция обПолучитьПредставлениеОтбора(Отборы) Экспорт
	Результат = "";
	Для Каждого Отбор из Отборы Цикл
		Если Отбор.Использование Тогда
			
			Если Отбор.ТипЗначения = Новый ОписаниеТипов("Дата") и обЗначениеНеЗаполнено(Отбор.Значение) Тогда
				Продолжить;
			КонецЕсли;
			
			Результат = Результат + " ";
			Результат = Результат + СтрЗаменить(Отбор.Представление, "_", " ")  + " ";
			
			Если Отбор.ВидСравнения = ВидСравнения.Равно Тогда
				Результат = Результат + "= " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Больше Тогда
				Результат = Результат + "> " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Меньше Тогда
				Результат = Результат + "< " + СокрЛП(Отбор.Значение);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.Интервал Тогда
                Результат = Результат + НСтр("ru=' > '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
                Результат = Результат + НСтр("ru=' И < '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяГраницы Тогда
                Результат = Результат + НСтр("ru=' >= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
                Результат = Результат + НСтр("ru=' И <= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяНачало Тогда
                Результат = Результат + НСтр("ru=' >= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
                Результат = Результат + НСтр("ru=' И < '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ИнтервалВключаяОкончание Тогда
                Результат = Результат + НСтр("ru=' > '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеС);
                Результат = Результат + НСтр("ru=' И <= '");
				Результат = Результат + СокрЛП(Отбор.ЗначениеПо);
			ИначеЕсли Отбор.ВидСравнения = ВидСравнения.ВСписке
				Или Отбор.ВидСравнения = ВидСравнения.ВСпискеПоИерархии
				Или Отбор.ВидСравнения = ВидСравнения.НеВСписке
				Или Отбор.ВидСравнения = ВидСравнения.НеВСпискеПоИерархии Тогда
				  Результат = Результат + Нрег(Отбор.ВидСравнения) + " (" + СокрЛП(Отбор.Значение) + ")";
			Иначе
				  Результат = Результат + Нрег(Отбор.ВидСравнения) + " " + СокрЛП(Отбор.Значение);
			КонецЕсли;
			Результат = Результат + ";";
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;
КонецФункции // обПолучитьПредставлениеОтбора()

#Если Сервер Тогда
	
// Проверяет в каком режиме работает 1С-Предприятие.
// Возвращает Истина-режим клиент-сервер; Ложь-файловый режим.
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Булево - признак клиент-сервера
//
Функция обЭтоКлиентСервер() Экспорт
	ЭтоКлиентСервер=Истина;
	#Если Клиент Тогда
		ЭтоКлиентСервер=Ложь;
	#КонецЕсли
	Возврат ЭтоКлиентСервер;
КонецФункции // обЭтоКлиентСервер()

#КонецЕсли

// функция получения валюты учета
//
// Параметры:
//	Номенклатура	- СправочникСсылка	- Номенклатура
//	ТипЦен			- СправочникСсылка	- Тип цен
//
// Возвращаемое значение:
//	СправочникСсылка	- валюта цены
//
Функция обВалютаТипаЦены(Номенклатура=Неопределено,ТипЦен,ВыводитьСообщения=Истина) Экспорт
	Если Номенклатура<>Неопределено И ТипЦен.ВВалютеУчета Тогда
		Если обЗначениеНеЗаполнено(Номенклатура.ВалютаУчета) Тогда
			#Если Клиент Тогда
			Если ВыводитьСообщения Тогда
				Сообщить("Не заполнена валюта учета номенклатуры <"+Номенклатура+">. Используется валюта регламентированного учета.",СтатусСообщения.Внимание);
			КонецЕсли; 
			#КонецЕсли
			Результат = Константы.ВалютаРегламентированногоУчетаОрганизаций.Получить();
		Иначе
			Результат = Номенклатура.ВалютаУчета;
		КонецЕсли; 
	Иначе
		Если обЗначениеНеЗаполнено(ТипЦен.ВалютаЦены) Тогда
			#Если Клиент Тогда
			Если ВыводитьСообщения Тогда
				Сообщить("Не заполнена валюта типа цен <"+ТипЦен+">. Используется валюта регламентированного учета.",СтатусСообщения.Внимание);
			КонецЕсли;
			#КонецЕсли
			Результат = Константы.ВалютаРегламентированногоУчетаОрганизаций.Получить();
		Иначе
			Результат = ТипЦен.ВалютаЦены;
		КонецЕсли;
	КонецЕсли;

	Возврат Результат;

КонецФункции// обВалютаТипаЦены(Номенклатура, ТипЦен)Экспорт	

// Получает и выдает на экран описание ошибки
//
// Параметры:
//	Нет.
//
// Возвращаемое значение:
//	Нет.
//
Процедура обОписаниеОшибки() Экспорт
	ТекстОшибки = ОписаниеОшибки();
	#Если Клиент Тогда
	Если Найти(ТекстОшибки, "Нарушение прав") > 0 Тогда	
		Предупреждение("Недостаточно прав для доступа к объекту.",,"Нарушение прав доступа!");
	Иначе
		Сообщить("Ошибка: " + Сред(ТекстОшибки, Найти(ТекстОшибки, ": ") + 2), СтатусСообщения.ОченьВажное);
	КонецЕсли;
	#КонецЕсли
КонецПроцедуры // обОписаниеОшибки()

// получает из строки HTML текст тела
//
// Параметры:
//	СтрокаHTML - Строка - строка HTML
//
// Возвращаемое значение:
//	Строка - Подстрока в строке HTML между <BODY> и </BODY>
//
Функция обПолучитьТелоHTML(СтрокаHTML) Экспорт
	НачалоТела = Найти(СтрокаHTML, "<BODY>") + 6;
	ОкончаниеТела = Найти(СтрокаHTML, "</BODY>");
	Если НачалоТела < ОкончаниеТела Тогда
		ТелоСодержания = Сред(СтрокаHTML, НачалоТела, ОкончаниеТела - НачалоТела);
	Иначе
		ТелоСодержания = "";
	КонецЕсли;
	
	// если, кроме пустых параграфов в теле ничего нет, вернём пустую строку
	Проверка = СокрЛП(СтрЗаменить(ТелоСодержания, "<P>&nbsp;</P>", ""));
	Если Проверка = "" Тогда
		ТелоСодержания = "";
	КонецЕсли;	
	
	Возврат ТелоСодержания;
КонецФункции// обПолучитьТелоHTML()

 // Функция предназначена для перевода HTML в текст
 // убирает все теги и заменяет кодовое обозначение стандартных символов
//
// Параметры:
//	Строка - Строка	 - Исходная строка в HTML
//
// Возвращаемое значение:
//	Строка - Итоговая строка простого текста
// 
Функция обПолучитьТекст(Строка) Экспорт
	НачалоСтрока = Найти(Строка,"<BODY>");
	Длина = СтрДлина (Строка);
	Если НачалоСтрока<>0 Тогда
		НачалоСтрока = НачалоСтрока+6;
	Иначе
		НачалоСтрока = 1;
	КонецЕсли;
	КонецСтрока = Найти(Строка,"</BODY>");
	Если КонецСтрока=0 или КонецСтрока<НачалоСтрока Тогда		
		КонецСтрока = Длина;
	КонецЕсли;	
	СтрокаРезультат = Сред(Строка, НачалоСтрока, КонецСтрока - НачалоСтрока);
	ДлинаСтрока = КонецСтрока - НачалоСтрока;
		
	СтрокаРезультат =  СтрЗаменить(СтрокаРезультат, Символ(13), "");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "<BR>",Символ(10));
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "\r;","");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "\n;","");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "\s;","");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&quot;","""");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#34;","""");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&amp;","&");	                     
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#38;","&"); 
 	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&nbsp;"," ");
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#160;"," ");    
 	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&iexcl;",Символ(161));
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#161;",Символ(161));                 
 	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&cent;",Символ(162));
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#162;",Символ(162));    
 	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&pound;",Символ(163));
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#163;",Символ(163));    
 	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&copy;",Символ(169));
	СтрокаРезультат = СтрЗаменить(СтрокаРезультат, "&#169;",Символ(169));	
    ИтоговыйТекст = "";
	БылоНачало = Ложь;	
	Индекс = 1;
	Пока Индекс<=Длина Цикл
		Символ = Сред(СтрокаРезультат, Индекс, 1);
		Если БылоНачало Тогда            		
			Если Символ = ">" Тогда
				БылоНачало = Ложь;
			КонецЕсли;
		Иначе
			Если Символ = "<" Тогда
				БылоНачало = Истина;
			Иначе
				ИтоговыйТекст = ИтоговыйТекст + Символ;
			КонецЕсли;
		КонецЕсли;
		Индекс = Индекс+1;
	КонецЦикла;	
	ИтоговыйТекст = СтрЗаменить(ИтоговыйТекст, "&lt;","<");
	ИтоговыйТекст = СтрЗаменить(ИтоговыйТекст, "&#60;","<");
	ИтоговыйТекст = СтрЗаменить(ИтоговыйТекст, "&gt;",">");
	ИтоговыйТекст = СтрЗаменить(ИтоговыйТекст, "&#62;",">");
	Возврат ИтоговыйТекст;
КонецФункции // обПолучитьТекст()

///////////////////////////////////////////////////////////////////
// РАЗЛИЧНЫЕ СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

#Если Клиент Тогда
	
// Выбирает составляющие цвета RGB из строки и возвращает переменную типа Цвет
//
// Параметры:
//	СтрокаЦвета - Строка	- Строка типа "RRR,GGG,BBB", где R,G и B - составляющие цвета
//
// Возвращаемое значение:
//	Цвет - цвет
//
Функция обПолучитьЦвет(СтрокаЦвета) Экспорт
	СтрЦвет = СтрокаЦвета;
	Красный = Сред(СтрЦвет, 1, Найти(СтрЦвет, ",") - 1);
	СтрЦвет = Сред(СтрЦвет, Найти(СтрЦвет, ",") + 1, СтрДлина(СтрЦвет));
	Зеленый = Сред(СтрЦвет, 1, Найти(СтрЦвет, ",") - 1);
	СтрЦвет = Сред(СтрЦвет, Найти(СтрЦвет, ",") + 1, СтрДлина(СтрЦвет));
	Синий	= Сред(СтрЦвет, 1, Найти(СтрЦвет, ",") - 1);
	Возврат  Новый Цвет(Красный, Зеленый, Синий);
КонецФункции // обПолучитьЦвет()

// Определяет, исходя из яркости фона, каким цветом выводить текст - белым или черным
//
// Параметры:
//	ЦветФона - Цвет	- Объект типа "Цвет"
//
// Возвращаемое значение:
//	Цвет - черный или белый цвет
//
Функция обПолучитьИнверсныйЦветТекста(ЦветФона) Экспорт
	
	Яркость = 0.3*ЦветФона.Красный + 0.59*ЦветФона.Зеленый + 0.11* ЦветФона.Синий;
	Возврат ?(Яркость  > 128, WebЦвета.Черный, WebЦвета.Белый);
	
КонецФункции // обПолучитьИнверсныйЦветТекста()

// проверяет входит ли указанное время во временной интервал
//
// Параметры:
//	ВремяНачалаИнтервала	- Дата	- Время начала интервала
//	ВремяОкончанияИнтервала - Дата	- Время окончания интервала
//	ВремяПроверки           - Дата	- Проверяемое время
//
// Возвращаемое значение:
//  Булево - признак вхождения в интервал
//
Функция обВходитВоВременнойИнтервал(Знач ВремяНачалаИнтервала,Знач ВремяОкончанияИнтервала,Знач ВремяПроверки) Экспорт
	// приведем все время к единому виду
	ВремяНачалаИнтервала='00010101'+(ВремяНачалаИнтервала-НачалоДня(ВремяНачалаИнтервала));
	ВремяОкончанияИнтервала='00010101'+(ВремяОкончанияИнтервала-НачалоДня(ВремяОкончанияИнтервала));
	ВремяПроверки='00010101'+(ВремяПроверки-НачалоДня(ВремяПроверки));
	
	// если время конца меньше времени начала, то это переход через 00:00:00
	Если ВремяОкончанияИнтервала<ВремяНачалаИнтервала Тогда
		ВремяОкончанияИнтервала=ВремяОкончанияИнтервала+86400;
	КонецЕсли;
	
	Возврат ((ВремяНачалаИнтервала<=ВремяПроверки И ВремяОкончанияИнтервала>=ВремяПроверки) ИЛИ (ВремяНачалаИнтервала<=(ВремяПроверки+86400) И ВремяОкончанияИнтервала>=(ВремяПроверки+86400)));
КонецФункции // обВходитВоВременнойИнтервал()

// Возвращает текущую для сеанса работы дату 
//
// Параметры:
//	Нет
//
// Возвращаемое значение:
//	Дата - возвращаемая дата
//
Функция обТекущаяДата() Экспорт
	Возврат ?(РабочаяДата = НачалоДня(ТекущаяДата()), ТекущаяДата(), КонецДня(РабочаяДата));	
КонецФункции // обТекущаяДата()

Процедура СохранитьРазмерыФормы(ЭтаФорма) Экспорт
	Если Константы.ВосстанавливатьРазмерыФорм.Получить() = Ложь Тогда 
		Возврат;
	КонецЕсли;

	Попытка
		ИмяМетаданныхФормы = ЭтаФорма.ДокументОбъект.Метаданные().Имя;
	Исключение
		Попытка
			ИмяМетаданныхФормы = ЭтаФорма.Метаданные().Имя;
		Исключение
			ИмяМетаданныхФормы = ЭтаФорма.Заголовок;
		КонецПопытки;
	КонецПопытки;
	
	СохранитьЗначение("ШиринаФормы" + ИмяМетаданныхФормы, ЭтаФорма.Ширина); //Запоминаем ширину формы
	СохранитьЗначение("ВысотаФормы" + ИмяМетаданныхФормы, ЭтаФорма.Высота); //Запоминаем высоту формы
КонецПроцедуры

Процедура ВосстановитьРазмерыФормы(ЭтаФорма) Экспорт
	Если Константы.ВосстанавливатьРазмерыФорм.Получить() = Ложь Тогда 
		Возврат;
	КонецЕсли;

	Если НЕ ПустаяСтрока(ЭтаФорма.КлючСохраненияПоложенияОкна) Тогда
		Возврат;
	КонецЕсли;

	ЭтаФорма.КлючСохраненияПоложенияОкна = Новый УникальныйИдентификатор();
	
	Попытка
		ИмяМетаданныхФормы = ЭтаФорма.ДокументОбъект.Метаданные().Имя;
	Исключение
		Попытка
			ИмяМетаданныхФормы = ЭтаФорма.Метаданные().Имя;
		Исключение
			ИмяМетаданныхФормы = ЭтаФорма.Заголовок;
		КонецПопытки;
	КонецПопытки;

	ШиринаФормы = ВосстановитьЗначение("ШиринаФормы" + ИмяМетаданныхФормы); //Восстанавливаем ширину формы
	Если ЗначениеЗаполнено(ШиринаФормы) Тогда
	    ЭтаФорма.Ширина = ШиринаФормы;    
	КонецЕсли;
	ВысотаФормы = ВосстановитьЗначение("ВысотаФормы" + ИмяМетаданныхФормы); //Восстанавливаем высоту формы
	Если ЗначениеЗаполнено(ВысотаФормы) Тогда
	    ЭтаФорма.Высота = ВысотаФормы;    
	КонецЕсли;
КонецПроцедуры

#КонецЕсли

// Функция получает таблицу соответствий небалансовых подразделений балансовым.
// При закрытии периода остатки по регистру "Доходы и расходы" с небалансовых подразделений переносятся
// на балансовые (либо на корневое подразделение)
//
// Параметры:
//  БалансВедетсяПоПодразделению - "Булево" - признак ведения учета баланса по подразделениям.
//											  Соответстует значению константы "Способ ведения баланса"
//
// Возвращаемое значение:
//   Табилица значений 
//       	- Источник: небалансовое подразделение, остатки которого необходимо перенести.
//			- Приемник: балансовое подразделение, на которое происходит перенос остатков.
// 
Функция обПолучитьСоответствияБалансовымПодразделениям(БалансВедетсяПоПодразделению) Экспорт
		
	// Если баланс ведется не по подразделениям, то все подразделения закрываются на корневой элемент.
	Если Не БалансВедетсяПоПодразделению Тогда
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПодразделенияКомпании.Ссылка КАК Источник,
		|	&Ссылка КАК Приемник
		|ИЗ
		|	Справочник.ПодразделенияКомпании КАК ПодразделенияКомпании
		|ГДЕ
		|	ПодразделенияКомпании.Ссылка <> &Ссылка
		|	И (НЕ ПодразделенияКомпании.ПометкаУдаления)";
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Справочники.ПодразделенияКомпании.ОсновноеПодразделение);
		Возврат Запрос.Выполнить().Выгрузить();
	Иначе
		// В этом случае получим список небалансовых подразделений.
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПодразделенияКомпании.Ссылка КАК Источник,
		|	&Ссылка КАК Приемник
		|ИЗ
		|	Справочник.ПодразделенияКомпании КАК ПодразделенияКомпании
		|ГДЕ
		|	(НЕ ПодразделенияКомпании.Балансовое)
		|	И ПодразделенияКомпании.Ссылка <> &Ссылка
		|	И (НЕ ПодразделенияКомпании.ПометкаУдаления)";
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Справочники.ПодразделенияКомпании.ОсновноеПодразделение);
		
		тзСоответствия = Запрос.Выполнить().Выгрузить();
		
		// Проходимся по полученным небалансовым подразделениям и находим для них соответствия.
		Для каждого ТекСтрока Из тзСоответствия  Цикл  	
			ТекСтрока.Приемник = обПолучитьБалансовоеПодразделение(ТекСтрока.Источник);	
		КонецЦикла;
		
		Возврат тзСоответствия;
	КонецЕсли;  	
КонецФункции // обПолучитьСоответствияБалансовымПодразделениям() 

// Функция получает для небалансового подразделения соответствующее балансовое подразделение
// (на которое будут переноситься остатки при закрытии периода)
//
// Параметры:
//  Источник – "СправочникСсылка.ПодразделениеКомпании" - небалансовое подразделение, остатки которого необходимо перенести.
//
// Возвращаемое значение:
//   "СправочникСсылка.ПодразделениеКомпании" - балансовое подразделение, на которое будут перенесены остатки.
// 
Функция обПолучитьБалансовоеПодразделение(ПодразделениеИсточник) Экспорт
	КорневойЭлемент = Справочники.ПодразделенияКомпании.ОсновноеПодразделение;
	
	// Если учет ведется не по подразделениям, то вернем корневое подразделение.
	Если Константы.СпособВеденияБаланса.Получить()<>Перечисления.СпособВеденияБаланса.ПоПодразделению Тогда
		Возврат КорневойЭлемент;	
	КонецЕсли;
	
	Если ПодразделениеИсточник.Балансовое или (ПодразделениеИсточник=КорневойЭлемент) Тогда
		Возврат ПодразделениеИсточник;		
	КонецЕсли;  	
	
	ТекЭлемент = ПодразделениеИсточник;
	Пока Истина Цикл
		ТекЭлемент = ТекЭлемент.Родитель;
		Если ТекЭлемент.Пустая() Или (ТекЭлемент=КорневойЭлемент) Тогда
			Возврат КорневойЭлемент;
		КонецЕсли;
		
		Если ТекЭлемент.Балансовое Тогда
			Возврат ТекЭлемент;
		КонецЕсли;		
	КонецЦикла;  	
КонецФункции // обПолучитьБалансовоеПодразделение() 

// Функция преобразования текста в HTML формат
// заменяет служебные символы
// Параметры
//		Текст - исходный текст
Функция обПреобразоватьТекстВHTML(Текст = "") Экспорт
	Преобразования = Новый Массив;
	Преобразования.Добавить(Новый Структура("Текст, HTML", "&", "&amp;"));
	Преобразования.Добавить(Новый Структура("Текст, HTML", "<", "&lt;"));
	Преобразования.Добавить(Новый Структура("Текст, HTML", ">", "&gt;"));
	Преобразования.Добавить(Новый Структура("Текст, HTML", """","&quot;"));
	Преобразования.Добавить(Новый Структура("Текст, HTML", Символы.ПС, "<br>"));
	
	Результат = Текст;
	
	Для каждого Преобразование из Преобразования цикл
		Результат  = СтрЗаменить(Результат, Преобразование.Текст, Преобразование.HTML);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции // обПреобразоватьТекстВHTML()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция обРазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // обРазложитьСтрокуВМассивПодстрок

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция обСформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // обСформироватьТекстСообщения


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

// Устанавливает управляемую блокировку таблицы
//
// Параметры:
//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  КоллекцияЗначенийБлокировки	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - блокируемое значение - <Произвольный тип>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом УстановитьЗначение() не накладываются.
//  КоллекцияОписанияИсточника	- <Структура или Соответствие> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>, 
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - поле таблицы источника данных - <Строка>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом ИспользоватьИзИсточникаДанных() не накладываются.
//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
//
Процедура обУстановитьУправляемуюБлокировку(СтруктураПараметров, КоллекцияЗначенийБлокировки = Неопределено, КоллекцияОписанияИсточника = Неопределено, Отказ = Ложь) Экспорт
	//Если ТипЗнч(КоллекцияЗначенийБлокировки)=Тип("Соответствие") Тогда
	//	КоллекцияЗначенийБлокировкиСтруктура=Новый Структура;
	//	Для каждого ЗначениеБлокировки Из КоллекцияЗначенийБлокировки Цикл
	//	 КоллекцияЗначенийБлокировкиСтруктура.Вставить(ЗначениеБлокировки.Ключ,ЗначениеБлокировки.Значение);
	//	КонецЦикла; 
	//Иначе
	//	КоллекцияЗначенийБлокировкиСтруктура=КоллекцияЗначенийБлокировки;
	//КонецЕсли; 
	//Если ТипЗнч(КоллекцияОписанияИсточника)=Тип("Соответствие") Тогда
	//	КоллекцияОписанияИсточникаСтруктура=Новый Структура;
	//	Для каждого ЗначениеИсточника Из КоллекцияОписанияИсточника Цикл
	//	 КоллекцияОписанияИсточникаСтруктура.Вставить(ЗначениеИсточника.Ключ,ЗначениеИсточника.Значение);
	//	КонецЦикла; 
	//Иначе
	//	КоллекцияОписанияИсточникаСтруктура=КоллекцияОписанияИсточника;
	//КонецЕсли;
	////ЗАЩИТА: Перед сборкой заменить на вызов функции из защищенного хранилища
	////Обработки.ЗащитаТОР.Создать().УстановитьУправляемуюБлокировку(СтруктураПараметров,КоллекцияЗначенийБлокировкиСтруктура,КоллекцияОписанияИсточникаСтруктура,Отказ);
	////ЗАЩИТА: Вызов функции из защищенного хранилища 
	//зфЗащищенныеФункцииСервер.УстановитьУправляемуюБлокировку(СтруктураПараметров,КоллекцияЗначенийБлокировкиСтруктура,КоллекцияОписанияИсточникаСтруктура,Отказ);
	////ЗАЩИТА: Коней вызова функции из защищенного хранилища 
	
	
	
	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИспользоватьЗначенияБлокировки = КоллекцияЗначенийБлокировки <> Неопределено 
		И (ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Структура") 
		 ИЛИ ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Соответствие"))
		И КоллекцияЗначенийБлокировки.Количество() > 0;
		
	ИспользоватьИсточникДанных = КоллекцияОписанияИсточника <> Неопределено 
		И (ТипЗнч(КоллекцияОписанияИсточника) = Тип("Структура") 
		 ИЛИ ТипЗнч(КоллекцияОписанияИсточника) = Тип("Соответствие"))
		И КоллекцияОписанияИсточника.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");
	
	Если (НЕ ИспользоватьЗначенияБлокировки) И (НЕ ИспользоватьИсточникДанных) Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления");
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы + "." + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
	
	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;
	
	Если ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Для Каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл
			ЭлементБлокировки.УстановитьЗначение(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
	Иначе
		
		//Если ИспользоватьИсточникДанных Тогда
		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для Каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементКоллекции.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			ТекстЗапроса = 
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
			Запрос.Текст = ТекстЗапроса;
			ИсточникДанных = Запрос.Выполнить();
		КонецЕсли;
		
		Если ИспользоватьЗначенияБлокировки Тогда
			Если ТипЗнч(ИсточникДанных) = Тип("ТаблицаЗначений") Тогда
				ИсточникДанных = ИсточникДанных.Скопировать();
			Иначе
				ИсточникДанных = ИсточникДанных.Выгрузить();
			КонецЕсли;
			
			ТекстКолонок = "";
			Для Каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
				Если ИсточникДанных.Колонки.Найти(ЭлементКоллекции.Значение) = Неопределено Тогда
					Сообщить("<" + ПространствоБлокировки + ">. Не установлена блокировка по полю """ + ЭлементКоллекции.Ключ + """ колонки """ + ЭлементКоллекции.Значение + """ нет в источнике данных!", СтатусСообщения.Важное);
					Продолжить;
				КонецЕсли;
				ТекстКолонок = ТекстКолонок + ?(ТекстКолонок = "", "", ", ") + ЭлементКоллекции.Значение;
			КонецЦикла;
			ИсточникДанных.Свернуть(ТекстКолонок);
			
			Для Каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл
				Если ИсточникДанных.Колонки.Найти(ЭлементКоллекции.Ключ) = Неопределено Тогда
					ТипКолонки = Новый Массив;
					ТипКолонки.Добавить(ТипЗнч(ЭлементКоллекции.Значение));
					ИсточникДанных.Колонки.Добавить(ЭлементКоллекции.Ключ, Новый ОписаниеТипов(ТипКолонки));
				КонецЕсли;
				ИсточникДанных.ЗаполнитьЗначения(ЭлементКоллекции.Значение, ЭлементКоллекции.Ключ);
			КонецЦикла;
		КонецЕсли;
		
		ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
		
		Для Каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
		
		Если ИспользоватьЗначенияБлокировки Тогда
			Для Каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл
				ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементКоллекции.Ключ, ЭлементКоллекции.Ключ);
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		Блокировка.Заблокировать();
	Исключение
		Отказ = Истина;
		Сообщить(ОписаниеОшибки(),СтатусСообщения.Важное);
		ВызватьИсключение "Операция не выполнена";
	КонецПопытки;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ХРАНИЛИЩАМИ НАСТРОЕК

Функция ХранилищеНастроекДанныхФормЗагрузитьДляТекущегоПользователя(КлючОбъекта, КлючНастроек = "", ОписаниеНастроек = Неопределено, ПоУмолчанию = Неопределено) Экспорт
	
	СохраненныеНастройки = ХранилищеНастроекДанныхФорм.Загрузить(КлючОбъекта, КлючНастроек, ОписаниеНастроек);
	Возврат ?(СохраненныеНастройки = Неопределено, ПоУмолчанию, СохраненныеНастройки);
		                                                                             
КонецФункции

Процедура ХранилищеНастроекДанныхФормСохранитьДляТекущегоПользователя(КлючОбъекта, Настройки, КлючНастроек = "", ОписаниеНастроек = Неопределено) Экспорт
	
	ХранилищеНастроекДанныхФорм.Сохранить(КлючОбъекта, КлючНастроек, Настройки, ОписаниеНастроек);
	
КонецПроцедуры