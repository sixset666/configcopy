
#Область ФункционалОплаты
Функция ПередачаПоQRНажатие(Форма) Экспорт
	
	// БИЗТЕХ КОВАЛЬ 15.07.2025 ++
	// ТИП СПОСОБА РАСЧЕТА
	ВхТипСпособаРасчета = Неопределено;
	Попытка
		ВхТипСпособаРасчета = Форма.ТипСпособаРасчета;
	Исключение
	КонецПопытки;
	
	Попытка
		Если НЕ ЗначениеЗаполнено(ВхТипСпособаРасчета) Тогда
			ВхТипСпособаРасчета = Форма.ЭтаФорма.прПередача;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Если НЕ ЗначениеЗаполнено(ВхТипСпособаРасчета) Тогда
		Предупреждение("Не определен тип способа расчета ККТ",,"Ошибка");
		Возврат Ложь;
	КонецЕсли;
	// БИЗТЕХ КОВАЛЬ 15.07.2025 --
	
	//
	//Если ВхТипСпособаРасчета <> Перечисления.ТипыСпособаРасчетаККТ.Передача Тогда
	//	Предупреждение("Частичная оплата по QR невозможна. Выберите другой способ оплаты.",,"Ошибка");
	//	Возврат Ложь;
	//КонецЕсли;
	
	Попытка
		Форма["О2_QR_ОплатаЧерезQRКод"] = Истина;
		Форма.закрыть(Истина);
	Исключение
		Сообщить("Не найден флаг О2_QR_ОплатаЧерезQRКод в модуле ФронтКассира");
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция ОплатаЧерезQR(ЧекНаОплату,ДокументОснование) Экспорт
	
	ОчиститьСообщения();
	// Блок получения настроек и проверки данных для оплаты О2
	НастройкиОплаты = ПолучитьНастройкиОплаты(ДокументОснование.ПодразделениеКомпании);
	Если НЕ ЗначениеЗаполнено(НастройкиОплаты.О2_QR_КассаККМ) ИЛИ
		НЕ ЗначениеЗаполнено(НастройкиОплаты.О2_QR_КонтрагентИнкассатор) ИЛИ
		НЕ ЗначениеЗаполнено(НастройкиОплаты.О2_QR_КонтрагентИнкассаторДоговор) Тогда
		
		Сообщить("Оплата по QR не настроена для подразделения <" + ДокументОснование.ПодразделениеКомпании + "> !");
		Возврат ЛОЖЬ;
	ИначеЕсли НЕ ЗначениеЗаполнено(НастройкиОплаты.О2_QR_КассаККМ.О2_QR_ИдентификаторКассы) ИЛИ 
		НЕ ЗначениеЗаполнено(НастройкиОплаты.О2_QR_КассаККМ.О2_QR_КлючДоступаККассе) Тогда
		
		Сообщить("Оплата по QR не настроена для Кассы ККМ <" + НастройкиОплаты.О2_QR_КассаККМ + "> !");
		Возврат ЛОЖЬ;
	ИначеЕсли НЕ ЗначениеЗаполнено(ЧекНаОплату.СтавкаНДС.О2_QR_Код) Тогда
		
		Сообщить("Оплата по QR не настроена для Ставок НДС !");
		Возврат ЛОЖЬ;
	ИначеЕсли ПолучитьПочтуКонтрагента(ЧекНаОплату.Контрагент) = Неопределено И ПолучитьКорректныйТелефонКонтрагента(ЧекНаОплату.Контрагент) = Неопределено Тогда
		
		Сообщить("Не указана корректная почта контрагента или корректный телефон!");
		Возврат ЛОЖЬ;
	Иначе
		Для Каждого Товар Из ЧекНаОплату.Товары Цикл
			Если НЕ ЗначениеЗаполнено(Товар.СтавкаНДС.О2_QR_Код) Тогда
				Сообщить("Оплата по QR не настроена для Ставок НДС !");
				Возврат ЛОЖЬ;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	//Запишем чек на оплату
	ЧекНаОплатуСсылка = ЗаписатьЧекНаОплату(ЧекНаОплату,НастройкиОплаты);
	//ЧекНаОплатуСсылка = Документы.ЧекНаОплату.СоздатьДокумент().Ссылка;
	
	//Отправим запрос на оплату
	Хост = Константы.О2_QR_API_Хост.Получить();
	URL = "https://" + Хост + "/create_payment";
	Метод = "POST";
	Body = ПолучитьСтруктуруДокумента(ЧекНаОплатуСсылка);	
	Ответ = ВыполнитьHTTPЗапрос(URL,Метод,Body,,,,ЧекНаОплатуСсылка);
	
	PaymentID = ПолучитьПоПути(Ответ,"payment_id");
	qr_code_url = ПолучитьПоПути(Ответ,"qr_code_url");
	
	//Если PaymentID <> ЧекНаОплатуСсылка.О2_QR_ИдПлатежа Тогда
	//	Сообщить("ОШИБКА!");
	//	Сообщить("Полученный ID Платежа не равен отправленному ID Платежа!");
	//	Возврат ЛОЖЬ;
	//КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(qr_code_url) Тогда
		Сообщить("ОШИБКА!");
		Сообщить("Ошибка обработки ответа, подробнее в логировании запросов QR О2 !");
		Возврат ЛОЖЬ;
	КонецЕсли;
	
	//Запишем новый статус
	ЗаписатьСтатусПлатежа(Перечисления.О2_QR_СтатусыОплаты.Сreated,ЧекНаОплату);
	
	//Отправим запрос на получение таймаута
	Хост = Константы.О2_QR_API_Хост.Получить();
	URL = "https://" + Хост + "/config";
	Метод = "GET";
	Ответ = ВыполнитьHTTPЗапрос(URL,Метод,,,,,ЧекНаОплатуСсылка);
	payment_ttl = ПолучитьПоПути(Ответ,"payment_ttl"); 
	Если НЕ ЗначениеЗаполнено(payment_ttl) Тогда
		payment_ttl = 15 * 60; // по умолчанию 15 мин
	Иначе
		payment_ttl = payment_ttl * 60; // нужно в секундах
	КонецЕсли;
	
	
	//Откроем форму оплаты
	ФормаОплаты = ПолучитьФорму("ОбщаяФорма.О2_QR_ФормаОплаты");
	ФормаОплаты.IDОплаты = СтрЗаменить(Строка(ЧекНаОплатуСсылка.О2_QR_ИдПлатежа)," ","");
	ФормаОплаты.ОплачиваемыйДокумент = ЧекНаОплатуСсылка;
	ФормаОплаты.ОставшеесяВремя = payment_ttl;
	ФормаОплаты.СсылкаНаОплату = qr_code_url;
	ФормаОплаты.QRКод = ПоместитьВоВременноеХранилище(ПолучитьQRКОД(qr_code_url),ФормаОплаты.УникальныйИдентификатор);
	ФормаОплаты.Открыть();
	
	
	Сообщить(ЧекНаОплатуСсылка);
	Возврат Истина;
	
КонецФункции
Функция СгенерироватьIDОплаты()
	
	Ген = новый ГенераторСлучайныхЧисел();
	СлучайноеЧисло = Ген.СлучайноеЧисло();
	Возврат СлучайноеЧисло;

КонецФункции
Функция ПолучитьСтруктуруДокумента(ДокументЧекНаОплату)
	
	Body = Новый Структура;
	
	order = новый Структура;
	client = новый Структура;
	reciept_items = новый Массив;
	
	//Способ расчета
	Если ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Передача Тогда
		payment_method = "FullPayment";
		payment_method_description = "Полный расчет" ;

	ИначеЕсли ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Предоплата И ДокументЧекНаОплату.Сделка.СуммаДокумента = ДокументЧекНаОплату.СуммаДокумента Тогда
		payment_method = "FullPrepayment" ;
		payment_method_description = "Полная предоплата" ;
		
	ИначеЕсли ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Предоплата И ДокументЧекНаОплату.Сделка.СуммаДокумента <> ДокументЧекНаОплату.СуммаДокумента Тогда
		payment_method = "PartialPrepayment" ;
		payment_method_description = "Частичная оплата" ;	
	Иначе
		payment_method = "PartialPrepayment" ;
		payment_method_description = "Частичная оплата" ;
	КонецЕсли;
	
	// БИЗТЕХ КОВАЛЬ 28.05.2025 +
	// Изменения согласно ТЗ "Оплата по QR. Доработки" - Вернуться к старой системе (Закомментрировал строки)
	
	// БИЗТЕХ КОВАЛЬ 28.05.2025 ++
	// Изменения согласно ТЗ - Всегда отправлять FullPrepayment
	//payment_method = "FullPrepayment" ;
	//payment_method_description = "Полная предоплата" ;
	// БИЗТЕХ КОВАЛЬ 28.05.2025 --
	
	// БИЗТЕХ КОВАЛЬ 05.06.2025 --
	
	
	//Предмет расчета
	ПредметРасчета = ПолучитьПредметРасчета(ДокументЧекНаОплату.ДокументОснование);
	Если ПредметРасчета = "Товар" Тогда
		ПредметРасчетаО2 = "Commodity";
	ИначеЕсли ПредметРасчета = "Услуга" Тогда
		ПредметРасчетаО2 = "Service";
	Иначе
		ПредметРасчетаО2 = "Service";
	КонецЕсли;
	
	// БИЗТЕХ КОВАЛЬ 03.12.2025 ++
	order.Вставить("source", "Retail");
	// БИЗТЕХ КОВАЛЬ 03.12.2025 --
	
	order.Вставить("cashbox",Base64Строка(ПолучитьДвоичныеДанныеИзСтроки(ДокументЧекНаОплату.КассаККМ.О2_QR_ИдентификаторКассы+":"+ДокументЧекНаОплату.КассаККМ.О2_QR_КлючДоступаККассе,"UTF-8",Ложь)));
	order.Вставить("order_id",ДокументЧекНаОплату.О2_QR_ИдПлатежа);
	order.Вставить("description",Строка(ДокументЧекНаОплату.ДокументОснование)
								+ " " + ПредметРасчета 
								+ " " + payment_method_description);
	Если ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Предоплата Тогда							
		order.Вставить("vat_type", "Vat120");
	Иначе
		Если ЗначениеЗаполнено(Строка(ДокументЧекНаОплату.СтавкаНДС.О2_QR_Код)) Тогда
			order.Вставить("vat_type", Строка(ДокументЧекНаОплату.СтавкаНДС.О2_QR_Код));
		Иначе
			order.Вставить("vat_type", "Vat22");
		КонецЕсли;
	КонецЕсли;

	order.Вставить("amount",ДокументЧекНаОплату.СуммаДокумента);
	//order.Вставить("currency",Строка(ДокументЧекНаОплату.ВалютаДокумента.Код));
	//order.Вставить("type","Payment");
	
	Почта = ПолучитьПочтуКонтрагента(ДокументЧекНаОплату.Контрагент);
	Телефон = ПолучитьКорректныйТелефонКонтрагента(ДокументЧекНаОплату.Контрагент);
	
	Если ЗначениеЗаполнено(Почта) Тогда
		client.Вставить("email", Почта);	
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Телефон) Тогда
		client.Вставить("phone", Телефон);	
	КонецЕсли;
	
	order.Вставить("client",client);
	
	// БИЗТЕХ КОВАЛЬ 18.07.2025 ++
	// Изменена логика формирования товаров - для частичной оплаты заполняется только один товар "Предоплата"
	Если ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Передача Тогда
		// ЛОГИКА ПЕРЕДАЧИ
		Для Каждого Товар Из ДокументЧекНаОплату.Товары Цикл
			СтруктураТовара = Новый Структура;
			
			Если ПредметРасчетаО2 = "Service" Тогда 
				СтруктураТовара.Вставить("name",Товар.Номенклатура.Наименование + " " + Товар.Количество);
				СтруктураТовара.Вставить("quantity",1);
				СтруктураТовара.Вставить("price",Товар.СуммаВсего);
			Иначе 	
				СтруктураТовара.Вставить("name",Товар.Номенклатура.Наименование);
				СтруктураТовара.Вставить("quantity",Товар.Количество*Товар.Коэффициент);
				СтруктураТовара.Вставить("price",Окр(Товар.СуммаВсего/Товар.Количество*Товар.Коэффициент, 2)); 
			КонецЕсли;
			
			СтруктураТовара.Вставить("vat_type",Товар.СтавкаНДС.О2_QR_Код);
			СтруктураТовара.Вставить("payment_subject",ПредметРасчетаО2);
			СтруктураТовара.Вставить("payment_method",payment_method);
			
			reciept_items.Добавить(СтруктураТовара);
		КонецЦикла;
		
	ИначеЕсли ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Предоплата И payment_method = "FullPrepayment" Тогда
		// ЛОГИКА ПОЛНОЙ ПРЕДОПЛАТЫ
		
		Для Каждого Товар Из ДокументЧекНаОплату.Товары Цикл
			СтруктураТовара = Новый Структура;
			
			Если ПредметРасчетаО2 = "Service" Тогда 
				СтруктураТовара.Вставить("name",Товар.Номенклатура.Наименование + " " + Товар.Количество);
				СтруктураТовара.Вставить("quantity",1);
				СтруктураТовара.Вставить("price",Товар.СуммаВсего);
			Иначе 	
				СтруктураТовара.Вставить("name",Товар.Номенклатура.Наименование);
				СтруктураТовара.Вставить("quantity",Товар.Количество*Товар.Коэффициент);
				СтруктураТовара.Вставить("price",Окр(Товар.СуммаВсего/Товар.Количество*Товар.Коэффициент, 2)); 
			КонецЕсли;
			
			СтруктураТовара.Вставить("vat_type", "Vat120");
			СтруктураТовара.Вставить("payment_subject",ПредметРасчетаО2);
			СтруктураТовара.Вставить("payment_method",payment_method);
			
			reciept_items.Добавить(СтруктураТовара);
		КонецЦикла;
				
	ИначеЕсли ДокументЧекНаОплату.ТипСпособаРасчетаККТ = Перечисления.ТипыСпособаРасчетаККТ.Предоплата И payment_method = "PartialPrepayment" Тогда
		// ЛОГИКА ЧАСТИЧНОЙ ПРЕДОПЛАТЫ
		
		ТоварПредоплата = Справочники.Номенклатура.Предоплата;
		
		СтруктураТовара = Новый Структура;
		СтруктураТовара.Вставить("name", "Предоплата по документу " + Строка(ДокументЧекНаОплату.Сделка));
		СтруктураТовара.Вставить("quantity", 1);
		СтруктураТовара.Вставить("price", ДокументЧекНаОплату.СуммаДокумента);
		СтруктураТовара.Вставить("vat_type", "Vat120");
		СтруктураТовара.Вставить("payment_subject", "Payment");
		СтруктураТовара.Вставить("payment_method", payment_method);
		reciept_items.Добавить(СтруктураТовара);
	КонецЕсли;
	//БИЗТЕХ КОВАЛЬ 18.07.2025 --
	
	order.Вставить("receipt_items",reciept_items);
	
	// БИЗТЕХ КОВАЛЬ 05.11.2025 ++
	
	СтруктураОплат = Новый Структура;
	
	Для Каждого СтрокаОплаты Из ДокументЧекНаОплату.Оплаты Цикл
		
		Если СтрокаОплаты.ТипОплаты = Справочники.ТипыОплат.Безналичные Тогда
			
			СтруктураОплат.Вставить("cashless", СтрокаОплаты.Сумма);
			
		ИначеЕсли СтрокаОплаты.ТипОплаты = Справочники.ТипыОплат.ЗачетАванса Тогда
			
			СтруктураОплат.Вставить("advance", СтрокаОплаты.Сумма);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если СтруктураОплат.Количество() Тогда
		order.Вставить("settlements", СтруктураОплат);
	КонецЕсли;
	
	// БИЗТЕХ КОВАЛЬ --
		
	Body.Вставить("order",order);
	
	Возврат Body;
	
КонецФункции
Функция БлокировкаЧекаНаОплату(ОплаченПоQRО2) Экспорт 
	Если ОплаченПоQRО2 и не РольДоступна("ПолныеПрава") Тогда  //Аляль 02.07.2025г. нужно менять оплаты!
		Сообщить("Запрещено редактировать чеки на оплату оплаченные через QR О2");
		Возврат Истина;
	КонецЕсли; 
	Возврат Ложь;
КонецФункции
#КонецОбласти

#Область ЭлементыКонфигурации
Функция ЗаписатьЧекНаОплату(ЧекНаОплатуОбъект,НастройкиОплаты)
	IDПлатежа = СгенерироватьIDОплаты();
	
	ЧекНаОплатуОбъект.О2_QR_ИдПлатежа = IDПлатежа;
	ЧекНаОплатуОбъект.КассаККМ = НастройкиОплаты.О2_QR_КассаККМ;
	ЧекНаОплатуОбъект.ДляПробитияНаФР = Ложь; 
	ЧекНаОплатуОбъект.СкладКомпании = Неопределено;
	ЧекНаОплатуОбъект.ПолученоБезнал = ЧекНаОплатуОбъект.СуммаДокумента;
	
	ЧекНаОплатуОбъект.Оплаты.Очистить();
	НоваяСтрокаОплаты = ЧекНаОплатуОбъект.Оплаты.Добавить();
	НоваяСтрокаОплаты.ТипОплаты = Справочники.ТипыОплат.Безналичные;
	НоваяСтрокаОплаты.ТипПлатежнойКарты = Справочники.ТипыПлатежныхКарт.Visa;
	НоваяСтрокаОплаты.Сумма = ЧекНаОплатуОбъект.СуммаДокумента;
	НоваяСтрокаОплаты.Контрагент = НастройкиОплаты.О2_QR_КонтрагентИнкассатор;
	НоваяСтрокаОплаты.ДоговорВзаиморасчетов = НастройкиОплаты.О2_QR_КонтрагентИнкассаторДоговор;
	
	ЧекНаОплатуОбъект.ОбработкаРеквизита("СтавкаНДС");
	
	ЧекНаОплатуОбъект.Записать(РежимЗаписиДокумента.Запись,РежимПроведенияДокумента.Оперативный);
	Сообщить("Записан документ <"+ЧекНаОплатуОбъект.Ссылка+">");
	Возврат ЧекНаОплатуОбъект.Ссылка;
	
КонецФункции 
Функция ПолучитьНастройкиОплаты(Подразделение)
	СтруктураНастроек = новый Структура;
	
	ПраваПодразделения = обПолучитьПраваИНастройкиПользователя(Подразделение);
	
	СтруктураНастроек.Вставить("О2_QR_КассаККМ",обПраво("О2_QR_КассаККМ",ПраваПодразделения,,Подразделение));
	СтруктураНастроек.Вставить("О2_QR_КонтрагентИнкассатор",обПраво("О2_QR_КонтрагентИнкассатор",ПраваПодразделения,,Подразделение));
	// БИЗТЕХ КОВАЛЬ 28/05/2025 ++
	// Временный костыль так как нет в правах типа ДоговорыВзаиморасчетов, требуется монопольно изменять.
	// Пока указал тип строка
	КодДоговора = обПраво("О2_QR_КонтрагентИнкассаторДоговор",ПраваПодразделения,,Подразделение);
	Если ЗначениеЗаполнено(КодДоговора) Тогда
		Договор = Справочники.ДоговорыВзаиморасчетов.НайтиПоКоду(КодДоговора);
		Если НЕ Договор.Пустая() Тогда
			СтруктураНастроек.Вставить("О2_QR_КонтрагентИнкассаторДоговор",Договор);
		Иначе
			СтруктураНастроек.Вставить("О2_QR_КонтрагентИнкассаторДоговор","");
		КонецЕсли;
	Иначе
		СтруктураНастроек.Вставить("О2_QR_КонтрагентИнкассаторДоговор","");
	КонецЕсли; 
	//
	
	
	
	Возврат СтруктураНастроек;
КонецФункции
Функция ПолучитьПочтуКонтрагента(Контрагент)
	ЭлПочта = Новый Массив;
	ЭлПочта.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.АдресЭлектроннойПочтыДомашний));
	ЭлПочта.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.АдресЭлектроннойПочтыРабочий));
	ЭлПочта.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.НайтиПоКоду("ЦБ000023")));
	ЭлПочта.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.НайтиПоКоду("ЦБ000003")));

	Для каждого ЭлПочта Из ЭлПочта Цикл
		Если СтрПодобнаПоРегулярномуВыражению(ЭлПочта,"^[a-zA-Z0-9](?:[a-zA-Z0-9._%+-]*[a-zA-Z0-9_])?@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$") Тогда
			Возврат ЭлПочта;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции
Функция ПолучитьКорректныйТелефонКонтрагента(Контрагент)
	Телефоны = Новый Массив;
	Телефоны.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.ТелефонДомашний));
	Телефоны.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.ТелефонКонтактный));
	Телефоны.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.ТелефонРабочий));
	Телефоны.Добавить(киПолучитьПредставлениеКИ(Контрагент,Справочники.ВидыКонтактнойИнформации.ТелефонСотовый));
	
	Для каждого Телефон Из Телефоны Цикл
		Телефон = СтрЗаменить(Телефон," ","");
		Телефон = СтрЗаменить(Телефон,"+","");
		Телефон = СтрЗаменить(Телефон,"-","");
		Телефон = СтрЗаменить(Телефон,"(","");
		Телефон = СтрЗаменить(Телефон,")","");
		Если СтрПодобнаПоРегулярномуВыражению(Телефон,"^[78]\d{10}$") Тогда
			Возврат Телефон;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции
Функция ПолучитьПредметРасчета(ДокументОснование)

	Если ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.ЗаказНаАвтомобиль") Тогда
		Возврат "Товар";
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.РабочийЛистОтделаСтрахования") Тогда
		Возврат "Услуга";
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.ЗаявкаНаРемонт") Тогда
		Возврат "Услуга";
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.ЗаказНаряд") Тогда
		Возврат "Услуга";	
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.РеализацияТоваров") Тогда
		Возврат "Товар";
	ИначеЕсли ТипЗнч(ДокументОснование) = Тип("ДокументСсылка.СчетНаОплату") И ЗначениеЗаполнено(ДокументОснование.ДокументОснование) Тогда
		Возврат ПолучитьПредметРасчета(ДокументОснование.ДокументОснование);
	Иначе
		Возврат "Услуга";
	КонецЕсли;

КонецФункции
//СТАТУСЫ
Функция ЗаписатьСтатусПлатежа(Статус,ДокументОплаты,ИдПлатежа = Неопределено,ОснованиеДокументаОплаты = Неопределено)
	НоваяЗапись = РегистрыСведений.О2_QR_СтатусыОплаты.СоздатьМенеджерЗаписи();
	НоваяЗапись.Период = ТекущаяДатаСеанса();
	НоваяЗапись.ДокументОплаты = ДокументОплаты.Ссылка;
	Если ОснованиеДокументаОплаты = Неопределено Тогда
		НоваяЗапись.ОснованиеДокументаОплаты = ДокументОплаты.ДокументОснование;
	Иначе
		НоваяЗапись.ОснованиеДокументаОплаты = ОснованиеДокументаОплаты;
	КонецЕсли;
	Если ИдПлатежа = Неопределено Тогда
		НоваяЗапись.ИдПлатежа = ДокументОплаты.О2_QR_ИдПлатежа;
	Иначе
		НоваяЗапись.ИдПлатежа = ИдПлатежа;
	КонецЕсли;
	НоваяЗапись.Статус = Статус;
	НоваяЗапись.Записать();
КонецФункции
#КонецОбласти

#Область QR
Функция ПолучитьQRКОД(СсылкаНаОплату) Экспорт
	ВнешняяКомпонента =  ПодключитьВнешнююКомпонентуПечатиШтрихкода();
	Картинка = ПолучитьКартинку(ВнешняяКомпонента, СсылкаНаОплату);
	ВнешняяКомпонента = Неопределено;
	Возврат Картинка;
КонецФункции
Функция ПодключитьВнешнююКомпонентуПечатиШтрихкода()
	
	// Подлючение компоненты
	Попытка
		Если ПодключитьВнешнююКомпоненту("ОбщийМакет.КомпонентаПечатиШтрихкодов", "Barcode") Тогда
			ВнешняяКомпонента = Новый("AddIn.Barcode.Barcode");
		Иначе
			Сообщить("Не удалось подключить компоненту для печати маркировки.");
			Возврат Неопределено;
		КонецЕсли;
	Исключение
		Сообщить("Не удалось подключить компоненту для печати маркировки.");
		Возврат Неопределено;
	КонецПопытки;
	
	// Если нет возможности рисовать
	Если НЕ ВнешняяКомпонента.ГрафикаУстановлена Тогда
		// То картинку сформировать не сможем
		Возврат Неопределено;
	Иначе
		
		// Установим основные параметры компоненты
		
		// Если в системе установлен шрифт Tahoma
		Если ВнешняяКомпонента.НайтиШрифт("Tahoma") = Истина Тогда
			// Выбираем его как шрифт для формирования картинки
			ВнешняяКомпонента.Шрифт = "Tahoma";
		Иначе
			
			// Шрифт Tahoma в системе отсутствует
			// Обойдем все доступные компоненте шрифты
			Для Сч = 0 По ВнешняяКомпонента.КоличествоШрифтов -1 Цикл
				// Получим очередной шрифт, доступный компоненте
				ТекущийШрифт = ВнешняяКомпонента.ШрифтПоИндексу(Сч);
				// Если шрифт доступен
				Если ТекущийШрифт <> Неопределено Тогда
					// Они и будет шрифтом для формирования штри-кода
					ВнешняяКомпонента.Шрифт = ТекущийШрифт;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// Утановим размер шрифта
		ВнешняяКомпонента.РазмерШрифта = 12;
		
		Возврат ВнешняяКомпонента;
		
	КонецЕсли;
	
КонецФункции
Функция ПолучитьКартинку(ВнешняяКомпонента, Строка) 
	
	// Зададим размер формируемой картинки.
	ВнешняяКомпонента.Ширина = Окр(300);
	ВнешняяКомпонента.Высота = Окр(300);
	ВнешняяКомпонента.АвтоТип = Истина;
	
	ШтрихкодВрем = Строка(Строка); // Преобразуем явно в строку.
	
	//ВнешняяКомпонента.АвтоТип = Ложь;
	ВнешняяКомпонента.ТипКода = 16;
	ВнешняяКомпонента.ОтображатьТекст = Истина;
	// Формируем картинку штрихкода.
	ВнешняяКомпонента.ЗначениеКода = ШтрихкодВрем;
	//// Угол поворота штрихкода.
	//ВнешняяКомпонента.УголПоворота = 0;
	//// Уровень коррекции QR кода (L=0, M=1, Q=2, H=3).
	//ВнешняяКомпонента.УровеньКоррекцииQR = 1;
	//ВнешняяКомпонента.ТипВходныхДанных = 1;
	
	// Сформируем картинку
	ДвоичныеДанныеКартинки = ВнешняяКомпонента.ПолучитьШтрихкод();
	
	// Если картинка сформировалась.
	Если ДвоичныеДанныеКартинки <> Неопределено Тогда
		// Формируем из двоичных данных.
		Возврат Новый Картинка(ДвоичныеДанныеКартинки);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции
#КонецОбласти

#Область ОшибкиAPI   
Функция ПолучитьОписаниеОшибки(КодОшибки, ДопПараметр = Неопределено)

	Соответствияошибок = новый Соответствие;
	
	//Ошибки API
	Соответствияошибок.Вставить("ERR_SERVER","Ошибка соединения. Возможно указан некорректный путь или метод запроса.");
	Соответствияошибок.Вставить("ERR_JSON",	"Не удалось обработать тело запроса как JSON.");
	
	//создание заказа
	Соответствияошибок.Вставить("ERR_ORDER_DATA_INVALID", "Не заполнены обязательные параметры для создания заказа. Проверьте что параметры СкладПолучательID, НомерЗаказаВПриложении - заполнены.");
	Соответствияошибок.Вставить("ERR_ORDER_WAREHOUSE_NOT_FOUND", "Не определен склад-получатель.");
	Соответствияошибок.Вставить("ERR_ORDER_EMPTY", "Невозможно создать пустой заказ");
	Соответствияошибок.Вставить("ERR_ORDER_ITEMS_DATA_INVALID", "Не заполнены обязательные параметры для товаров для создания заказа. Проверьте что параметры external_id, article, brand, quantity и external_warehouse_id  - заполнены.");
	Соответствияошибок.Вставить("ERR_ORDER_ITEMS_RESOURCE_NOT_FOUND","Номенклатура заказа не найдена. "+ ДопПараметр);
	Соответствияошибок.Вставить("ERR_ORDER_ITEMS_WAREHOUSE_NOT_FOUND","Не найден склад по ID.");
	Соответствияошибок.Вставить("ERR_ORDER_ITEMS_WAREHOUSE_EMPTY","Нет товаров на указанных складах. " + ДопПараметр);
	Соответствияошибок.Вставить("ERR_ORDER_CREATE_FAILED", "Ошибка при создании заказа покупателя. Ошибка - " + ДопПараметр);
	Соответствияошибок.Вставить("ERR_ORDER_RESERVE_CREATE_FAILED", "Ошибка при создании резерва под заказа покупателя. Ошибка - " + ДопПараметр);
	
	//Отмена заказа
	Соответствияошибок.Вставить("ERR_ORDER_DOESNT_EXIST",			"Данных не найдено. Заказ не найден.");
	Соответствияошибок.Вставить("ERR_ORDER_ALREADY_CANCELLED", 		"Заказ уже отменен.");
	Соответствияошибок.Вставить("ERR_ORDER_ALREADY_COMPLETED", 		"Заказ реализован. Отменить его нельзя.");
	Соответствияошибок.Вставить("ERR_ORDER_CANCEL_FAILED",			"Ошибка при отмене заказа. Ошибка - " + ДопПараметр);
	Соответствияошибок.Вставить("ERR_ORDER_DOESNT_CREATED_API", 		"Заказ не является заказом O2 API. Отменить его нельзя.");
	
	//статус заказа
	Соответствияошибок.Вставить("ERR_STATES_ORDERS_IDS_INVALID",	"Данных не найдено. Возможно указаны некорректные ID заказов.");
	Соответствияошибок.Вставить("ERR_STATES_REFERENCE_NOT_UNIQUE",	"В списке не уникальные ID заказа");
	Соответствияошибок.Вставить("ERR_STATES_DOESNT_CREATED_API", 		"Заказ не является заказом O2 API. Получить его нельзя.");
	
	
	Если ЗначениеЗаполнено(Соответствияошибок.Получить(КодОшибки)) Тогда 
		Возврат Соответствияошибок.Получить(КодОшибки);
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции
Функция ВернутьОшибку(КодОшибки, ДопПараметр = Неопределено)
	
	Ответ = Новый HTTPСервисОтвет(400);
	
	//Структура ошибки
	СтруктураОтвета = новый Структура;
	МассивОшибок = Новый Массив;
	СтруктураОшибки = Новый Структура;
	
	СтруктураОшибки.Вставить("code",КодОшибки);
	СтруктураОшибки.Вставить("text",ПолучитьОписаниеОшибки(КодОшибки,ДопПараметр));
	
	МассивОшибок.Добавить(СтруктураОшибки);
	
	СтруктураОтвета.Вставить("errors", МассивОшибок);
	
	//Json
	ЗаписьJSON = Новый ЗаписьJSON;			
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON,СтруктураОтвета,);
	ТелоОтвета = ЗаписьJSON.Закрыть();

	Ответ.Заголовки.Вставить("Content-Type","application/json;charset=utf-8");
	Ответ.УстановитьТелоИзСтроки(ТелоОтвета);
	Возврат Ответ;
	
КонецФункции
#КонецОбласти

#Область ЛогированиеЗапросов
Функция ЛогированиеЗапросовHTTPСервисы(Период,Запрос,Ответ=Неопределено,Документ=Неопределено,Ошибка=Неопределено)
		
	Набор = РегистрыСведений.О2_API_ЛогиЗапросов.СоздатьНаборЗаписей();
	Если ЗначениеЗаполнено(Период) Тогда
		Набор.Отбор.Период.Установить(Период);
	Иначе
		Набор.Отбор.Период.Установить(ТекущаяДатаСеанса());
	КонецЕсли;
	
	//Запрос
	ТекстЗаголовкиЗапроса = "";
	Для Каждого Заголовок Из Запрос.Заголовки Цикл
		ТекстЗаголовкиЗапроса = ТекстЗаголовкиЗапроса + Заголовок.Ключ + ": " + Заголовок.Значение + Символы.ПС;
	КонецЦикла;
	
	Набор.Отбор.Метод.Установить(Запрос.HTTPМетод + " " + Запрос.БазовыйURL + Запрос.ОтносительныйURL);
	Набор.Прочитать();
	
	Если Набор.Количество() = 0 тогда
		НоваяЗапись = Набор.Добавить();
	Иначе
		НоваяЗапись = Набор[0];
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Период) Тогда
		НоваяЗапись.Период = Период;
	Иначе
		НоваяЗапись.Период = ТекущаяДатаСеанса();
	КонецЕсли;

	НоваяЗапись.Метод = Запрос.HTTPМетод + " " + Запрос.БазовыйURL + Запрос.ОтносительныйURL;
	НоваяЗапись.ЗаголовкиЗапроса = ТекстЗаголовкиЗапроса;
	НоваяЗапись.ТелоЗапроса = Запрос.ПолучитьТелоКакСтроку("UTF-8");

	
	//Ответ
	Если ТипЗнч(Ответ) = Тип("HTTPСервисОтвет") Тогда  
		ТекстЗаголовкиОтвета = "";
		Для Каждого Заголовок Из Ответ.Заголовки Цикл
			ТекстЗаголовкиОтвета = ТекстЗаголовкиОтвета + Заголовок.Ключ + ": " + Заголовок.Значение + Символы.ПС;
		КонецЦикла;
		НоваяЗапись.ЗаголовкиОтвета = ТекстЗаголовкиОтвета;
		НоваяЗапись.КодОтвета = Ответ.КодСостояния;
		НоваяЗапись.ТелоОтвета = Ответ.ПолучитьТелоКакСтроку();
	КонецЕсли;
		
	
	//Прочая информация
	НоваяЗапись.ОписаниеОшибки = Ошибка;
	НоваяЗапись.Документ = Документ;
	
	Набор.Записать();
КонецФункции
функция ВЖурнал(Значение)
	ЗаписьЖурналаРегистрации("О2 API",УровеньЖурналаРегистрации.Информация,Значение,Строка(Значение),Строка(Значение));
КонецФункции
Функция ЛогированиеЗапросов(Хост,Метод,ПолнаяСсылка,ЗаголовкиЗапроса,ТелоЗапроса,КодОтвета,ЗаголовкиОтвета,ТелоОтвета,Документ)
	//Подготовка заголовков
	//Запроса  
	ТекстЗаголовкиЗапроса = "";
	Для Каждого Заголовок Из ЗаголовкиЗапроса Цикл
		ТекстЗаголовкиЗапроса = ТекстЗаголовкиЗапроса + Заголовок.Ключ + ": " + Заголовок.Значение + Символы.ПС;
	КонецЦикла;
	//Ответа  
	ТекстЗаголовкиОтвета = "";
	Для Каждого Заголовок Из ЗаголовкиОтвета Цикл
		ТекстЗаголовкиОтвета = ТекстЗаголовкиОтвета + Заголовок.Ключ + ": " + Заголовок.Значение + Символы.ПС;
	КонецЦикла;
	
	НоваяЗапись = РегистрыСведений.О2_QR_ЛогиЗапросов.СоздатьМенеджерЗаписи();
	НоваяЗапись.Период = ТекущаяДатаСеанса();
	НоваяЗапись.Метод = Метод + " " + ПолнаяСсылка;
	НоваяЗапись.КодОтвета = КодОтвета;
	НоваяЗапись.Документ = Документ;
	НоваяЗапись.ЗаголовкиЗапроса = ТекстЗаголовкиЗапроса;
	НоваяЗапись.ТелоЗапроса = ТелоЗапроса;
	НоваяЗапись.ЗаголовкиОтвета = ТекстЗаголовкиОтвета;
	НоваяЗапись.ТелоОтвета = ТелоОтвета;
	НоваяЗапись.Записать();
КонецФункции
#КонецОбласти

#Область ОбработкаJSON
Функция ПолучитьСтруктуруИзJSON(Текст)
	Попытка
		//Попытаемся прочитать JSON
		ЧтениеJson = Новый ЧтениеJSON;
		ЧтениеJson.УстановитьСтроку(Текст);
		ДанныеСтруктура = ПрочитатьJSON(ЧтениеJson);
		Возврат ДанныеСтруктура;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
КонецФункции
//Получает данные из структуры если ключ существует
Функция ПолучитьЗначениеЕслиСуществуетИЗаполнено(Данные,Наименование) Экспорт
	Если НЕ ЗначениеЗаполнено(Данные) Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(Данные) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Данные.Свойство(Наименование) И ЗначениеЗаполнено(Данные[Наименование]) Тогда
		Возврат Данные[Наименование];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции
//Получает данные из структуры по пути "ключ1.ключ2" если ключи сущестуют
Функция ПолучитьЗначениеЕслиСуществуетИЗаполненоПоПути(Данные,Путь) Экспорт
	МассивПути = СтрРазделить(Путь,".",Ложь);
	ТекущиеДанные = Данные;
	Для Каждого ТекущийКлюч из МассивПути Цикл
		ТекущиеДанные = ПолучитьЗначениеЕслиСуществуетИЗаполнено(ТекущиеДанные,ТекущийКлюч); 		
		Если ТекущиеДанные = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;
	Возврат ТекущиеДанные;
КонецФункции
//упр вызов функции ПолучитьЗначениеЕслиСуществуетИЗаполненоПоПути
Функция ПолучитьПоПути(Данные,Путь)
	Возврат ПолучитьЗначениеЕслиСуществуетИЗаполненоПоПути(Данные,Путь);
КонецФункции	
Функция ПолучитьМассивСтруктурИзТаблицы(Таблица)
	МассивТЗ = Новый Массив;
	Для каждого СтрокаТЗ Из Таблица Цикл
		СтруктураСтроки = Новый Структура;
		Для каждого Колонка Из Таблица.Колонки Цикл
		    СтруктураСтроки.Вставить(Колонка.Имя, СтрокаТЗ[Колонка.Имя]);
		КонецЦикла;
		МассивТЗ.Добавить(СтруктураСтроки);
	КонецЦикла;
	Возврат МассивТЗ;
КонецФункции
#КонецОбласти

#Область HTTPЗапросыИДанные
// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка - схема из URI.
//   * Логин         - Строка - логин из URI.
//   * Пароль        - Строка - пароль из URI.
//   * ИмяСервера    - Строка - часть <хост>:<порт> из URI.
//   * Хост          - Строка - хост из URI.
//   * Порт          - Строка - порт из URI.
//   * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> из URI.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@", НаправлениеПоиска.СКонца);
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не ТолькоЦифрыВСтроке(Порт) Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции
//HTTP запрос
Функция ВыполнитьHTTPЗапрос(URL, МетодЗапроса = "GET", ТелоЗапроса = "", Заголовки = Неопределено, Авторизация = Неопределено,SSL = Неопределено,Документ = Неопределено) Экспорт
	
	ОшибкаЗапроса = Неопределено;
	
	СтруктураURL = СтруктураURI(URL);
	
	Если SSL = Неопределено Тогда
		SSL = Новый ЗащищенноеСоединениеOpenSSL;	
	КонецЕсли;
	
	HTTPСоединение = Новый HTTPСоединение(СтруктураURL.Хост,СтруктураURL.Порт,,,,,SSL);
	HTTPЗапрос = Новый HTTPЗапрос(СтруктураURL.ПутьНаСервере);
	
	//Заголовки
	Если ЗначениеЗаполнено(Заголовки) И ТипЗнч(Заголовки) = Тип("Соответствие") тогда
		HTTPЗапрос.Заголовки = Заголовки;		
	КонецЕсли;
	//Обяз хост
	Если HTTPЗапрос.Заголовки.Получить("Host") = Неопределено Тогда
		HTTPЗапрос.Заголовки.Вставить("Host",СтруктураURL.Хост);	
	КонецЕсли;
	//Обяз ассерт
	Если HTTPЗапрос.Заголовки.Получить("Accept") = Неопределено Тогда
		HTTPЗапрос.Заголовки.Вставить("Accept","application/json");	
	КонецЕсли;
	
	//Авторизация
	Если ЗначениеЗаполнено(Авторизация) Тогда
		Если ТипЗнч(Авторизация) = тип("ТокенДоступа") Тогда
			HTTPЗапрос.ДобавитьТокенДоступа(Авторизация);			
		ИначеЕсли ТипЗнч(Авторизация) = тип("Строка") Тогда
			 HTTPЗапрос.Заголовки.Вставить("Authorization",Авторизация);
		КонецЕсли;
	КонецЕсли;
	
	//Тело запроса
	Если ЗначениеЗаполнено(ТелоЗапроса) И ТипЗнч(ТелоЗапроса) = Тип("Строка") Тогда
		HTTPЗапрос.УстановитьТелоИзСтроки(ТелоЗапроса,,ИспользованиеByteOrderMark.НеИспользовать); 
		HTTPЗапрос.Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded")
	ИначеЕсли ЗначениеЗаполнено(ТелоЗапроса) И ТипЗнч(ТелоЗапроса) = Тип("Структура") Тогда
		ЗаписьJSON = Новый ЗаписьJSON;			
		ЗаписьJSON.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJson.Нет));
		ЗаписатьJSON(ЗаписьJSON,ТелоЗапроса,);
		ТелоЗапроса = ЗаписьJSON.Закрыть();

		HTTPЗапрос.УстановитьТелоИзСтроки(ТелоЗапроса,"UTF-8",ИспользованиеByteOrderMark.НеИспользовать);
		HTTPЗапрос.Заголовки.Вставить("Content-Type","application/json");
	КонецЕсли;
	
	//Выполнение запроса 
	Попытка
		Тестирование = Константы.О2_QR_Тестирование.Получить();
		
		Если Тестирование <> Истина Тогда
			ОтветHTTP = HTTPСоединение.ВызватьHTTPМетод(МетодЗапроса, HTTPЗапрос); 
			КодСостояния = ОтветHTTP.КодСостояния;
			ЗаголовкиОтвета = ОтветHTTP.Заголовки;
			ТекстОтвета = ОтветHTTP.ПолучитьТелоКакСтроку();
			ДанныеСтруктура = Неопределено;
		Иначе
			КодСостояния = 200;
			ЗаголовкиОтвета = Новый Структура;
			ДанныеСтруктура = Неопределено;
			Если ЗначениеЗаполнено(ТелоЗапроса) Тогда
				ТекстОтвета = "{""payment_id"":6,""qr_code_url"":""https://qr.nspk.ru/AS2R001CCVGQPPI08M8BF861LLJUU142?type=01&bank=100000000008&crc=CC0B""}";
			Иначе
				ТекстОтвета = "{""payment_ttl"":12}";
			КонецЕсли;
		КонецЕсли;
			
		Попытка
			//Попытаемся прочитать JSON
			ЧтениеJson = Новый ЧтениеJSON;
			ЧтениеJson.УстановитьСтроку(ТекстОтвета);
			ДанныеСтруктура = ПрочитатьJSON(ЧтениеJson);
		Исключение
		КонецПопытки;
		
		ЛогированиеЗапросов(СтруктураURL.Хост,МетодЗапроса,URL,HTTPЗапрос.Заголовки,ТелоЗапроса,КодСостояния,ЗаголовкиОтвета,ТекстОтвета,Документ);
			
		Если ЗначениеЗаполнено(ДанныеСтруктура) Тогда
			Возврат ДанныеСтруктура;
		ИначеЕсли КодСостояния = 302 Тогда
			Возврат ЗаголовкиОтвета["location"]; 
		Иначе
			Возврат Неопределено;
		КонецЕсли;
		
	Исключение
		Сообщить("Ошибка выполнения запроса!");
		ТекстОшибки = ОписаниеОшибки();
		Сообщить(ТекстОшибки);
		
		ВторойТекстОшибки = "";
		ВторойТекстОшибки = ВторойТекстОшибки + ?(ЗначениеЗаполнено(КодСостояния),"КодСостояния - " + Строка(КодСостояния) + Символы.ПС,"");
		ВторойТекстОшибки = ВторойТекстОшибки + ?(ЗначениеЗаполнено(ТекстОтвета),"ТекстОтвета - " + Строка(ТекстОтвета) + Символы.ПС,"");
		Если ЗначениеЗаполнено(ВторойТекстОшибки) Тогда
			Сообщить(ВторойТекстОшибки);
		КонецЕсли;
		Возврат Неопределено;
	КонецПопытки;
КонецФункции
//Возвращает Basic Base64(Логин:Пароль) 
Функция ПолучитьАвторизациюКакBASIC(Логин,Пароль)
	Возврат "Basic "+Base64Строка(ПолучитьДвоичныеДанныеИзСтроки(Логин + ":" + Пароль));	
КонецФункции 
//Возвращает Bearer
Функция ПолучитьАвторизациюКакBearer(Токен)
	Возврат "Bearer "+Токен;	
КонецФункции
//добавляет к url структуру в виде ?param1=1&param2=2
Функция ДобавитьBodyURLEncoded(URL, Params)
	URL = URL + "?";
	Для Каждого Параметр из Params Цикл
		URL = URL + Параметр.Ключ + "=" + Параметр.Значение + "&";
	КонецЦикла;
	Возврат URL;
КонецФункции
Функция ВернутьBodyURLEncoded(Params)
	URL = "";
	Для Каждого Параметр из Params Цикл
		URL = URL + Параметр.Ключ + "=" + Параметр.Значение + "&";
	КонецЦикла;
	Возврат URL;
КонецФункции
//Конвертирует структуру в строку в формате JSON
Функция СтруктуруВJSONТекст(JSON)
	Попытка
		JSONобъект = новый ЗаписьJSON;
		JSONобъект.УстановитьСтроку();
		ЗаписатьJSON(JSONобъект,JSON);
		JSONТекстом = JSONобъект.Закрыть(); 
		Возврат JSONТекстом;
	Исключение
		JSONТекстом = "Не удалось получить JSON конкретного объекта";
		Возврат JSONТекстом;
	КонецПопытки;
КонецФункции
// Нормализует дату в формате 2024-12-03T21:00:00Z в дату 1с
Функция JSONДатаНормализовать(ДатаJSON)
	ДатаJSON = СтрЗаменить(ДатаJSON,"Z","");
	ДатаJSON = XMLЗначение(Тип("Дата"),ДатаJSON);
	Возврат ДатаJSON;	
КонецФункции
// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//  Устаревший       - Булево - устаревший параметр, не используется.
//  ПробелыЗапрещены - Булево - если Ложь, то в строке допустимо наличие пробелов.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры или пустая, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("0123abc"); // Ложь
//  Результат = СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке("01 2 3",, Ложь); // Истина
//
Функция ТолькоЦифрыВСтроке(Знач Значение, Знач Устаревший = Истина, Знач ПробелыЗапрещены = Истина) Экспорт

	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;

	Если Не ПробелыЗапрещены Тогда
		Значение = СтрЗаменить(Значение, " ", "");
	КонецЕсли;

	Если СтрДлина(Значение) = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9",
		"")) = 0;

КонецФункции
Функция ОбработкаОшибокЗапросов(ДанныеСтруктура,ТекстОтвета,ЗаголовкиОтвета,КодСостояния,СообщатьЛи = Истина)
	//Если запрос неуспешен и ответ в JSON
	Если КодСостояния <> 200 И (ТипЗнч(ДанныеСтруктура) = Тип("Структура") И ДанныеСтруктура.Свойство("error")) тогда
		//ЕстьОшибка
		КодОшибки  = "";
		ОписаниеОшибки  = "";
		Если ДанныеСтруктура.Свойство("error") Тогда
			//Есть КодОшибки
			КодОшибки = ДанныеСтруктура["error"];
		КонецЕсли;
		Если ДанныеСтруктура.Свойство("error_description") Тогда
			//Есть ОписаниеОшибки
			ОписаниеОшибки = ДанныеСтруктура["error_description"];
		КонецЕсли;
	КонецЕсли;
	//Если это редирект то надо проверить есть ли в ссылке ошибка
	Если ЗначениеЗаполнено(ЗаголовкиОтвета.Получить("location")) Тогда
		//Запросим блоки регуляркой
		ВремКодОшибки = СтрНайтиПоРегулярномуВыражению(ЗаголовкиОтвета.Получить("location"),"error=([a-zA-Z0-9_]{1,1000})&").ПолучитьГруппы();
		Если ВремКодОшибки.Количество() > 0 Тогда КодОшибки = ВремКодОшибки[0].Значение; КонецЕсли;
		ВремОписаниеОшибки = СтрНайтиПоРегулярномуВыражению(ЗаголовкиОтвета.Получить("location"),"error_description=(.{1,1000})&").ПолучитьГруппы();
		Если ВремОписаниеОшибки.Количество() > 0 Тогда ОписаниеОшибки = ВремОписаниеОшибки[0].Значение; КонецЕсли;
		ОписаниеОшибки = РаскодироватьСтроку(ОписаниеОшибки, СпособКодированияСтроки.URLВКодировкеURL);
		ОписаниеОшибки = СтрЗаменить(ОписаниеОшибки,"+"," ");
	КонецЕсли;
	
	//Если это ошибка бизнес логики
	Если КодСостояния <> 200 И (ТипЗнч(ДанныеСтруктура) = Тип("Структура") И ДанныеСтруктура.Свойство("errorCode")) Тогда
		//ЕстьОшибка
		КодОшибки  = "";
		ОписаниеОшибки  = "";
		Если ДанныеСтруктура.Свойство("errorCode") Тогда
			//Есть КодОшибки
			КодОшибки = ДанныеСтруктура["errorCode"];
		КонецЕсли;
		Если ДанныеСтруктура.Свойство("errorDesc") Тогда
			//Есть ОписаниеОшибки
			ОписаниеОшибки = ДанныеСтруктура["errorDesc"];
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(КодОшибки) ИЛИ ЗначениеЗаполнено(ОписаниеОшибки) Тогда
		ТекстСообщения = "Получен ответ с ошибкой." + ?(ЗначениеЗаполнено(КодОшибки),Символы.ПС+"Код ошибки: "+КодОшибки,"") + ?(ЗначениеЗаполнено(ОписаниеОшибки),Символы.ПС+"Описание ошибки: "+ОписаниеОшибки,"");
		Сообщить(ТекстСообщения);
		Возврат ТекстСообщения;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции
#КонецОбласти

#Область ОбработчикиAPI
Функция ВсеОстальныеЛюбой(Запрос) Экспорт
	Ответ = ВернутьОшибку("ERR_SERVER");
	ЛогированиеЗапросовHTTPСервисы(Неопределено,Запрос,Ответ,,"Некорректный путь или метод запроса.");
	Возврат Ответ;
КонецФункции

Функция update_payment_statusPOST(Запрос) Экспорт
	Ответ = ВернутьОшибку("ERR_SERVER");
	ЛогированиеЗапросовHTTPСервисы(Неопределено,Запрос,Ответ,,"Некорректный путь или метод запроса.");
	Возврат Ответ;
КонецФункции
#КонецОбласти   

#Область ПрочиеФункцииДляДокументов

#КонецОбласти   