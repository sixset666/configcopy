//ДОПОЛНИТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура сфСообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = обСформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // сфСообщитьОбОшибке()

// Делает запись в регистр сведений РежимыРаботыПользователей с параметрами текущего сеанса
//
Процедура ЗаписатьДанныеСеансаОбработчикаЗаданий(Пользователь=НЕОПРЕДЕЛЕНО, НомерСоединения=0, Режим=2, Начало=НЕОПРЕДЕЛЕНО, Конец=НЕОПРЕДЕЛЕНО, ТекстСообщения="") Экспорт
	Если НЕ ЗначениеЗаполнено(Пользователь) Тогда
		Пользователь = ПараметрыСеанса.Пользователь;
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(НомерСоединения) Тогда
		НомерСоединения = НомерСоединенияИнформационнойБазы();
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(Начало) Тогда
		Начало = ТекущаяДата();
	КонецЕсли;
	Если ПустаяСтрока(ТекстСообщения) Тогда
		ТекстСообщения = "C " +	Формат(Начало,"ДФ='дд.ММ.гггг ЧЧ:мм:сс'") + ?(Режим=2," был подключен обработчик регламентных операций", " установлен режим " + Режим) + " (Номер соединения: " + НомерСоединения + ")";
	КонецЕсли;
	Попытка // Отпишемся в регистр что мы такие вот взяли на себя обработку заданий
		НаборЗаписей = РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
		НаборЗаписей.Отбор.НомерСоединения.Установить(НомерСоединения);
		НаборЗаписей.Отбор.Режим.Установить(Режим); // 2 = Выполняем регламентную операцию
		НаборЗаписей.Прочитать();
		Если НаборЗаписей.Количество() = 0 Тогда
			Запись = НаборЗаписей.Добавить();
			Запись.Пользователь		= ПараметрыСеанса.Пользователь;
			Запись.НомерСоединения	= НомерСоединения;
			Запись.Режим 			= 2;
		Иначе
			Запись = НаборЗаписей[0];
		КонецЕсли;
		Запись.Начало = Начало;
		Если ЗначениеЗаполнено(Конец) Тогда
			Запись.Конец = Конец;
		КонецЕсли;
		Запись.Текст = ТекстСообщения;
		НаборЗаписей.Записать();
	Исключение
	КонецПопытки;
	
КонецПроцедуры // ЗаписатьДанныеСеансаОбработчикаЗаданий()

// Удаляет записи в регистре сведений РежимыРаботыПользователей с параметрами текущего сеанса
//
Процедура УдалитьДанныеСеансаОбработчикаЗаданий(Пользователь=НЕОПРЕДЕЛЕНО, НомерСоединения=НЕОПРЕДЕЛЕНО, Режим=2,УдалятьНеактивные = Ложь) Экспорт
	Если НЕ ЗначениеЗаполнено(Пользователь) Тогда
		Пользователь = ПараметрыСеанса.Пользователь;
	КонецЕсли;
	Попытка // Вычеркнем себя из списка выполняющих регламентные операции
		НаборЗаписей = РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
		НаборЗаписей.Отбор.Режим.Установить(Режим); // 2 = Выполняем регламентную операцию
		
		Если УдалятьНеактивные Тогда
			МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
			Если МассивСоединений = Неопределено Тогда
				ТекстСообщения = "При удалении записей обновления прав не удалось получить список соединений с текущей базой - возможно нет права на получение списка активных пользователей";
				ЗаписьЖурналаРегистрации("Обновление прав", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			КонецЕсли;
			СписокСоединений = Новый СписокЗначений;
			Для Инд = 0 По МассивСоединений.ВГраница() Цикл
				СписокСоединений.Добавить(МассивСоединений[Инд].НомерСоединения);
			КонецЦикла;	
			
			Запрос = Новый Запрос;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	РежимыРаботы.НомерСоединения
			|ИЗ
			|	РегистрСведений.РежимыРаботыПользователей КАК РежимыРаботы
			|ГДЕ
			|	РежимыРаботы.Пользователь = &Пользователь
			|	И РежимыРаботы.Режим = &Режим
			|	И НЕ РежимыРаботы.НомерСоединения В(&СписокСоединений)";
			Запрос.УстановитьПараметр("Пользователь",Пользователь);
			Запрос.УстановитьПараметр("Режим",Режим);
			Запрос.УстановитьПараметр("СписокСоединений",СписокСоединений);
			Выборка = Запрос.Выполнить().Выбрать();
			Пока Выборка.Следующий() Цикл
			    НаборЗаписей.Отбор.НомерСоединения.Установить(Выборка.НомерСоединения);
				НаборЗаписей.Прочитать();
				Если НаборЗаписей.Количество() <> 0 Тогда
					НаборЗаписей.Очистить();
					НаборЗаписей.Записать();
				КонецЕсли; 
			КонецЦикла; 
			
		Иначе
			Если НомерСоединения <> Неопределено Тогда
				НаборЗаписей.Отбор.НомерСоединения.Установить(НомерСоединения);
			КонецЕсли;
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() <> 0 Тогда
				НаборЗаписей.Очистить();
				НаборЗаписей.Записать();
			КонецЕсли;
		КонецЕсли; 
	Исключение
		//Сообщить(ИнформацияОбОшибке().Описание,СтатусСообщения.Важное);
	КонецПопытки;
КонецПроцедуры // УдалитьДанныеСеансаОбработчикаЗаданий()

// Записывает в регистр РежимыРаботыПользователей информацию
// для обновления прав каждого активного пользователя
//
Процедура сфЗаписатьДанныеСеансаОбновитьПрава() Экспорт
	
	// получим список активных пользователей
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	Если МассивСоединений = Неопределено Тогда
		ТекстСообщения = "При записи обновления прав не удалось получить список соединений с текущей базой - возможно нет права на получение списка активных пользователей";
		ЗаписьЖурналаРегистрации("Обновление прав", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
		Результат = Ложь;
		Возврат;
	КонецЕсли;
	
	Для Инд = 0 По МассивСоединений.ВГраница() Цикл
		ТекСоединение = МассивСоединений[Инд];
		Если НЕ ТекСоединение.ИмяПриложения = "1CV8" Тогда
			Продолжить;
		КонецЕсли; 
		Если обЗначениеНеЗаполнено(ТекСоединение.Пользователь) Тогда
			Продолжить;
		КонецЕсли; 
		// пишем в регистр
		ТекПользователь = Справочники.Пользователи.НайтиПоКоду(ТекСоединение.Пользователь.Имя);
		Если ТекПользователь.Пустая() Тогда
			Продолжить;
		КонецЕсли; 
		ТекНомерСоединения = ТекСоединение.НомерСоединения;
		Если ТекНомерСоединения = НомерСоединенияИнформационнойБазы() Тогда
		    Продолжить; // самих себя не будем оповещать
		КонецЕсли; 
		Режим = 3;
		Попытка 
			НаборЗаписей = РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Пользователь.Установить(ТекПользователь);
			НаборЗаписей.Отбор.НомерСоединения.Установить(ТекНомерСоединения);
			НаборЗаписей.Отбор.Режим.Установить(Режим); 
			НаборЗаписей.Прочитать();
			Если НаборЗаписей.Количество() = 0 Тогда
				Запись = НаборЗаписей.Добавить();
				Запись.Пользователь		= ТекПользователь;
				Запись.НомерСоединения	= ТекНомерСоединения;
				Запись.Режим 			= Режим;
			Иначе
				Запись = НаборЗаписей[0];
			КонецЕсли;
			Запись.Начало = ТекущаяДата();
			ТекстСообщения = "C " +	Формат(Запись.Начало,"ДФ='дд.ММ.гггг ЧЧ:мм:сс'") + " был подключен обработчик обновления прав, установлен режим " + СокрЛП(Режим) + " (Номер соединения: " + СокрЛП(ТекНомерСоединения) + ")";
			Запись.Текст = ТекстСообщения;
			НаборЗаписей.Записать();
		Исключение
		КонецПопытки;
	КонецЦикла; 

КонецПроцедуры
 
//ПЛАНИРОВЩИК ОБРАБОТКИ РЕЖИМОВ ОТКЛЮЧЕНИЯ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда
	
// Процедура подключает обработчик ожидания КонтрольРежимаЗавершенияРаботыПользователей
//Параметры:
//			Принудительно - булево, когда Истина режим контроля будет установлен обязательно
//									когда Ложь в зависимости от того зашел ли пользователь
//									в уже заблокированную базу (значит знал пароль!) или нет
Процедура сфУстановитьКонтрольРежимаЗавершенияРаботыПользователей(Принудительно = Ложь)  Экспорт
	Если НЕ Принудительно Тогда	// Принудительно когда нужно установить контроль невзирая ни на что
		// А без принудительного режима проявим интеллектуальность и проверим что если пользователь 
		//зашел в уже заблокированную базу, значит сам позаботится о том чтобы завершить свой сеанс
		РежимБлокировки = ПолучитьБлокировкуУстановкиСоединений();
		Если РежимБлокировки.Установлена Тогда
			Возврат; // не будем устанавливать контроль, парень должен сам знать что он делает
		КонецЕсли;
	КонецЕсли;	
	// Иначе нужно периодически контролировать включения данного режима чтобы не помешать
	// регламентным операциям с базой данных
	ПодключитьОбработчикОжидания("сфКонтрольРежимаЗавершенияРаботыПользователей", 45); // 60 много ждать приходиться, а 30 маловато чтобы пользователь успел что-то сделать полезного между предупреждениями
КонецПроцедуры // сфУстановитьКонтрольРежимаЗавершенияРаботыПользователей 

#КонецЕсли

// Обработчик ожидания отключения пользователей
// Процедура выполняет отключение пользователей от информационной 
//	в случае установки специального режима (блокировка соединений с БД)
//
Процедура сфКонтрольРежимаЗавершенияРаботыПользователей() Экспорт

	ТекущийМоментСервер = сфТекущаяДатаСервера();
	#Если Клиент Тогда
	ТекПользователь = ПараметрыСеанса.Пользователь;
	РежимБлокировки = ПолучитьБлокировкуУстановкиСоединений();
	Если РежимБлокировки.Установлена Тогда
		// 1. БЛОКИРОВКА
		
		Если ТекПользователь = Справочники.Пользователи.Робот Тогда
			// Вычеркнем себя из списка выполняющих регламентные операции
			УдалитьДанныеСеансаОбработчикаЗаданий(ТекПользователь,НомерСоединенияИнформационнойБазы(),2);	
			// Исходим из того что за сеансом Робота никто не наблюдает и запрашивать что-либо бесполезно
			ЗавершитьРаботуСистемы(Ложь, Истина); // Если это был Робот и делал что-то полезное пусть перезапустится и продолжит когда опять будет можно
			Возврат;
		КонецЕсли;
		
		// Считаем параметры блокировки
		ВремяНачалаБлокировки = РежимБлокировки.Начало;
		СообщениеАдминистратора = РежимБлокировки.Сообщение;
		Если ПустаяСтрока(СообщениеАдминистратора) Тогда
			СообщениеАдминистратора = СокрЛП(Константы.СообщениеОБлокировкеБазы.Получить());
		КонецЕсли;
		Если ПустаяСтрока(СообщениеАдминистратора) Тогда
			СообщениеАдминистратора	= 	"
										| База данных ЗАКРЫТА на регламентное обслуживание.
										|
										|ВНИМАНИЮ тех, кто еще пока продолжает свою работу:
										|Администратор просит выйти из базы самостоятельно.
										|  Через несколько минут ваш сеанс будет завершен
										|автоматически в принудительном режиме!
										|";
									КонецЕсли;
									
		Если ЗначениеЗаполнено(ВремяНачалаБлокировки) Тогда
			// 1.1 В основе время начала блокировки
			
			// а теперь проверим, не "хитрит" ли пользователь, переведя у себя время...
			Если ЗначениеЗаполнено(ТекущийМоментСервер) Тогда
			    ТекущийМомент = ТекущийМоментСервер;
			Иначе	
			    ТекущийМомент = ТекущаяДата();
			КонецЕсли; 
			
			Если (ТекущийМомент + 6 * 45) < ВремяНачалаБлокировки Тогда
				Возврат; // слишком рано - зачем зря надоедать пользователям "всякими ненужными" сообщениями
			КонецЕсли;
			
			// если указан таймаут, возьмем его, иначе общее время - 300 сек.
			Попытка
				ИнтервалОжидания = Число(РежимБлокировки.Параметр);
			Исключение
				ИнтервалОжидания = Константы.ТаймаутЗавершенияРаботыПользователей.Получить();
			КонецПопытки;
			
			ЧастьИнтервала = ИнтервалОжидания / 5;
			
			ВремяЗавершенияРаботыСистемы = ВремяНачалаБлокировки + 5 * ЧастьИнтервала;
			ВремяЖесткогоВыхода			 = ВремяНачалаБлокировки + 3 * ЧастьИнтервала;
			ВремяМягкогоВыхода			 = ВремяНачалаБлокировки + 2 * ЧастьИнтервала;
			
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Информация, , ,
			"Время завершения работы системы: " + СокрЛП(ВремяЗавершенияРаботыСистемы)
			+ ",  Текущий момент: " + СокрЛП(ТекущийМомент)
			+ ",  Время жесткого выхода: " + СокрЛП(ВремяЖесткогоВыхода)
			+ ",  Время мягкого выхода: " + СокрЛП(ВремяМягкогоВыхода));
			
			Если ТекущийМомент >= ВремяЗавершенияРаботыСистемы Тогда
				ПрекратитьРаботуСистемы(Истина);
			ИначеЕсли ТекущийМомент >= ВремяЖесткогоВыхода Тогда
				Предупреждение("Работа системы завершается " + ВремяЖесткогоВыхода + Символы.ПС + СообщениеАдминистратора, 25);
				ЗавершитьРаботуСистемы(Ложь, Истина);
			ИначеЕсли ТекущийМомент >= ВремяМягкогоВыхода Тогда
				Предупреждение("Работа системы завершается " + ВремяЖесткогоВыхода + Символы.ПС + СообщениеАдминистратора, 25);
				ЗавершитьРаботуСистемы(Истина, Истина);
			Иначе
				Предупреждение("Работа системы будет завершена " + ВремяЖесткогоВыхода + Символы.ПС + СообщениеАдминистратора, 25);
			КонецЕсли;
			
		Иначе 
			// 1.2 время не назначено - в основе кол-во выданных предупреждений 
			Предупреждение(СообщениеАдминистратора,25);
			Попытка СтрРежимРаботы = СокрЛП(ПараметрыСеанса.РежимРаботы); Исключение СтрРежимРаботы = ""; КонецПопытки;
			ПозицияМаркераСчетчика = Найти(СтрРежимРаботы,"W");
			Если ПозицияМаркераСчетчика = 0 Тогда
				СчетчикПредупреждений = 0;
			Иначе
				Попытка
					СчетчикПредупреждений = Число(Сред(СтрРежимРаботы,ПозицияМаркераСчетчика+1,1));
				Исключение
					СчетчикПредупреждений = 0;
				КонецПопытки;
			КонецЕсли;
			// Увеличим счетчик выданных предупреждений
			СчетчикПредупреждений = СчетчикПредупреждений + 1;
			Если (ПозицияМаркераСчетчика > 0) Тогда
				ПараметрыСеанса.РежимРаботы = Лев(СтрРежимРаботы,ПозицияМаркераСчетчика-1)+ "W" + СчетчикПредупреждений + Сред(СтрРежимРаботы,ПозицияМаркераСчетчика+2);
			Иначе
				ПараметрыСеанса.РежимРаботы = СтрРежимРаботы + "W" + СчетчикПредупреждений;
			КонецЕсли;
			// В зависимости от числа уже выданных предупреждений завершаем мягко или жестко
			Если 		(СчетчикПредупреждений >= 5) Тогда
				ПрекратитьРаботуСистемы(Истина);		// Совсем жестоко
			ИначеЕсли 	(СчетчикПредупреждений >= 3) Тогда
				ЗавершитьРаботуСистемы(Ложь, Истина); 	// теперь уже жестко, исходим из того что если не робот а человек-администратор, то он в состоянии был отменить свой автовыход до этого момента
			ИначеЕсли	(СчетчикПредупреждений >= 2) Тогда
				ЗавершитьРаботуСистемы(Истина, Истина);	// сначала мягко, а до того вообще одни только предупреждения были
			КонецЕсли;
			
		КонецЕсли;			
		
	Иначе 
		// 2. РЕЖИМ РАБОТЫ 
		// 1 - отключить с предупреждением
		// 4 - отключить немедленно
		Запрос = Новый Запрос;
		Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
		               |	РежимРаботы.Текст КАК Сообщение,
		               |	РежимРаботы.Режим КАК Режим
		               |ИЗ
		               |	РегистрСведений.РежимыРаботыПользователей КАК РежимРаботы
		               |ГДЕ
		               |	РежимРаботы.Пользователь = &Пользователь
		               |	И (РежимРаботы.Режим = 1
		               |			ИЛИ РежимРаботы.Режим = 4)
		               |
		               |УПОРЯДОЧИТЬ ПО
		               |	Режим УБЫВ";
		Запрос.УстановитьПараметр("Пользователь",ТекПользователь);
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда
			Возврат;
		КонецЕсли;
		Выборка=РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Если Выборка.Режим = 4 Тогда
			// без перезапуска, иначе будет повторный запуск сеанса с послед.отключением
			// (в отличие от блокировки, где повтора не будет)
			ПрекратитьРаботуСистемы(Ложь);
			Возврат;
		КонецЕсли;

		// предупредим пользователя		
		СообщениеАдминистратора = Выборка.Сообщение;
		Если ПустаяСтрока(СообщениеАдминистратора) Тогда
			СообщениеАдминистратора = 	" Администратор ВРЕМЕННО ЗАПРЕТИЛ Вам работать 
			|в базе и просит самостоятельно закрыть ее.
			| ВНИМАНИЕ! Через несколько минут Ваш сеанс будет 
			|завершен автоматически в принудительном режиме!";
		КонецЕсли;
		// время не назначено - будем считать что блокировка ужа началась 
		Предупреждение(СообщениеАдминистратора,15);
		// определяем количество уже выданных предупреждений
		Попытка СтрРежимРаботы = СокрЛП(ПараметрыСеанса.РежимРаботы); Исключение СтрРежимРаботы = ""; КонецПопытки;
		ПозицияМаркераСчетчика = Найти(СтрРежимРаботы,"W");
		Если ПозицияМаркераСчетчика = 0 Тогда
			СчетчикПредупреждений = 0;
		Иначе
			Попытка
				СчетчикПредупреждений = Число(Сред(СтрРежимРаботы,ПозицияМаркераСчетчика+1,1));
			Исключение
				СчетчикПредупреждений = 0;
			КонецПопытки;
		КонецЕсли;
		// Увеличим счетчик выданных предупреждений
		СчетчикПредупреждений = СчетчикПредупреждений + 1;
		Если (ПозицияМаркераСчетчика > 0) Тогда
			ПараметрыСеанса.РежимРаботы = Лев(СтрРежимРаботы,ПозицияМаркераСчетчика-1)+ "W" + СчетчикПредупреждений + Сред(СтрРежимРаботы,ПозицияМаркераСчетчика+2);
		Иначе
			ПараметрыСеанса.РежимРаботы = СтрРежимРаботы + "W" + СчетчикПредупреждений;
		КонецЕсли;
		// В зависимости от числа уже выданных предупреждений завершаем мягко или жестко
		Если (СчетчикПредупреждений >= 5) Тогда
			ПрекратитьРаботуСистемы(Ложь); // Совсем жестоко
		ИначеЕсли  (СчетчикПредупреждений >= 3) Тогда
			ЗавершитьРаботуСистемы(Ложь, Ложь); 	// теперь уже жестко, исходим из того что если не робот а человек-администратор, то он в состоянии был отменить свой автовыход до этого момента 
		ИначеЕсли (СчетчикПредупреждений >= 2) Тогда
			ЗавершитьРаботуСистемы(Истина, Ложь);	// сначала мягко, а до того только предупреждения были
		КонецЕсли;
		
	КонецЕсли;
	#КонецЕсли
КонецПроцедуры // сфКонтрольРежимаЗавершенияРаботыПользователей

#Если Сервер Тогда
	
// Возвращает текущую дату на сервере
//
// Параметры
//  Нет
//
// Возвращаемое значение:
//   Дата 
//
Функция сфТекущаяДатаСервера() Экспорт

	Возврат ТекущаяДата();
	
КонецФункции // ТекущаяДатаСервера()

// Функция возвращает каталог временных файлов сервера
Функция сфПолучитьКаталогВременныхФайловНаСервере() Экспорт
	
	Возврат КаталогВременныхФайлов();
		
КонецФункции

#КонецЕсли

// ОБРАБОТКА ПАРАМЕТРОВ ЗАПУСКА

#Если Клиент Тогда
	
// Обработка параметров запуска программы 
// параметры обрабатываются только предопределенным пользователем "Робот"
// функция возвращает Истина в случае если параметр обработан ИЛИ требуется
// немедленно завершение работы системы
//
// Параметры
// 	СтрокаПараметровЗапуска - Строка. Текущий параметр запуска
// 	ЗапускДоОбновления - Булево. Флаг обработки параметра запуска до выполнения обновления ИБ
//
// Возвращаемое значение
//   Булево. Флаг успешной обработки параметра запуска
//
Функция сфОбработатьПараметрЗапуска(СтрокаПараметровЗапуска,ЗапускДоОбновления=Истина) Экспорт
	
	// есть ли параметры запуска 
	Если ПустаяСтрока(СтрокаПараметровЗапуска) Тогда
		Возврат Ложь; // Нет параметров - пусть дальше работает штатно
	КонецЕсли;
	
	ПравоДоступаАдминистрированиеМетаданных = ПравоДоступа("Администрирование", Метаданные);
	ПраваРобота = НЕ ПравоДоступа("Администрирование", Метаданные) И ПравоДоступа("ОбновлениеКонфигурацииБазыДанных", Метаданные);
	ПравоЗапуска = ПравоДоступаАдминистрированиеМетаданных ИЛИ ПраваРобота;
	// Приводим строку параметра к верхнему регистру для выполнения сравнений и поиска подстрок
	ТекПараметрЗапуска = Врег(СтрокаПараметровЗапуска);
	
	Если ЗапускДоОбновления Тогда
		// сначала "СРОЧНЫЕ" операции
		// Варианты параметра запуска
		Если Найти(ТекПараметрЗапуска, Врег("AllowLogonInToBase")) > 0 Тогда //Разрешение работы всех пользователей
			Если НЕ ПравоЗапуска Тогда
				Сообщить("Параметр запуска не отработан. Нет прав на администрирование информационной базы.", СтатусСообщения.Внимание);
				ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Ошибка, , , "Параметр запуска """+ТекПараметрЗапуска+""" - не отработан. Нет прав на администрирование информационной базы.");
				ЗавершитьРаботуСистемы(Ложь);  // Не смог отработать команду - все равно пусть этот служебный сеанс "отваливается"
				Возврат Истина;
			КонецЕсли; 
			ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Информация, , , ТекПараметрЗапуска);
		    сфРазрешитьРаботуПользователей();
			ЗавершитьРаботуСистемы(Ложь);  // Все равно пусть этот служебный сеанс "отваливается" как можно скорее
			Возврат Истина;
			
		ИначеЕсли ТекПараметрЗапуска = Врег("LogOffAllUsers") Тогда //Отключение всех пользователей
			// если завершение 
			Если Не ПравоЗапуска Тогда
				Сообщить("Параметр запуска не отработан. Нет прав на администрирование информационной базы.", СтатусСообщения.Внимание);
				ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Ошибка, , , "Параметр запуска """+ТекПараметрЗапуска+""" - не отработан. Нет прав на администрирование информационной базы.");
				Возврат Истина; // Не смог отработать команду - все равно пусть этот служебный сеанс "отваливается"
			КонецЕсли; 
			ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Информация, , , ТекПараметрЗапуска);
			// Для пользователя "Робот" не запускается такой обработчик, но мы все равно сделаем контрольный выстрел
			ОтключитьОбработчикОжидания("сфКонтрольРежимаЗавершенияРаботыПользователей");
			Состояние("Устанавливаем режим блокировки соединений с ИБ");
			Таймаут = Константы.ТаймаутЗавершенияРаботыПользователей.Получить();
			пвПривилегированныйМодуль.УстановитьБлокировкуСоединений(,,,,Таймаут);
			Состояние("Ожидаем завершения работы пользователей...");
			РезультатОжидания = Ложь; // флаг успешного завершения работы всех пользователей, кроме текущего
			сфОжиданиеЗавершенияРаботыПользователей(РезультатОжидания);
			// если что-то не так (пользователи остались) и данный сеанс был вызван в рамках
			// сборного скрипта "выгон - обновление базы данных - снятие блокировки",
			// предостережемся от динамического обновления - проделаем фокус
			// - найдем файл скрипта и просто удалим его
			Если НЕ РезультатОжидания Тогда
				СкриптУдален = Ложь;
				одОбменДанными.УдалитьСкриптОбновления(СкриптУдален);
				Если СкриптУдален Тогда
					пвПривилегированныйМодуль.СнятьБлокировкуСоединений();
				КонецЕсли; 
				// если скрипт удалили, текущий сеанс просто завершиться и никакого обновления не будет
			КонецЕсли; 
			Состояние("Завершение собственного сеанса...");
			ЗавершитьРаботуСистемы(Ложь);  //  "отваливаемся" как можно скорее
			Возврат Истина; // Все сделано - вываливаемся
			
		ИначеЕсли Найти(ТекПараметрЗапуска, ВРЕГ("BackDoor")) > 0  Тогда
			СтрокаПараметровЗапуска=""; // А вот нам очень НЕ нужно делать обновления базы и прочие StartUp действия (отладочная функция для разработчиков)
			Возврат Истина;
			
		КонецЕсли;
		
	ИНАЧЕ  // Параметры обрабатываются после обновлений ИБ и загрузки внешних компонент
	
		Если Найти(ТекПараметрЗапуска, "EXCHANGE") = 1 Тогда // Если команда обмена так она ПЕРВАЯ и ЕДИНСТВЕННАЯ должна быть, без всяких пакетных обработок!
			// Командная строка вида "Exchange:FromSubs=У1,У3;FromMain;Repost;OutPutMain;OutPutSubs;"
			ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска.Обмен", УровеньЖурналаРегистрации.Информация, , , "Получена команда на проведение обмена: "+ТекПараметрЗапуска);
			фзФоновыеЗадания.ВыполнитьОбменПоСхеме(ТекПараметрЗапуска);
			ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска.Обмен", УровеньЖурналаРегистрации.Информация, , , "Выполнение команд обмена завершено");
			ЗавершитьРаботуСистемы(Ложь);  //  "отваливаемся" как можно скорее
			Возврат Истина;  // Все сделано - вываливаемся
			
		ИначеЕсли Найти(ТекПараметрЗапуска, ВРЕГ("RunJobSheduler")) > 0 Тогда
			// Проверим а нет ли уже других сеансов обрабатывающих задания
			НаборЗаписей = РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Режим.Установить(2); // 2 = Выполняем регламентную операцию
			НаборЗаписей.Прочитать();
			МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
			Если (НаборЗаписей.Количество() > 0) И (МассивСоединений <> НЕОПРЕДЕЛЕНО) Тогда 
				// Что-то есть нужно проверять насколько они живые теперь
				Для Каждого Запись ИЗ НаборЗаписей Цикл
					НомерСоединения = Запись.НомерСоединения;
					ИмяПользователя = Врег(СокрЛП(Запись.Пользователь.Код));
					Для Каждого Соединение ИЗ МассивСоединений Цикл
						Если (Соединение.НомерСоединения = НомерСоединения) И (ВРЕГ(СокрЛП(Соединение.Пользователь.Имя)) = ИмяПользователя) Тогда
							// Мы нашли кого-то живого кто делает уже эту самую задачку - нам здесь делать нечего
							ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Предупреждение, , , "Параметр запуска """+ТекПараметрЗапуска+""" - не отрабатывается, т.к. обнаружен другой активный сеанс, выполняющий регламентные операции. Пользователь: "+СокрЛП(Соединение.Пользователь.Имя) + " номер соединения: "+НомерСоединения);
							ЗавершитьРаботуСистемы(Ложь);  //  "отваливаемся" как можно скорее
							Возврат Истина;  // Все сделано - вываливаемся
						КонецЕсли;		
					КонецЦикла;		
				КонецЦикла;
			КонецЕсли;
			НаборЗаписей = НЕОПРЕДЕЛЕНО; МассивСоединений = НЕОПРЕДЕЛЕНО;
		    // Придется нам самим этим заняться
			сфЗапуститьОбработчикПланировщикаЗаданий();
			Возврат Ложь; // НЕ вываливаемся, подключаем все штатное что положено и дальнейшая обработка будет в обработчике ожидания выполняться
			
		ИначеЕсли Найти(ТекПараметрЗапуска, Врег("UpdateIB")) > 0 ИЛИ Найти(ТекПараметрЗапуска, Врег("SendExchangeMessage")) > 0 Тогда
			// Обновление уже прошло раньше в процедуре (ЗавершитьОбновлениеБазыДочернегоУзла)
			// а нам теперь нужно нужно просто срочно выйти
			ЗавершитьРаботуСистемы(Ложь);  //  "отваливаемся" как можно скорее
			Возврат Истина;  // Все сделано - вываливаемся
		КонецЕсли;
	КОНЕЦЕСЛИ;
	// Сюда попали - значит никак не отработали
	ЗаписьЖурналаРегистрации("ОбработкаПараметраЗапуска", УровеньЖурналаРегистрации.Предупреждение, , , "Параметр запуска """+ТекПараметрЗапуска+""" - не известен такой параметр" + ?(ЗапускДоОбновления," до "," после ") + "обновления.");
	Возврат Ложь;
	
КонецФункции // сфОбработатьПараметрЗапуска()

// Выполняет запуск обработчика ожидания при входе в систему
// пользователя Робот с параметром обработки фоновых заданий
// Имеет смысл только для файлового режима работы
//
// Параметры
// 	Интервал - Число. Интервал проверки фоновых заданий
// 	Сообщать - Булево. Флаг необходимости вывода сообщения
//
// Возвращаемое значение
//   Нет
//
Процедура сфЗапуститьОбработчикПланировщикаЗаданий(Интервал = 0, Сообщать = Истина) Экспорт
	
	Интервал = Константы.ИнтервалПроверкиЗаданий.Получить();
	Интервал = ?(Интервал < 5, 5 , Интервал); // Не буду я с таким маленьким интервалом регламентные задания выполнять 
	НомерСоединения = НомерСоединенияИнформационнойБазы();
	// SUIG - нужен запуск обработчика сразу при нажатии на кнопку запуска без ожидания
	ПодключитьОбработчикОжидания("глОбработкаПланировщикаЗаданий", 1,Истина); // первый раз выполняем однократно
	Начало = ТекущаяДата();
	// сейчас подключим с интервалом в 1 сек. Сразу по окончании вып-ия заданий обраб-к подключится
	// еще раз с необходимым интервалом
	ТекстСообщения = "Подключен обработчик регламентных операций с интервалом " + Интервал + " сек.  (Номер соединения: " + НомерСоединения + ")";
	// Отпишемся в регистр что мы такие вот взяли на себя обработку заданий
	ЗаписатьДанныеСеансаОбработчикаЗаданий(, НомерСоединения, , Начало, , ТекстСообщения);
	Если Сообщать Тогда // И в окно сообщений об этом расскажем
		Сообщить(Формат(Начало,"ДФ='дд.ММ.гггг ЧЧ:мм:сс'") + " " + ТекстСообщения);
	КонецЕсли;
КонецПроцедуры // сфЗапуститьОбработчикПланировщикаЗаданий()

// Выполняет отключение обработчика ожидания для  
// обработки фоновых заданий
// Имеет смысл только для файлового режима работы
//
// Параметры
// 	Нет
//
// Возвращаемое значение
//  Нет
//
Процедура сфОтключитьОбработчикПланировщикаЗаданий() Экспорт
	ОтключитьОбработчикОжидания("глОбработкаПланировщикаЗаданий");
	// Вычеркнем себя из списка выполняющих регламентные операции
	УдалитьДанныеСеансаОбработчикаЗаданий(ПараметрыСеанса.Пользователь,НомерСоединенияИнформационнойБазы(),2);
КонецПроцедуры // сфОтключитьОбработчикПланировщикаЗаданий()

#КонецЕсли

// ОТКЛЮЧЕНИЕ/РАЗРЕШЕНИЕ РАБОТЫ ПОЛЬЗОВАТЕЛЕЙ

// Функция возвращает список пользователей
Функция сфПолучитьПользователейДляУстановкиРежима(СписокСоединений = Неопределено, Режим = 1) Экспорт
	
	Если ПравоДоступа("Администрирование", Метаданные) Тогда
		Если СписокСоединений = Неопределено Тогда
			СписокСоединений = ПолучитьСоединенияИнформационнойБазы();
		КонецЕсли;
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(Режим) Тогда
		Режим = 1;
	КонецЕсли;

	// приведем к виду Пользователь, НомерСоединения
	// подготовим таблицу со всеми данными для отключения
	АктивныеПользователи = Новый ТаблицаЗначений;
	АктивныеПользователи.Колонки.Добавить("Пользователь", Новый ОписаниеТипов("СправочникСсылка.Пользователи"));
	АктивныеПользователи.Колонки.Добавить("НомерСоединения", Новый ОписаниеТипов("Число"));
	КС = Новый КвалификаторыСтроки(150);
	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));
	ОписаниеТиповС = Новый ОписаниеТипов(Массив, , КС);
	АктивныеПользователи.Колонки.Добавить("Текст", ОписаниеТиповС);
	АктивныеПользователи.Колонки.Добавить("Режим", Новый ОписаниеТипов("Число"));
	
	Если НЕ ПравоДоступа("Администрирование", Метаданные) Тогда
		Возврат АктивныеПользователи;
	КонецЕсли;
	
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для Каждого ТекСтрока Из СписокСоединений Цикл
		// найти пользователя в справочнике
		ТекПользователь = Справочники.Пользователи.НайтиПоКоду(ТекСтрока.Код);
		ТекНомерСоединения = ТекСтрока.НомерСоединения;
		// отсекаем тех, кого не можем отключить
		// причем служеб. пользователя Робот оставляем в списке для отключения
		// причина - в файл-сервер.варианте неясно как его отключить удаленно
		// средствами 1С, например, для обновления конфигурации (не лезть же
		// в Открытые сеансы Windows и рубить его там...)
		Если НЕ ТекСтрока.ИмяПриложения = "1CV8" Тогда
			Сообщить("Соед. № " + ТекНомерСоединения + ": отключить можно только пользователя, работающего в режиме ""1С:Предприятие""", СтатусСообщения.Внимание);
			Продолжить;
		ИначеЕсли ТекНомерСоединения = НомерТекущегоСоединения Тогда 
			Сообщить("Соед. № " + ТекНомерСоединения + ": это текущее соединение", СтатусСообщения.Внимание);
			Продолжить;            
		ИначеЕсли ТекПользователь.Пустая() Тогда
			Сообщить("Соед. № " + ТекНомерСоединения + ": невозможно отключить пользователя, отсутствующего в справочнике ""Пользователи""", СтатусСообщения.Внимание);
			Продолжить;
		КонецЕсли;
		
		// пользователя можно отключать
		НоваяСтрока 				= АктивныеПользователи.Добавить();
		НоваяСтрока.Пользователь 	= ТекПользователь;
		НоваяСтрока.НомерСоединения = ТекНомерСоединения;
		НоваяСтрока.Режим 			= Режим;
	КонецЦикла;
	
	// проверим, есть ли кто для отключения
	Если АктивныеПользователи.Количество()=0 Тогда
		Сообщить("Нет выбранных пользователей для отключения", СтатусСообщения.Информация);
		Возврат АктивныеПользователи;
	КонецЕсли;
    	
	// даем админу ввести свой текст сообщения пользователям
	ТекстСообщения = "";
	Если Режим = 1 Тогда
		ТекстСообщения = "Внимание!
		|Через NNN минут работа с базой будет принудительно завершена!
		|Просьба сохранить измененные данные и завершить работу системы!";
		#Если Клиент Тогда	
			Если НЕ ВвестиСтроку(ТекстСообщения, "Введите текст сообщения пользователю", 0, Истина) Тогда
				АктивныеПользователи.Очистить();
				Возврат АктивныеПользователи; // последний шанс для отмены.. 
			КонецЕсли;
		#КонецЕсли
	ИначеЕсли Режим = 4 Тогда
		ТекстСообщения = "Внимание!
		|Работа пользователя будет принудительно завершена";
	КонецЕсли;
	АктивныеПользователи.ЗаполнитьЗначения(ТекстСообщения, "Текст");
	
	Возврат АктивныеПользователи;

КонецФункции

//Устанавливаем режим отключения пользователей (завершение работы системы)
//Параметры:
//	АктивныеПользователи - таблица - поля "Пользователь", "НомерСоединения"
//	флПредупреждать - Булево - если Истина, то перед отключением будет выдаваться предупреждение,
//	иначе отключение производится сразу без предупреждения
//	Сообщение - Строка - текст предупреждения об отключении
Процедура сфУстановитьРежимОтключенияПользователей(АктивныеПользователи) Экспорт
	
	Если НЕ ЗначениеЗаполнено(АктивныеПользователи) Тогда
		Возврат; // что-то не то передали
	КонецЕсли;
	// все проверки были сделаны ранее, просто пишем в регистр
	// через набор записей
	НаборЗаписей = РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
	Для Каждого ТекПользователь Из АктивныеПользователи Цикл
		НоваяЗапись = НаборЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяЗапись, ТекПользователь); 
		ЗаписьЖурналаРегистрации("Отключение пользователя", УровеньЖурналаРегистрации.Предупреждение, , ,
			"Пользователь """+СокрЛП(ТекПользователь.Пользователь)+"""" + ", соед.№ " + СокрЛП(ТекПользователь.НомерСоединения));
	КонецЦикла;
	НаборЗаписей.Записать();
	
КонецПроцедуры // сфУстановитьРежимОтключенияПользователей

//Удаляет запись об отключении пользователей
//Параметры:
//	Пользователь_ - справочникссылка - пользователь, которому разрешается работа. Если не указан, то текущий
//	НомерСоединения_ - число - номер соединения с ИБ. Если не указан, то текущее
Функция сфРазрешитьРаботуПользователя(Пользователь,ТекстСообщения="") Экспорт
		
	Если НЕ ЗначениеЗаполнено(Пользователь) ИЛИ (ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")) Тогда
		ТекстСообщения="Некорректное значение в первом параметре (Пользователь)";
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Ошибка, , ,ТекстСообщения);
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		ТЗ="ВЫБРАТЬ ПЕРВЫЕ 1
		   |	РежимРаботы.Текст КАК Сообщение,
		   |	РежимРаботы.Режим КАК Режим
		   |ИЗ
		   |	РегистрСведений.РежимыРаботыПользователей КАК РежимРаботы
		   |ГДЕ
		   |	РежимРаботы.Пользователь = &Пользователь
		   |	И (РежимРаботы.Режим = 1 ИЛИ РежимРаботы.Режим = 4)";
		   
		Запрос=Новый Запрос(ТЗ);
		Запрос.УстановитьПараметр("Пользователь",Пользователь);
		РезультатЗапроса = Запрос.Выполнить();
		Если РезультатЗапроса.Пустой() Тогда
			Результат=Истина;
			ТекстСообщения="Аккаунт пользователя """+ Пользователь + """ не был заблокирован.";
			ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Информация, , ,ТекстСообщения);
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			ТекРежим = Выборка.Режим;
			НаборЗаписей=РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
			НаборЗаписей.Отбор.Режим.Установить(ТекРежим);
			НаборЗаписей.Очистить();
			НаборЗаписей.Записать();
			Результат=Истина;
			ТекстСообщения="Отменена блокировка работы пользователя """+СокрЛП(Пользователь)+"""";
			ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Информация, , ,ТекстСообщения);
		КонецЕсли;
	Исключение
		Результат=Ложь;
		ТекстСообщения="Блокировка пользователя """+СокрЛП(Пользователь)+""" НЕ отменена из-за ошибки: "+обСформироватьТекстСообщения(ОписаниеОшибки());
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Ошибка, , ,ТекстСообщения);
	КонецПопытки;
	
	// Возврат результата работы
	Возврат Результат;

КонецФункции // сфРазрешитьРаботуПользователя

// Функция включает режим запрещения работы конкретного пользователя
//  возвращает (булево значение) - результат своей работы
// Параметры:
//  Пользователь	- ссылка на элемент справочника Пользователи 
//  ТекстСообщения	- строка, текст сообщения или ошибки (если возникла)
//  
Функция сфЗапретитьРаботуПользователя(Пользователь,ТекстСообщения="Ваш аккаунт доступа в программу заблокирован. Обращайтесь к администратору базы данных.") Экспорт
	
	Если НЕ ЗначениеЗаполнено(Пользователь) ИЛИ (ТипЗнч(Пользователь) <> Тип("СправочникСсылка.Пользователи")) Тогда
		ТекстСообщения="Некорректное значение в первом параметре (Пользователь)";
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Ошибка, , ,ТекстСообщения);
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		ТЗ="ВЫБРАТЬ ПЕРВЫЕ 1
		   |	РежимРаботы.Текст КАК Сообщение
		   |ИЗ
		   |	РегистрСведений.РежимыРаботыПользователей КАК РежимРаботы
		   |ГДЕ
		   |	РежимРаботы.Пользователь = &Пользователь
		   |	И (РежимРаботы.Режим = 1 ИЛИ РежимРаботы.Режим = 4)";
		   
		Запрос=Новый Запрос(ТЗ);
		Запрос.УстановитьПараметр("Пользователь",Пользователь);
		Если Запрос.Выполнить().Пустой() Тогда
			НаборЗаписей=РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Пользователь.Установить(Пользователь);
			НаборЗаписей.Отбор.Режим.Установить(1);
			НоваяЗапись=НаборЗаписей.Добавить();
			НоваяЗапись.Пользователь=Пользователь;
			НоваяЗапись.Режим=1;
			НоваяЗапись.Текст=ТекстСообщения;
			НаборЗаписей.Записать(Ложь); // нам неважно чтобы была именно одна запись, так что незачем лишний раз нагружать (очищать!) систему
		КонецЕсли;
		// Либо уже была запись по этому пользователю, либо только что внесли в любом случае результат уже положительный
		Результат=Истина;
		ТекстСообщения="Запрещена работа пользователя """+СокрЛП(Пользователь)+"""";
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Предупреждение, , ,ТекстСообщения);
	Исключение
		Результат=Ложь;
		ТекстСообщения="Работа пользователя """+СокрЛП(Пользователь)+""" не заблокирована из-за ошибки: "+обСформироватьТекстСообщения(ОписаниеОшибки());
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Ошибка, , ,ТекстСообщения);
	КонецПопытки;
	
	// Возврат результата работы
	Возврат Результат;
	
КонецФункции // сфЗапретитьРаботуПользователя

// Процедура выключает режим блокировки соединений к информационной базе
//
Процедура сфРазрешитьРаботуПользователей() экспорт
	
	Попытка 
		пвПривилегированныйМодуль.СнятьБлокировкуСоединений();
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Предупреждение, , , "Успешно снята блокировка соединений с базой");
	
		
		// Проверка есть ли временно заблокированные (всем разрешим)
		ТЗ="ВЫБРАТЬ ПЕРВЫЕ 1
		   |	РежимРаботы.Пользователь КАК Забаненный
		   |ИЗ
		   |	РегистрСведений.РежимыРаботыПользователей КАК РежимРаботы
		   |ГДЕ
		   |	РежимРаботы.Режим = 1 ИЛИ РежимРаботы.Режим = 4";
		   
		Запрос=Новый Запрос(ТЗ);
		Если Запрос.Выполнить().Пустой() Тогда
			ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Информация, , , "Не было записей о персональных блокировках пользователей");
		Иначе
			// Есть как минимум один заблокированный - будем очищать бан-лист
			НаборЗаписей=РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Режим.Установить(1);	// Отбор только по блокировке т.е. всех пользователей администируем
			НаборЗаписей.Очистить();
			НаборЗаписей.Записать();
			
			НаборЗаписей=РегистрыСведений.РежимыРаботыПользователей.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Режим.Установить(4);	// Отбор только по блокировке т.е. всех пользователей администируем
			НаборЗаписей.Очистить();
			НаборЗаписей.Записать();

			ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Информация, , , "Очищены все записи о персональных блокировках пользователей");
		КонецЕсли;
		
	Исключение
		СтрОшибка=обСформироватьТекстСообщения(ОписаниеОшибки());
		ЗаписьЖурналаРегистрации("Блокировка работы с базой", УровеньЖурналаРегистрации.Ошибка, , , СтрОшибка);
	КонецПопытки;
КонецПроцедуры	// сфРазрешитьРаботуПользователей()

// Ожидает завершения работы пользователей в течение 5 мин после начала блокировки
//или от момента вызова, после чего начинает прерывать все другие соединения кроме текущего
//
// Параметры:
//	Результат - Булево. Равен Ложь, если после всех мер по "выкидыванию"
//  	пользователей из базы в ней все же кто то остался
//
Функция сфОжиданиеЗавершенияРаботыПользователей(Результат = Истина) Экспорт
	
	// Получим текущее состояние
	РежимБлокировки = ПолучитьБлокировкуУстановкиСоединений();
	ЕстьБлокировка  = РежимБлокировки.Установлена;
	ТаймаутОжидания	= Константы.ТаймаутЗавершенияРаботыПользователей.Получить();
	ТекущийМомент = ТекущаяДата();
	
	// Получим время начала жесткого отключения соединений из режима работы
	Попытка
		СтрРежимРаботы  = СокрП(ПараметрыСеанса.РежимРаботы);
	Исключение
		СтрРежимРаботы = "";
	КонецПопытки;
	ПозицияМаркера1 = Найти(СтрРежимРаботы,"T");
	ПозицияМаркера2 = Найти(СтрРежимРаботы,";");
	ВремяОтключения = НЕОПРЕДЕЛЕНО;
	Если (ПозицияМаркера1 > 0) И (ПозицияМаркера2 > (ПозицияМаркера1+18))  Тогда 
		Попытка 
			ВремяОткСтрокой = Сред(СтрРежимРаботы,ПозицияМаркера1+1,ПозицияМаркера2-ПозицияМаркера1-1);
			ВремяОтключения = Дата(ВремяОткСтрокой);
		Исключение КонецПопытки;
	КонецЕсли;
	// Если время отключения не назначено через режим работы (как должно было быть) то попробуем
	// "вычислить" его через "Начало" блокировки
	Если НЕ ЗначениеЗаполнено(ВремяОтключения) Тогда
		Если ЕстьБлокировка И ЗначениеЗаполнено(РежимБлокировки.Начало) Тогда
			Попытка
				ТаймаутОжидания = Число(РежимБлокировки.Параметр);
			Исключение 
				ТаймаутОжидания = Константы.ТаймаутЗавершенияРаботыПользователей.Получить();
			КонецПопытки;
			Если ТаймаутОжидания < 120 Тогда // меньше пары минут давать пользователям закончить все свои дела точно не гуманно
				ТаймаутОжидания = 300;		// по умолчанию 5 минут
			КонецЕсли;
			Попытка 
				ВремяОтключения = РежимБлокировки.Начало + ТаймаутОжидания;
			Исключение 
				ВремяОтключения = НЕОПРЕДЕЛЕНО;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ВремяОтключения) ИЛИ (ТипЗнч(ВремяОтключения) <> Тип("Дата")) Тогда
		ВремяОтключения = ТекущийМомент + ТаймаутОжидания; // Нигде не заполнено - начинаем рубить сразу с плеча прямо сейчас
	КонецЕсли;
	
	Если (ВремяОтключения - ТекущийМомент) > 600 Тогда	// Неправильно слишком долго "висеть" в цикле и не отдавать управление вызвавшему нас коду
		ТекстСообщения = "Функция ожидания завершения работы пользователей вызвана слишком рано, до установленного времени отключения: "+ВремяОтключения+" слишком большой интервал времени (>10 мин).";
		ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
		Результат = Ложь;
		Возврат "Ошибка: " + ТекстСообщения;
	КонецЕсли;

	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , ,"Текущее соединение N "+НомерТекущегоСоединения+". Режим блокировки соединений "+?(ЕстьБлокировка,"","НЕ")+"установлен. Время принудительного завершения соединений: "+ВремяОтключения);
	СчетчикОшибок = 0; 	// Страховка от большого числа ошибок при зацикливании
	СтрОшибка = "";		// Здесь сохраним текст ошибки исключения	
	ПодстрокиСтрокиСоединения  = обРазложитьСтрокуВМассивПодстрок(СтрокаСоединенияИнформационнойБазы(),";");
	
	ИмяАдминистратораСервера				= СокрЛП(Константы.ИмяАдминистратораСервера.Получить());
	ПарольАдминистратораСервера				= СокрЛП(Константы.ПарольАдминистратораСервера.Получить());
	НомерПортаАгента						= Константы.НомерПортаПодключенияКАгенту.Получить();	
	ИмяАдминистратораКластера 				= СокрЛП(Константы.ИмяАдминистратораКластера.Получить());
	ПарольАдминистратораКластера			= СокрЛП(Константы.ПарольАдминистратораКластера.Получить());
	ИмяАдминистратораИБ 					= СокрЛП(Константы.ИмяАдминистратораИБ.Получить());
	ПарольАдминистратораИБ 					= СокрЛП(Константы.ПарольАдминистратораИБ.Получить());
	
	Если обЭтоКлиентСервер() Тогда
		Если НЕ (ПодстрокиСтрокиСоединения.Количество()> 1 и Лев(ПодстрокиСтрокиСоединения[0], 5) = "Srvr=" и Лев(ПодстрокиСтрокиСоединения[1], 4) = "Ref=") Тогда
			ТекстСообщения = "Ошибка: не удалось определить параметры подключения к серверу";
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			Сообщить(ТекстСообщения,СтатусСообщения.Важное);
			Возврат ТекстСообщения;
		Иначе
			ИмяСервера = ВРЕГ(Сред(ПодстрокиСтрокиСоединения[0],7, СтрДлина(ПодстрокиСтрокиСоединения[0]) - 7));
			ИмяИБ      = ВРЕГ(Сред(ПодстрокиСтрокиСоединения[1],6, СтрДлина(ПодстрокиСтрокиСоединения[1]) - 6));
		КонецЕсли;
	КонецЕсли; 
	
	Попытка
		NewCOM = Новый COMОбъект("V8ServerUtils.ServerUtils");
		//NewCOM.Basename = ";
		NewCOM.Sleep(3000,0);
	Исключение
		ТекстОшибки = ИнформацияОбОшибке().Описание;
		Останов = 1;
	КонецПопытки;
	
	ИмяСервераЗащиты=СокрЛП(Константы.СерверЛицензирования.Получить());
	ПозРазд=Найти(ИмяСервераЗащиты,":");
	Если ПозРазд>0 Тогда
		ИмяСервераЗащиты=Лев(ИмяСервераЗащиты,ПозРазд-1);
	КонецЕсли;
	ИмяВременногоФайла = КаталогВременныхФайлов() + "_httpOutFile.htmL";

		
	Пока Истина Цикл	 // Главный цикл ожидания (пока не отрубим всех или не решим что хватит "висеть" в этом цикле)
		
		Если (СчетчикОшибок >= 50) Тогда // Контроль по большому числу ошибок, для исключения массовых ошибок в цикле
			ТекстСообщения = "Не удалось отключить сессии пользователей, процедура прервана из-за большого числа накопленных ошибок.";
			ТекстСообщения = ТекстСообщения +?(ПустаяСтрока(СтрОшибка),""," Описание последней ошибки: "+СтрОшибка);
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			Возврат "Ошибка: " + ТекстСообщения;
		КонецЕсли;
		
		ТекущийМомент = ТекущаяДата();
		Если ТекущийМомент > (ВремяОтключения + 360) Тогда		// контроль по большому времени выполнения (страховка)
			ТекстСообщения = "Не удалось отключить сессии пользователей, процедура прервана из-за превышения времени своей работы (>6 мин.)";
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			Возврат "Ошибка: Слишком долго пытаемся отключить - таймаут (6 мин.) истек, процедура прервана.";
		КонецЕсли;
		
		Попытка	// COM-соединения такая штука не всегда знаешь что еще может случиться, будем считать наши ошибки на всякий случай
			
			ЗадержкаНужна = Истина; // Подождем еще пока соединения отвалятся в пул
			Попытка
				Нач = Строка(ТекущаяДата());
				Прокси		= Новый ИнтернетПрокси(Ложь);
				Соединение = Новый HTTPСоединение("wertretrt.ertertrte",,,,Прокси); // ИмяСервераЗащиты
				Соединение.Получить("/_ResultFile","D:\Temp\_Result.html"); //ИмяВременногоФайла);
				ЗадержкаНужна = Ложь;
			Исключение 
				ТекстОшибки = ИнформацияОбОшибке().Описание;
				tmp=1;
			КонецПопытки;
			Кон = Строка(ТекущаяДата());
			Если ЗадержкаНужна Тогда
				Рез = 0;
				Для Инд = 1 По 1000000 Цикл
					Рез = Рез + 1; 
				КонецЦикла;
			КонецЕсли;
			
	        // Получим число соединений с нашей базой на данный момент
			Соединения = ПолучитьСоединенияИнформационнойБазы();
			Если Соединения = НЕОПРЕДЕЛЕНО Тогда
				ТекстСообщения = "Не удалось получить список соединений с текущей базой - возможно нет права на получение списка активных пользователей";
				ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
				Результат = Ложь;
				Возврат "Ошибка: " + ТекстСообщения;
			Иначе
				ЧислоСоединений = Соединения.Количество();
				// Если остались консоли - их не считаем - они нам не помеха
				Для каждого Соединение Из Соединения Цикл
					ИмяПриложения = ВРЕГ(Соединение.ИмяПриложения);
					Если (Найти(ВРег(ИмяПриложения),"SRVRCONSOLE") > 0) Тогда
						ЧислоСоединений = ЧислоСоединений - 1;
					КонецЕсли;
				КонецЦикла;	
				Если (НЕ ЧислоСоединений > 1) Тогда
					// Отключены все пользователи, кроме одного т.е. нашего текущего сеанса - отлично!
					ТекстСообщения = "Зафиксирован только один активный сеанс - текущий, Все Ок";
					ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Информация, , , ТекстСообщения);
					Результат = Истина;
					Возврат "Все Ок - мы одни остались";
				КонецЕсли;
			КонецЕсли; 
			
			// в файловом режиме, к сожалению, принудительно выкинуть пользователей не выйдет
			Если НЕ обЭтоКлиентСервер() Тогда
				// Подождем - просто больше ничего не остается как только ждать
				Если (ТекущийМомент < ВремяОтключения) Тогда
					ЗадержкаНужна = Истина;
					Попытка
						Соединение = Новый HTTPСоединение(ИмяСервераЗащиты,11998);
						Соединение.Получить("/",ИмяВременногоФайла);
						ЗадержкаНужна = Ложь;
					Исключение 
					КонецПопытки;
					Если ЗадержкаНужна Тогда
						Рез = 0;
						Для Инд = 1 По 2000000 Цикл
							Рез = Рез + 1; 
						КонецЦикла;
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
				
			Иначе // а вот клиент-сервере можно рубить соединения 
				Если (ТекущийМомент < ВремяОтключения) Тогда
					// Еще рано "рубить" сплеча, подождем еще сознательных пользователей, которые сами выйдут все-таки
					ЗадержкаНужна = Истина;
					Попытка
						Соединение = Новый HTTPСоединение(ИмяСервераЗащиты,11998);
						Соединение.Получить("/",ИмяВременногоФайла);
						ЗадержкаНужна = Ложь;
					Исключение 
					КонецПопытки;
					Если ЗадержкаНужна Тогда
						Рез = 0;
						Для Инд = 1 По 1000000 Цикл
							Рез = Рез + 1; 
						КонецЦикла;
					КонецЕсли;
				Иначе
					// Настало время со всеми поступать жестоко, причем может быть даже ногами
					ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , ,
					"Начало принудительного завершения работы: " + Строка(ТекущийМомент) + "."
					+ "Наше соединение N " + НомерТекущегоСоединения);
					ЕстьРегАгент = Ложь;	// Есть ли у нас регистрация агента
					ComConnector = Новый COMОбъект(сфПолучитьИмяCOMСоединителя());
					// Подключаемся к агенту сервера 1С Предприятия
					ConToAgent1C = ComConnector.ConnectAgent("TCP://"+ИмяСервера+?(НомерПортаАгента>0 И Найти(ИмяСервера,":") = 0,":"+XMLСтрока(НомерПортаАгента),""));
					// Аутентиф. как администратор центрального сервера
					ConToAgent1C.AuthenticateAgent(ИмяАдминистратораСервера,ПарольАдминистратораСервера);
					// Получим список кластеров и в нем найдем свой, в котором мы сейчас работаем
					ClustersArray
					= ConToAgent1C.GetClusters();
					Для ТекущийИндекс = ClustersArray.GetLowerBound() По ClustersArray.GetUpperBound() Цикл
						// Среди множества прописанных кластеров (ну а вдруг :-) нам нужен только один
						Cluster = ClustersArray.GetValue(ТекущийИндекс);
						Если (ВРЕГ(Cluster.HostName) = ИмяСервера) Тогда // вот именно этот нас вполне устроит
							Прервать; // так что никакие другие кластеры нам не нужны
						КонецЕсли
					КонецЦикла;
					// А если не имеем кластер то и делать нам дальше нечего
					Если Cluster = НЕОПРЕДЕЛЕНО Тогда
						СтрОшибка = "Не удалось определить рабочий кластер серверов 1С предприятия";
						СчетчикОшибок = СчетчикОшибок + 1;
						Продолжить;
					КонецЕсли;
					// Попытаемся аутентифицироваться как администраторы кластера 
					Если НЕ ЕстьРегАгент Тогда
						Попытка // Тогда от спец-пользователя
							ConToAgent1C.Authenticate(Cluster,ИмяАдминистратораКластера,ПарольАдминистратораКластера);
							ЕстьРегАгент=Истина;
						Исключение
							СтрОшибка = ОписаниеОшибки();
						КонецПопытки;
					КонецЕсли;
					// Обойдем все сервера и их рабочие процессы 
					WorkingServers = ConToAgent1C.GetWorkingServers(Cluster);
					Для Каждого CurrentServer Из WorkingServers Цикл
						WorkingProcesses = ConToAgent1C.GetServerWorkingProcesses(Cluster, CurrentServer);
						Если WorkingProcesses <> НЕОПРЕДЕЛЕНО Тогда
							Для Каждого CurrentProcess Из WorkingProcesses Цикл
								Если CurrentProcess.Running <> 1 Тогда
									Продолжить; // Этот процесс сейчас не работает так что нам не интересен
								КонецЕсли;
								ЕстьРегПроцесса  = Ложь;
								СтрокаСоединения = "TCP://"+CurrentProcess.HostName+":"+XMLСтрока(CurrentProcess.MainPort);
								ConToCurrProcess = ComConnector.ConnectWorkingProcess(СтрокаСоединения);
								Если ConToCurrProcess <> Неопределено Тогда
									InfoBasesArray = ConToCurrProcess.GetInfoBases();
									Если InfoBasesArray  <> НЕОПРЕДЕЛЕНО Тогда
										Для Каждого InfoBase ИЗ InfoBasesArray Цикл
											Если ВРЕГ(InfoBase.Name) <> ИмяИБ Тогда
												Продолжить; // Это не наша база - пропускаем
											КонецЕсли;
											// Восстановим админское подключение к базе (в случае ошибки и при переходе на другой рабочий процесс)
											Если НЕ ЕстьРегПроцесса Тогда
												Попытка
													ConToCurrProcess.AddAuthentication(ИмяАдминистратораИБ, ПарольАдминистратораИБ);
													ЕстьРегПроцесса=Истина;
												Исключение
													СтрОшибка=ОписаниеОшибки();
												КонецПопытки;
											КонецЕсли;
											// Получим и обойдем все соединения с нашей базой в текущем рабочем процессе
											IBaseConnArray=ConToCurrProcess.GetInfoBaseConnections(InfoBase);
											Если IBaseConnArray<>НЕОПРЕДЕЛЕНО Тогда
												Для Каждого IBaseConn Из IBaseConnArray Цикл
													UserName = IBaseConn.UserName;
													ConnID	 = IBaseConn.ConnID;
													AppID    = ВРЕГ(IBaseConn.AppID);
													Если (UserName = ИмяПользователя()) И (ConnID = НомерТекущегоСоединения) Тогда
														Продолжить; // Это сеанс текущего пользователя - его не трогаем
													КонецЕсли;
													Если (UserName = ИмяАдминистратораИБ) И (Найти(AppID,"COM") > 0) Тогда
														Продолжить; // А это наш собственное подключение так что не будем рубить сук на котором сидим
													КонецЕсли;
													//Если (Найти(AppID,"SRVRCONSOLE") > 0) Тогда
													//	Продолжить; // если консоль кластера - оставим для подглядывания через консоль
													//КонецЕсли;
													Попытка
														ConToCurrProcess.Disconnect(IBaseConn);
														ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , ,
														"Отключено соединение: " + "User=["+UserName+"] ConnID=["+ConnID+"] AppID=["+AppID+"]");
													Исключение
														ЕстьРегПроцесса=Ложь;
													КонецПопытки;
												КонецЦикла; // По соединениям с текущей базой
												// Аккуратно подчищаем за собой объекты
												IBaseConn=НЕОПРЕДЕЛЕНО;
												IBaseConnArray=НЕОПРЕДЕЛЕНО;
											КонецЕсли;
										КонецЦикла; // По базам с которым есть соединения в текущем рабочем процессе сервера
										// Аккуратно подчищаем за собой объекты
										InfoBase=НЕОПРЕДЕЛЕНО;
										InfoBasesArray=НЕОПРЕДЕЛЕНО;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла; // по рабочим процессам сервера
						КонецЕсли;
						// Аккуратно подчищаем за собой объекты
						ConToCurrProcess=НЕОПРЕДЕЛЕНО;
						CurrentProcess=НЕОПРЕДЕЛЕНО;
						WorkingProcesses=НЕОПРЕДЕЛЕНО;
						
					КонецЦикла; // по серверам
					//Прервать;
				КонецЕсли; // если истекло время добровольного выхода
				
				
			КонецЕсли; // Если обКлиентСервер()
			
		Исключение
			СтрОшибка = ОписаниеОшибки();
			СчетчикОшибок = СчетчикОшибок + 1;
			сфСообщитьОбОшибке(СтрОшибка);
			Результат = Ложь;
		КонецПопытки;
		// И еще раз подчищаем за собой все объекты
		ConToCurrProcess=НЕОПРЕДЕЛЕНО;
		CurrentProcess=НЕОПРЕДЕЛЕНО;
		WorkingProcesses=НЕОПРЕДЕЛЕНО;
		
	КонецЦикла; // Главный цикл ожидания (пока не отрубим всех или не решим что хватит "висеть" в этом цикле)
	
	// Конец работы функции, анализ достигнутых результатов
	ЗадержкаНужна = Истина;
	Попытка
		Соединение = Новый HTTPСоединение(ИмяСервераЗащиты,11998);
		Соединение.Получить("/",ИмяВременногоФайла);
		ЗадержкаНужна = Ложь;
	Исключение 
	КонецПопытки;
	Если ЗадержкаНужна Тогда
		Рез = 0;
		Для Инд = 1 По 2000000 Цикл
			Рез = Рез + 1; 
		КонецЦикла;
	КонецЕсли;

	// Проверяем сколько у нас осталось текущих соединений
	Соединения = ПолучитьСоединенияИнформационнойБазы();
	ЧислоСоединений = Соединения.Количество();
	// Если остались консоли - их не считаем - они нам не помеха
	Для каждого Соединение Из Соединения Цикл
		ИмяПриложения = ВРЕГ(Соединение.ИмяПриложения);
		Если (Найти(ВРег(ИмяПриложения),"SRVRCONSOLE") > 0) Тогда
			 ЧислоСоединений = ЧислоСоединений - 1;
		КонецЕсли;
	КонецЦикла;	
		
	Если ЧислоСоединений > 1 Тогда
		Для каждого Соединение Из Соединения Цикл
			ИмяПользователя = СокрЛП(Соединение.Пользователь);
			НомерСоединения = СокрЛП(Соединение.НомерСоединения);
			Если Не Соединение.НомерСоединения = НомерСоединенияИнформационнойБазы() Тогда
				Сообщение = "Не удалось разорвать соединение N " + НомерСоединения + " пользователя " + ИмяПользователя;
				Сообщить(Сообщение, СтатусСообщения.Внимание);
				ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , , Сообщение);
			КонецЕсли;
		КонецЦикла; 
		
		Сообщение = "Не удалось завершить все сеансы пользователей. Осталось всего соединений: "+ЧислоСоединений+" (включая текущее N "+НомерТекущегоСоединения+" )";
		Сообщить(Сообщение, СтатусСообщения.Важное);	// Пусть вызвавший завершение работы всех пользователей администратор увидит проблему
		ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , Сообщение);
		Результат = Ложь; // предостережемся от динамического обновления
		Возврат "Ошибка: " + Сообщение;	// Возврат результата полезен если данная функция была вызвана из COM-соединения 
	Иначе
		ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Информация, , , "Все соединения кроме текущего (N "+XMLСтрока(НомерТекущегоСоединения)+") завершены успешно.");
		Сообщить("Завершение рабочих сеансов пользователей выполнено успешно.", СтатусСообщения.Информация);
		Результат = Истина; // динамическое обновление теперь не грозит
		Возврат "Все сеансы успешно отключены, Ок";	// Возврат результата полезен если данная функция была вызвана из COM-соединения
	КонецЕсли;
	
КонецФункции // сфОжиданиеЗавершенияРаботыПользователей

// Функция определяет включен ли режим запрещения работы конкретного пользователя
//  возвращает (булево значение) - результат блокировка (Истина если пользователь заблокирован)
// Параметры:
//  Пользователь	- ссылка на элемент справочника Пользователи 
//  ТекстСообщения	- строка, текст сообщения или ошибки (если возникла)
//  
Функция сфРаботаПользователяЗапрещена(Пользователь,ТекстСообщения="") Экспорт
	
	Результат = Ложь;	
	ТЗ="ВЫБРАТЬ ПЕРВЫЕ 1
	|	РежимРаботы.Текст КАК Сообщение
	|ИЗ
	|	РегистрСведений.РежимыРаботыПользователей КАК РежимРаботы
	|ГДЕ
	|	РежимРаботы.Пользователь = &Пользователь
	|	И РежимРаботы.Режим = 1 ИЛИ РежимРаботы.Режим = 4";
	
	Запрос=Новый Запрос(ТЗ);
	Запрос.УстановитьПараметр("Пользователь",Пользователь);
	РезультатЗапроса = Запрос.Выполнить();
	Результат = НЕ РезультатЗапроса.Пустой();
	Если Результат Тогда
		// Есть контакт - текущего пользователя в базе видеть не хотят
		Выборка=РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		ТекстСообщения = Выборка.Сообщение;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Если Сервер Тогда
	
//Завершает (принудительно) сеансы подключения в этой базе в клиент-серверном режиме работы
//Параметры:
//	Попыток - количество попыток отключения пользователей
//	Таймаут - время (сек), по истечении которого попытки отключения прекращаются
Функция сфПринудительноеОтключениеПользователейКлиентСервер(СписокСоединений, Знач Попыток = 10, Знач Таймаут = 120, флВсех = Истина) Экспорт
	
	ВремяОтключения = сфТекущаяДатаСервера();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	// получим из списка соединений массив номеров-соединений
	МассивНомеровСоединений = Новый Массив;
	
	Если ТипЗнч(СписокСоединений) = Тип("Массив") Тогда
		Для Инд = 0 По СписокСоединений.ВГраница() Цикл
			Соединение = СписокСоединений[Инд];
			Если Соединение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			МассивНомеровСоединений.Добавить(Соединение.НомерСоединения);
		КонецЦикла;
	ИначеЕсли ТипЗнч(СписокСоединений) = Тип("ТаблицаЗначений") Тогда
		Для Каждого ТекСтрока из СписокСоединений Цикл
			Если ТекСтрока.НомерСоединения = 0 Тогда
				Продолжить;
			КонецЕсли;
			МассивНомеровСоединений.Добавить(ТекСтрока.НомерСоединения);
		КонецЦикла;
	КонецЕсли;
			
	ИндексСоединения = МассивНомеровСоединений.Найти(НомерТекущегоСоединения);
	Если ИндексСоединения <> Неопределено Тогда
		МассивНомеровСоединений.Удалить(ИндексСоединения);
	КонецЕсли;
		
	Если МассивНомеровСоединений.Количество()= 0 Тогда
		Возврат "Все выбранные соединения отключены" + " (OK)";
	КонецЕсли; 
		
	СчетчикОшибок = 0; 	// Страховка от большого числа ошибок при зацикливании
	СтрОшибка = "";		// Здесь сохраним текст ошибки исключения	
	ПодстрокиСтрокиСоединения  = обРазложитьСтрокуВМассивПодстрок(СтрокаСоединенияИнформационнойБазы(),";");
	
	ИмяАдминистратораСервера				= СокрЛП(Константы.ИмяАдминистратораСервера.Получить());
	ПарольАдминистратораСервера				= СокрЛП(Константы.ПарольАдминистратораСервера.Получить());
	НомерПортаАгента						= Константы.НомерПортаПодключенияКАгенту.Получить();
	ИмяАдминистратораКластера 				= Константы.ИмяАдминистратораКластера.Получить();
	ПарольАдминистратора 					= СокрЛП(Константы.ПарольАдминистратораКластера.Получить());
	ИмяАдминистратораИБ 					= СокрЛП(Константы.ИмяАдминистратораИБ.Получить());
	ПарольАдминистратораИБ 					= СокрЛП(Константы.ПарольАдминистратораИБ.Получить());
	ТаймаутЗавершенияРаботыПользователей 	= Константы.ТаймаутЗавершенияРаботыПользователей.Получить();
	
	Если НЕ (ПодстрокиСтрокиСоединения.Количество()> 1 и Лев(ПодстрокиСтрокиСоединения[0], 5) = "Srvr=" и Лев(ПодстрокиСтрокиСоединения[1], 4) = "Ref=") Тогда
		ТекстСообщения = "Ошибка: не удалось определить параметры подключения к серверу";
		Сообщить(ТекстСообщения,СтатусСообщения.Важное);
		Возврат ТекстСообщения;
	Иначе
		ИмяСервера = ВРЕГ(Сред(ПодстрокиСтрокиСоединения[0],7, СтрДлина(ПодстрокиСтрокиСоединения[0]) - 7));
		ИмяИБ      = ВРЕГ(Сред(ПодстрокиСтрокиСоединения[1],6, СтрДлина(ПодстрокиСтрокиСоединения[1]) - 6));
	КонецЕсли;
	
	ИмяСервераЗащиты=СокрЛП(Константы.СерверЛицензирования.Получить());
	ПозРазд=Найти(ИмяСервераЗащиты,":");
	Если ПозРазд>0 Тогда
		ИмяСервераЗащиты=Лев(ИмяСервераЗащиты,ПозРазд-1);
	КонецЕсли;
	ИмяВременногоФайла = КаталогВременныхФайлов() + "_httpOutFile.htmL";
	
	Пока Истина Цикл // Главный цикл ожидания (пока не отрубим всех или не решим что хватит "висеть" в этом цикле)
		Если (СчетчикОшибок >= Попыток) Тогда // Контроль по большому числу ошибок, для "бесконечных" циклов полезно
			ТекстСообщения = "Не удалось отключить все соединения, истекло максимальное количество попыток (" + Попыток + ").";
			ТекстСообщения = ТекстСообщения +?(ПустаяСтрока(СтрОшибка),""," Описание последней ошибки: "+СтрОшибка);
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			Возврат "Ошибка: " + ТекстСообщения + " (ERR)";
		КонецЕсли;
		
		Если ВремяОтключения + Таймаут < ТекущаяДата() Тогда // контроль по большому времени выполнения (страховка)
			ТекстСообщения = "Не удалось отключить все соединения, превышен таймаут отключения";
			ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , ТекстСообщения);
			Возврат "Ошибка: Слишком долго пытаемся отключить - таймаут (120 сек.) истек, процедура прервана." + " (ERR)";
		КонецЕсли;
		
		Попытка		// COM-соединения такая штука не всегда знаешь что еще может случиться, будем считать наши ошибки на всякий случай
			ЗадержкаНужна = Истина;
			Попытка
				Соединение = Новый HTTPСоединение(ИмяСервераЗащиты,11998);
				Соединение.Получить("/",ИмяВременногоФайла);
				ЗадержкаНужна = Ложь;
			Исключение 
			КонецПопытки;
			Если ЗадержкаНужна Тогда
				Рез = 0;
				Для Инд = 1 По 1000000 Цикл
					Рез = Рез + 1; 
				КонецЦикла;
			КонецЕсли;
			
			Если флВсех Тогда
				// Получим число соединений с нашей базой на данный момент
				// т.к. отключение пользователей происходит не сразу,
				// то учтем возможные появления новых соединений во время отключения
				// **номер нового соединения после отключения старого будет гарантированно другим
				Соединения = ПолучитьСоединенияИнформационнойБазы();
				Для Инд = 0 По Соединения.ВГраница() Цикл
					Соединение = Соединения[Инд];
					Если Соединение = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Если Соединение.НомерСоединения = НомерТекущегоСоединения Тогда
						Продолжить;
					КонецЕсли;
					Если МассивНомеровСоединений.Найти(Соединение.НомерСоединения) = Неопределено Тогда
						МассивНомеровСоединений.Добавить(Соединение.НомерСоединения);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			// доп.проверка - может уже все в норме
			Если МассивНомеровСоединений.Количество()= 0 Тогда
				// Отключены все пользователи, кроме одного т.е. нашего текущего сеанса - отлично!
				Прервать;
			КонецЕсли; 
			
			// Настало время со всеми поступать жестоко, причем может быть даже ногами
			ЕстьРегАгент = Ложь;	// Есть ли у нас регистрация агента
			ComConnector = Новый COMОбъект(сфПолучитьИмяCOMСоединителя());
			ConToAgent1C = ComConnector.ConnectAgent("TCP://"+ИмяСервера+?(НомерПортаАгента>0 И Найти(ИмяСервера,":") = 0,":"+XMLСтрока(НомерПортаАгента),""));
			
			// Подключимся к кластеру					
			ClustersArray = ConToAgent1C.GetClusters();
			Для ТекущийИндекс = ClustersArray.GetLowerBound() По ClustersArray.GetUpperBound() Цикл
				// Ищем свой кластер
				Cluster = ClustersArray.GetValue(ТекущийИндекс);
				Если (ВРЕГ(Cluster.HostName) = ИмяСервера) Тогда
					Прервать; // DOOY реально тут мы имеем что единственный попавшийся кластер (или последний в списке если их несколько)
				КонецЕсли
			КонецЦикла;
			// А если не имеем кластер то и делать нам дальше нечего
			Если Cluster = НЕОПРЕДЕЛЕНО Тогда
				СтрОшибка = "Нет удалось подключиться к кластеру";
				СчетчикОшибок = СчетчикОшибок + 1;
				Продолжить;
			КонецЕсли;
			// Попробуем аутентифицироваться сначала по-умолчанию (90% устанавливающих сервер 1С не ставят пароль на кластер)
			Если ПустаяСтрока(ПарольАдминистратора) Тогда
				Попытка	// попробуем залогиниться от пустышки
					ConToAgent1C.Authenticate(Cluster,"","");
					ЕстьРегАгент=Истина;
				Исключение
					СтрОшибка = ОписаниеОшибки();
				КонецПопытки;
			КонецЕсли;
			// Если не получилось то теперь по служебному паролю
			Если НЕ ЕстьРегАгент Тогда
				Попытка // Тогда от спец-пользователя
					ConToAgent1C.Authenticate(Cluster,ИмяАдминистратораКластера,ПарольАдминистратора);
					ЕстьРегАгент=Истина;
				Исключение
					СтрОшибка = ОписаниеОшибки();
				КонецПопытки;
			КонецЕсли;
			// Обойдем все сервера и их рабочие процессы 
			WorkingServers = ConToAgent1C.GetWorkingServers(Cluster);
			Для Каждого CurrentServer Из WorkingServers Цикл
				WorkingProcesses = ConToAgent1C.GetServerWorkingProcesses(Cluster, CurrentServer);
				Если WorkingProcesses <> НЕОПРЕДЕЛЕНО Тогда
					Для Каждого CurrentProcess Из WorkingProcesses Цикл
						Если CurrentProcess.Running <> 1 Тогда
							Продолжить; // Этот процесс сейчас не работает так что нам не интересен
						КонецЕсли;
						ЕстьРегПроцесса  = Ложь;
						СтрокаСоединения = "TCP://"+CurrentProcess.HostName+":"+XMLСтрока(CurrentProcess.MainPort);
						ConToCurrProcess = ComConnector.ConnectWorkingProcess(СтрокаСоединения);
						Если ConToCurrProcess <> Неопределено Тогда
							InfoBasesArray = ConToCurrProcess.GetInfoBases();
							Если InfoBasesArray  <> НЕОПРЕДЕЛЕНО Тогда
								Для Каждого InfoBase ИЗ InfoBasesArray Цикл
									Если ВРЕГ(InfoBase.Name) <> ИмяИБ Тогда
										Продолжить; // Это не наша база - пропускаем
									КонецЕсли;
									// Восстановим админское подключение к базе (в случае ошибки и при переходе на другой рабочий процесс)
									Если НЕ ЕстьРегПроцесса Тогда
										Попытка
											ConToCurrProcess.AddAuthentication(ИмяАдминистратораИБ, ПарольАдминистратораИБ);
											ЕстьРегПроцесса=Истина;
										Исключение
											СтрОшибка=ОписаниеОшибки();
										КонецПопытки;
									КонецЕсли;
									// Получим и обойдем все соединения с нашей базой в текущем рабочем процессе
									IBaseConnArray=ConToCurrProcess.GetInfoBaseConnections(InfoBase);
									Если IBaseConnArray<>НЕОПРЕДЕЛЕНО Тогда
										Для Каждого IBaseConn Из IBaseConnArray Цикл
											UserName = IBaseConn.UserName;
											ConnID	 = IBaseConn.ConnID;
											AppID    = ВРЕГ(IBaseConn.AppID);
											Если (UserName = ИмяПользователя()) И (ConnID = НомерТекущегоСоединения) Тогда
												Продолжить; // Это сеанс текущего пользователя - его не трогаем
											КонецЕсли;
											Если (UserName = ИмяАдминистратораИБ) И (Найти(AppID,"COM") > 0) Тогда
												Продолжить; // А это наш собственное подключение так что не будем рубить сук на котором сидим
											КонецЕсли;
											//Если (Найти(AppID,"SRVRCONSOLE") > 0) Тогда
											//	Продолжить; // если консоль кластера - оставим для подглядывания через консоль
											//КонецЕсли;
											Попытка
												
												ИндексСоединения = МассивНомеровСоединений.Найти(ConnID);
												Если ИндексСоединения <> Неопределено Тогда	
													ConToCurrProcess.Disconnect(IBaseConn);
													МассивНомеровСоединений.Удалить(ИндексСоединения); // удалим из массива отключаемых соединений
													ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , ,
														"Отключено соединение: " + "User=["+UserName+"] ConnID=["+ConnID+"] AppID=["+AppID+"]");

												КонецЕсли;	
											Исключение
												ЕстьРегПроцесса=Ложь;
											КонецПопытки;
										КонецЦикла; // По соединениям с текущей базой
										// Аккуратно подчищаем за собой объекты
										IBaseConn=НЕОПРЕДЕЛЕНО;
										IBaseConnArray=НЕОПРЕДЕЛЕНО;
									КонецЕсли;
								КонецЦикла; // По базам с которым есть соединения в текущем рабочем процессе сервера
								// Аккуратно подчищаем за собой объекты
								InfoBase=НЕОПРЕДЕЛЕНО;
								InfoBasesArray=НЕОПРЕДЕЛЕНО;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла; // по рабочим процессам сервера
				КонецЕсли;
				// Аккуратно подчищаем за собой объекты
				ConToCurrProcess=НЕОПРЕДЕЛЕНО;
				CurrentProcess=НЕОПРЕДЕЛЕНО;
				WorkingProcesses=НЕОПРЕДЕЛЕНО;
				
			КонецЦикла; // по серверам
			
			
		Исключение
			СтрОшибка = ОписаниеОшибки();
			СчетчикОшибок = СчетчикОшибок + 1;
			Сообщить(СтрОшибка);
			
		КонецПопытки;
		// И еще раз подчищаем за собой все объекты
		ConToCurrProcess=НЕОПРЕДЕЛЕНО;
		CurrentProcess=НЕОПРЕДЕЛЕНО;
		WorkingProcesses=НЕОПРЕДЕЛЕНО;
		
	КонецЦикла; // Главный цикл ожидания (пока не отрубим всех или не решим что хватит "висеть" в этом цикле)
	
	// Конец работы функции, анализ достигнутых результатов
	ЗадержкаНужна = Истина;
	Попытка
		Соединение = Новый HTTPСоединение(ИмяСервераЗащиты,11998);
		Соединение.Получить("/",ИмяВременногоФайла);
		ЗадержкаНужна = Ложь;
	Исключение 
	КонецПопытки;
	Если ЗадержкаНужна Тогда
		Рез = 0;
		Для Инд = 1 По 2000000 Цикл
			Рез = Рез + 1; 
		КонецЦикла;
	КонецЕсли;
	
	
	// Проверяем сколько у нас осталось текущих соединений
	ЧислоНомеровСоединений = МассивНомеровСоединений.Количество();
	Если ЧислоНомеровСоединений = 0 Тогда
		ЧислоСоединений  = 0;
	Иначе
		Соединения = ПолучитьСоединенияИнформационнойБазы();
		// Если остались консоли - их не считаем - они нам не помеха
		Для каждого Соединение Из Соединения Цикл
			ИмяПриложения = ВРЕГ(Соединение.ИмяПриложения);
			Если (Найти(ВРег(ИмяПриложения),"SRVRCONSOLE") > 0) Тогда
				ЧислоНомеровСоединений = ЧислоНомеровСоединений - 1;
			КонецЕсли;
		КонецЦикла;
		Если ЧислоНомеровСоединений < 1 Тогда
			ЧислоСоединений  = 0;
		Иначе
			ЧислоСоединений = ЧислоНомеровСоединений;
		КонецЕсли;
	КонецЕсли;
	
	Если ЧислоСоединений <> 0 Тогда
		Для каждого Соединение Из Соединения Цикл
			ИмяПользователя = СокрЛП(Соединение.Пользователь);
			НомерСоединения = СокрЛП(Соединение.НомерСоединения);
			Если Не Соединение.НомерСоединения = НомерСоединенияИнформационнойБазы() Тогда
				Сообщение = "Не удалось разорвать соединение N " + НомерСоединения + " пользователя " + ИмяПользователя;
				Сообщить(Сообщение, СтатусСообщения.Внимание);
				ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Предупреждение, , , Сообщение);
			КонецЕсли;
		КонецЦикла; 
		
		Сообщение = "Не удалось завершить все выбранные сеансы пользователей. Осталось всего соединений: "+ЧислоСоединений+" (включая текущее N "+НомерТекущегоСоединения+" )";
		Сообщить(Сообщение, СтатусСообщения.Важное);	// Пусть вызвавший завершение работы всех пользователей администратор увидит проблему
		ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Ошибка, , , Сообщение);
		Результат = Ложь; // предостережемся от динамического обновления
		Возврат "Ошибка: " + Сообщение;	// Возврат результата полезен если данная функция была вызвана из COM-соединения 
	Иначе
		ЗаписьЖурналаРегистрации("Завершение работы пользователей", УровеньЖурналаРегистрации.Информация, , , "Все выбранные соединения кроме текущего (N "+XMLСтрока(НомерТекущегоСоединения)+") завершены успешно.");
		Сообщить("Завершение рабочих сеансов пользователей выполнено успешно.", СтатусСообщения.Информация);
		Результат = Истина; // динамическое обновление теперь не грозит
		Возврат "Все выбранные сеансы успешно отключены, Ок";	// Возврат результата полезен если данная функция была вызвана из COM-соединения
	КонецЕсли;

КонецФункции

#КонецЕсли

// Вернуть имя COM-класса для работы с 1С:Предприятием 8 через COM-соединение.
Функция сфПолучитьИмяCOMСоединителя() Экспорт
	СисИнфо = Новый СистемнаяИнформация;
	ПодстрокиВерсии = обРазложитьСтрокуВМассивПодстрок(СисИнфо.ВерсияПриложения, ".");
	Возврат "V" + ПодстрокиВерсии[0] + ПодстрокиВерсии[1] + ".COMConnector";
КонецФункции 

// ПРОЦЕДУРЫ И ФУНКЦИИ, ВЫЗЫВАЕМЫЕ ВНЕШНИМ ПРИЛОЖЕНИЕМ

	
// Установка блокировки соединений с базой
//Параметры:
//	PermitCode - код разрешения работы с базой, в обход блокировки
//	Message - сообщение блокировки, показываемое в виде предупреждения пользователю
//	StartDate - начало блокировки
//	StopDate - окончание блокировки
//	Parameter - произвольный текстовый параметр, используемый например роботом регл. операций (обмен и т.п.)
Function LockBase(PermitCode = Неопределено, Знач Message = Неопределено, StartDate = Неопределено, StopDate = Неопределено, Parameter = Неопределено) Export
	Return "S_ERROR";
EndFunction // LockBase()

// Снятие блокировки соединений с базой
Function UnLockBase() Export
	Return "S_ERROR";
EndFunction // UnLockBase()

// Отключает всех пользователей ИБ, кроме текущего. Отключение производится на уровне движка регистра
// РежимыРаботыПользователей
//Средства администрирования ИБ не позволяют отключить пользователей в файловом режиме
//Параметры:
//	Warning - предупреждать пользователей перед отключением, при предупреждении будет выдержан таймаут
//	отключения (заданный константой)
//	Message - сообщение при отключении, показываемое в виде предупреждения пользователю.
//	В сообщение может входить подстрока вида "NNN", вместо которой будет подставлено оставшееся время до
//	принудительного завершения работы
Function DisconnectAllUsers(Warning = Истина, Message = Неопределено) Export
	Return "S_ERROR";
EndFunction // DisconnectAllUsers()

// Отключает всех пользователей ИБ принудительно(!), кроме текущего. Отключение производится на 
// уровне средств администрирования ИБ
//Только на клиент-сервере (!)
//Параметры:
//	Attemtps - максимальное количество попыток отключения, если колич. попыток превысит это число,
//	то попытка отключений пользователей завершится неудачей
//	Timeout - таймаут отключения, время, по истечении которого попытка отключений пользователей
//	завершится неудачей
Function ForceDisconnectAllUsers(Attemtps = 3, Timeout = 120) Export
	Return "S_ERROR";
EndFunction // ForceDisconnectAllUsers()
